/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["App"] = factory();
	else
		root["App"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ellementul/ui-game-grid/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ellementul/ui-game-grid/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Grid: () => (/* binding */ Grid)\n/* harmony export */ });\nclass Grid extends Map {\n  constructor(baseLength) {\n    super()\n\n    this.baseLength = baseLength || 20\n    this.cell = {\n      height: 0,\n      width: 0\n    }\n\n    this.computeCells()\n\n    window.addEventListener(\"resize\", () => {\n      this.computeCells()\n      this.updateBoxes()\n    })\n  }\n\n  computeCells() {\n    const baseSide = window.screen.height < window.screen.width ? \"height\" : \"width\"\n    const otherSide = window.screen.height < window.screen.width ? \"width\" : \"height\"\n \n    this.cell[baseSide] = window.screen[baseSide] / this.baseLength\n \n    this.cell[otherSide] = window.screen[otherSide] / Math.floor(window.screen[otherSide] / this.cell[baseSide])\n  }\n\n  createBox({ name, top, right, bottom, left, centred }) {\n    name ||= \"Box\" + this.size\n    if(this.has(name))\n      throw new Error(`Box with name \"${name}\" is existed already!`)\n\n    this.set(name, new Box(name, { \n      cellWidth: this.cell.width,\n      cellHeight: this.cell.height\n    }, { \n      top, \n      right, \n      bottom, \n      left, \n      centred\n    }))\n\n    return this.get(name)\n  }\n\n  updateBoxes() {\n    for (const [name, box] of this) {\n      box.updateSize({\n        cellWidth: this.cell.width,\n        cellHeight: this.cell.height\n      })\n    }\n  }\n}\n\nclass Box {\n  constructor(name, { cellWidth, cellHeight }, { top, right, bottom, left, centred = false }) {\n    this.element = document.createElement(\"div\")\n    this.element.id = name\n    this.element.style.position = \"absolute\"\n    this.limits = { top, right, bottom, left }\n    this.centred = centred\n    document.body.appendChild(this.element)\n\n    this.updateSize({ cellWidth, cellHeight })\n\n    const randomColor = Math.floor(Math.random()*16777215).toString(16)\n    this.element.style.backgroundColor = \"#\" + randomColor\n  }\n\n  updateSize({ cellWidth, cellHeight }) {\n    if(this.centred)\n      return this.updateByCenter({ cellWidth, cellHeight })\n\n    const x1 = this.limits.left >= 0 ? this.limits.left * cellWidth : window.screen.width + this.limits.left * cellWidth\n    const x2 = this.limits.right >= 0 ? window.screen.width - this.limits.right * cellWidth : -1 * this.limits.right * cellWidth\n    const y1 = this.limits.top >= 0 ? this.limits.top * cellHeight : window.screen.height + this.limits.top * cellHeight\n    const y2 = this.limits.bottom >= 0 ? window.screen.height - this.limits.bottom * cellHeight : -1 * this.limits.bottom * cellHeight\n\n    this.element.style.width = (x2 - x1) + \"px\"\n    this.element.style.height = (y2 - y1) + \"px\"\n    this.element.style.top = y1 + \"px\"\n    this.element.style.left = x1 + \"px\"\n  }\n\n  updateByCenter({ cellWidth, cellHeight }) {\n    const cx = window.screen.width / 2\n    const cy = window.screen.height / 2\n\n    this.element.style.width = ((this.limits.left + this.limits.right) * cellWidth) + \"px\"\n    this.element.style.height = ((this.limits.top + this.limits.bottom) * cellHeight) + \"px\"\n    this.element.style.left = (cx - this.limits.left * cellWidth) + \"px\"\n    this.element.style.top = (cy - this.limits.top * cellHeight) + \"px\"\n  }\n\n  setBgColor({r = 0, g = 0, b = 0, a = 1 } = {}) {\n    this.element.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`\n  }\n\n  hidden(){\n    this.element.style.display = \"none\"\n  }\n\n  show(){\n    this.element.style.display = \"block\"\n  }\n}\n\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/ui-game-grid/index.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ \"./logging.js\");\n/* harmony import */ var _ellementul_pos_member__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ellementul/pos-member */ \"./node_modules/@ellementul/pos-member/index.js\");\n/* harmony import */ var _members_GraphRender_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./members/GraphRender/index.js */ \"./members/GraphRender/index.js\");\n/* harmony import */ var _members_ui_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./members/ui/index.js */ \"./members/ui/index.js\");\n\n\n\n\n\nconst room = new _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Room();\nroom.addMember(_ellementul_pos_member__WEBPACK_IMPORTED_MODULE_2__.POSMember);\nroom.addMember(_members_GraphRender_index_js__WEBPACK_IMPORTED_MODULE_3__.GraphRenderMember);\n// room.addMember(UIMember)\n\nconst env = new _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.UnitedEventsEnv(room);\nenv.baseUrl = \"./\";\nenv.setupLogging({\n  logging: (0,_logging__WEBPACK_IMPORTED_MODULE_1__.Logging)()\n});\nenv.build();\nenv.run();\n\n//# sourceURL=webpack://App/./index.js?");

/***/ }),

/***/ "./logging.js":
/*!********************!*\
  !*** ./logging.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logging: () => (/* binding */ Logging)\n/* harmony export */ });\nfunction Logging() {\n  return function (payload) {\n    switch (payload.message.system) {\n      default:\n        console.log(payload.message);\n    }\n  };\n}\n\n\n//# sourceURL=webpack://App/./logging.js?");

/***/ }),

/***/ "./members/GraphRender/index.js":
/*!**************************************!*\
  !*** ./members/GraphRender/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphRenderMember: () => (/* binding */ GraphRenderMember)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n/* harmony import */ var _litegraph_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./litegraph/index.js */ \"./members/GraphRender/litegraph/index.js\");\n\n\nclass GraphRenderMember extends _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Member {\n  constructor() {\n    super();\n    this.graph = new _litegraph_index_js__WEBPACK_IMPORTED_MODULE_1__.LGraph();\n    const canvas = document.createElement(\"canvas\");\n    document.body.appendChild(canvas);\n    const gCanvas = new _litegraph_index_js__WEBPACK_IMPORTED_MODULE_1__.LGraphCanvas(canvas, this.graph);\n    this.onEvent(_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.events.buildEvent, () => this.createCanvas()); // Subscribing on event\n\n    this.role = \"GraphRender\";\n  }\n  createCanvas() {\n    const LINK = \"Link\";\n\n    //node constructor class\n    function MyAddNode() {\n      this.addInput(\"Above\", LINK);\n      this.addOutput(\"Below\", LINK);\n    }\n\n    //name to show\n    MyAddNode.title = \"Point\";\n\n    //function to call when the node is executed\n    MyAddNode.prototype.onConnectInput = function () {\n      console.log(arguments);\n      this.addInput(\"Above\", LINK);\n    };\n\n    //register in the system\n    _litegraph_index_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registerNodeType(\"point\", MyAddNode);\n    const node_const = _litegraph_index_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(\"point\");\n    node_const.pos = [200, 200];\n    this.graph.add(node_const);\n\n    // node_const.connect(0, node_watch, 0 );\n  }\n}\nconst exportEvents = {// Export of your events\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/index.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/context_menu.js":
/*!*******************************************************!*\
  !*** ./members/GraphRender/litegraph/context_menu.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextMenu: () => (/* binding */ ContextMenu)\n/* harmony export */ });\n/* harmony import */ var _libs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs.js */ \"./members/GraphRender/litegraph/libs.js\");\n\n\n/**\n * ContextMenu from LiteGUI\n *\n * @class ContextMenu\n * @constructor\n * @param {Array} values (allows object { title: \"Nice text\", callback: function ... })\n * @param {Object} options [optional] Some options:\\\n * - title: title to show on top of the menu\n * - callback: function to call when an option is clicked, it receives the item information\n * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback\n * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n */\nfunction ContextMenu(values, options) {\n  options = options || {};\n  this.options = options;\n  var that = this;\n\n  //to link a menu with its parent\n  if (options.parentMenu) {\n    if (options.parentMenu.constructor !== this.constructor) {\n      console.error(\"parentMenu must be of class ContextMenu, ignoring it\");\n      options.parentMenu = null;\n    } else {\n      this.parentMenu = options.parentMenu;\n      this.parentMenu.lock = true;\n      this.parentMenu.current_submenu = this;\n    }\n  }\n  var eventClass = null;\n  if (options.event)\n    //use strings because comparing classes between windows doesnt work\n    eventClass = options.event.constructor.name;\n  if (eventClass !== \"MouseEvent\" && eventClass !== \"CustomEvent\" && eventClass !== \"PointerEvent\") {\n    console.error(\"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (\" + eventClass + \")\");\n    options.event = null;\n  }\n  var root = document.createElement(\"div\");\n  root.className = \"litegraph litecontextmenu litemenubar-panel\";\n  if (options.className) {\n    root.className += \" \" + options.className;\n  }\n  root.style.minWidth = 100;\n  root.style.minHeight = 100;\n  root.style.pointerEvents = \"none\";\n  setTimeout(function () {\n    root.style.pointerEvents = \"auto\";\n  }, 100); //delay so the mouse up event is not caught by this element\n\n  //this prevents the default context browser menu to open in case this menu was created when pressing right button\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(root, \"up\", function (e) {\n    //console.log(\"pointerevents: ContextMenu up root prevent\");\n    e.preventDefault();\n    return true;\n  }, true);\n  root.addEventListener(\"contextmenu\", function (e) {\n    if (e.button != 2) {\n      //right button\n      return false;\n    }\n    e.preventDefault();\n    return false;\n  }, true);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(root, \"down\", function (e) {\n    //console.log(\"pointerevents: ContextMenu down\");\n    if (e.button == 2) {\n      that.close();\n      e.preventDefault();\n      return true;\n    }\n  }, true);\n  function on_mouse_wheel(e) {\n    var pos = parseInt(root.style.top);\n    root.style.top = (pos + e.deltaY * options.scroll_speed).toFixed() + \"px\";\n    e.preventDefault();\n    return true;\n  }\n  if (!options.scroll_speed) {\n    options.scroll_speed = 0.1;\n  }\n  root.addEventListener(\"wheel\", on_mouse_wheel, true);\n  root.addEventListener(\"mousewheel\", on_mouse_wheel, true);\n  this.root = root;\n\n  //title\n  if (options.title) {\n    var element = document.createElement(\"div\");\n    element.className = \"litemenu-title\";\n    element.innerHTML = options.title;\n    root.appendChild(element);\n  }\n\n  //entries\n  var num = 0;\n  for (var i = 0; i < values.length; i++) {\n    var name = values.constructor == Array ? values[i] : i;\n    if (name != null && name.constructor !== String) {\n      name = name.content === undefined ? String(name) : name.content;\n    }\n    var value = values[i];\n    this.addItem(name, value, options);\n    num++;\n  }\n\n  //close on leave? touch enabled devices won't work TODO use a global device detector and condition on that\n  /*pointerListenerAdd(root,\"leave\", function(e) {\n      console.log(\"pointerevents: ContextMenu leave\");\n      if (that.lock) {\n          return;\n      }\n      if (root.closing_timer) {\n          clearTimeout(root.closing_timer);\n      }\n      root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n      //that.close(e);\n  });*/\n\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(root, \"enter\", function (e) {\n    //console.log(\"pointerevents: ContextMenu enter\");\n    if (root.closing_timer) {\n      clearTimeout(root.closing_timer);\n    }\n  });\n\n  //insert before checking position\n  var root_document = document;\n  if (options.event) {\n    root_document = options.event.target.ownerDocument;\n  }\n  if (!root_document) {\n    root_document = document;\n  }\n  if (root_document.fullscreenElement) root_document.fullscreenElement.appendChild(root);else root_document.body.appendChild(root);\n\n  //compute best position\n  var left = options.left || 0;\n  var top = options.top || 0;\n  if (options.event) {\n    left = options.event.clientX - 10;\n    top = options.event.clientY - 10;\n    if (options.title) {\n      top -= 20;\n    }\n    if (options.parentMenu) {\n      var rect = options.parentMenu.root.getBoundingClientRect();\n      left = rect.left + rect.width;\n    }\n    var body_rect = document.body.getBoundingClientRect();\n    var root_rect = root.getBoundingClientRect();\n    if (body_rect.height == 0) console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n    if (body_rect.width && left > body_rect.width - root_rect.width - 10) {\n      left = body_rect.width - root_rect.width - 10;\n    }\n    if (body_rect.height && top > body_rect.height - root_rect.height - 10) {\n      top = body_rect.height - root_rect.height - 10;\n    }\n  }\n  root.style.left = left + \"px\";\n  root.style.top = top + \"px\";\n  if (options.scale) {\n    root.style.transform = \"scale(\" + options.scale + \")\";\n  }\n}\nContextMenu.prototype.addItem = function (name, value, options) {\n  var that = this;\n  options = options || {};\n  var element = document.createElement(\"div\");\n  element.className = \"litemenu-entry submenu\";\n  var disabled = false;\n  if (value === null) {\n    element.classList.add(\"separator\");\n    //element.innerHTML = \"<hr/>\"\n    //continue;\n  } else {\n    element.innerHTML = value && value.title ? value.title : name;\n    element.value = value;\n    if (value) {\n      if (value.disabled) {\n        disabled = true;\n        element.classList.add(\"disabled\");\n      }\n      if (value.submenu || value.has_submenu) {\n        element.classList.add(\"has_submenu\");\n      }\n    }\n    if (typeof value == \"function\") {\n      element.dataset[\"value\"] = name;\n      element.onclick_callback = value;\n    } else {\n      element.dataset[\"value\"] = value;\n    }\n    if (value.className) {\n      element.className += \" \" + value.className;\n    }\n  }\n  this.root.appendChild(element);\n  if (!disabled) {\n    element.addEventListener(\"click\", inner_onclick);\n  }\n  if (!disabled && options.autoopen) {\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(element, \"enter\", inner_over);\n  }\n  function inner_over(e) {\n    var value = this.value;\n    if (!value || !value.has_submenu) {\n      return;\n    }\n    //if it is a submenu, autoopen like the item was clicked\n    inner_onclick.call(this, e);\n  }\n\n  //menu option clicked\n  function inner_onclick(e) {\n    var value = this.value;\n    var close_parent = true;\n    if (that.current_submenu) {\n      that.current_submenu.close(e);\n    }\n\n    //global callback\n    if (options.callback) {\n      var r = options.callback.call(this, value, options, e, that, options.node);\n      if (r === true) {\n        close_parent = false;\n      }\n    }\n\n    //special cases\n    if (value) {\n      if (value.callback && !options.ignore_item_callbacks && value.disabled !== true) {\n        //item callback\n        var r = value.callback.call(this, value, options, e, that, options.extra);\n        if (r === true) {\n          close_parent = false;\n        }\n      }\n      if (value.submenu) {\n        if (!value.submenu.options) {\n          throw \"ContextMenu submenu needs options\";\n        }\n        var submenu = new that.constructor(value.submenu.options, {\n          callback: value.submenu.callback,\n          event: e,\n          parentMenu: that,\n          ignore_item_callbacks: value.submenu.ignore_item_callbacks,\n          title: value.submenu.title,\n          extra: value.submenu.extra,\n          autoopen: options.autoopen\n        });\n        close_parent = false;\n      }\n    }\n    if (close_parent && !that.lock) {\n      that.close();\n    }\n  }\n  return element;\n};\nContextMenu.prototype.close = function (e, ignore_parent_menu) {\n  if (this.root.parentNode) {\n    this.root.parentNode.removeChild(this.root);\n  }\n  if (this.parentMenu && !ignore_parent_menu) {\n    this.parentMenu.lock = false;\n    this.parentMenu.current_submenu = null;\n    if (e === undefined) {\n      this.parentMenu.close();\n    } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n      ContextMenu.trigger(this.parentMenu.root, _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"leave\", e);\n    }\n  }\n  if (this.current_submenu) {\n    this.current_submenu.close(e, true);\n  }\n  if (this.root.closing_timer) {\n    clearTimeout(this.root.closing_timer);\n  }\n};\n\n//this code is used to trigger events easily (used in the context menu mouseleave\nContextMenu.trigger = function (element, event_name, params, origin) {\n  var evt = document.createEvent(\"CustomEvent\");\n  evt.initCustomEvent(event_name, true, true, params); //canBubble, cancelable, detail\n  evt.srcElement = origin;\n  if (element.dispatchEvent) {\n    element.dispatchEvent(evt);\n  } else if (element.__events) {\n    element.__events.dispatchEvent(evt);\n  }\n  //else nothing seems binded here so nothing to do\n  return evt;\n};\n\n//returns the top most menu\nContextMenu.prototype.getTopMenu = function () {\n  if (this.options.parentMenu) {\n    return this.options.parentMenu.getTopMenu();\n  }\n  return this;\n};\nContextMenu.prototype.getFirstEvent = function () {\n  if (this.options.parentMenu) {\n    return this.options.parentMenu.getFirstEvent();\n  }\n  return this.options.event;\n};\nContextMenu.isCursorOverElement = function (event, element) {\n  var left = event.clientX;\n  var top = event.clientY;\n  var rect = element.getBoundingClientRect();\n  if (!rect) {\n    return false;\n  }\n  if (top > rect.top && top < rect.top + rect.height && left > rect.left && left < rect.left + rect.width) {\n    return true;\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/context_menu.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/drag_and_scale.js":
/*!*********************************************************!*\
  !*** ./members/GraphRender/litegraph/drag_and_scale.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragAndScale: () => (/* binding */ DragAndScale)\n/* harmony export */ });\n/* harmony import */ var _libs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs.js */ \"./members/GraphRender/litegraph/libs.js\");\n\n//****************************************\n\n//Scale and Offset\nfunction DragAndScale(element, skip_events) {\n  this.offset = new Float32Array([0, 0]);\n  this.scale = 1;\n  this.max_scale = 10;\n  this.min_scale = 0.1;\n  this.onredraw = null;\n  this.enabled = true;\n  this.last_mouse = [0, 0];\n  this.element = null;\n  this.visible_area = new Float32Array(4);\n  if (element) {\n    this.element = element;\n    if (!skip_events) {\n      this.bindEvents(element);\n    }\n  }\n}\nDragAndScale.prototype.bindEvents = function (element) {\n  this.last_mouse = new Float32Array(2);\n  this._binded_mouse_callback = this.onMouse.bind(this);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(element, \"down\", this._binded_mouse_callback);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(element, \"move\", this._binded_mouse_callback);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(element, \"up\", this._binded_mouse_callback);\n  element.addEventListener(\"mousewheel\", this._binded_mouse_callback, false);\n  element.addEventListener(\"wheel\", this._binded_mouse_callback, false);\n};\nDragAndScale.prototype.computeVisibleArea = function (viewport) {\n  if (!this.element) {\n    this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n    return;\n  }\n  var width = this.element.width;\n  var height = this.element.height;\n  var startx = -this.offset[0];\n  var starty = -this.offset[1];\n  if (viewport) {\n    startx += viewport[0] / this.scale;\n    starty += viewport[1] / this.scale;\n    width = viewport[2];\n    height = viewport[3];\n  }\n  var endx = startx + width / this.scale;\n  var endy = starty + height / this.scale;\n  this.visible_area[0] = startx;\n  this.visible_area[1] = starty;\n  this.visible_area[2] = endx - startx;\n  this.visible_area[3] = endy - starty;\n};\nDragAndScale.prototype.onMouse = function (e) {\n  if (!this.enabled) {\n    return;\n  }\n  var canvas = this.element;\n  var rect = canvas.getBoundingClientRect();\n  var x = e.clientX - rect.left;\n  var y = e.clientY - rect.top;\n  e.canvasx = x;\n  e.canvasy = y;\n  e.dragging = this.dragging;\n  var is_inside = !this.viewport || this.viewport && x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] && y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3];\n\n  //console.log(\"pointerevents: DragAndScale onMouse \"+e.type+\" \"+is_inside);\n\n  var ignore = false;\n  if (this.onmouse) {\n    ignore = this.onmouse(e);\n  }\n  if (e.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"down\" && is_inside) {\n    this.dragging = true;\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(canvas, \"move\", this._binded_mouse_callback);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(document, \"move\", this._binded_mouse_callback);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(document, \"up\", this._binded_mouse_callback);\n  } else if (e.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"move\") {\n    if (!ignore) {\n      var deltax = x - this.last_mouse[0];\n      var deltay = y - this.last_mouse[1];\n      if (this.dragging) {\n        this.mouseDrag(deltax, deltay);\n      }\n    }\n  } else if (e.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"up\") {\n    this.dragging = false;\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(document, \"move\", this._binded_mouse_callback);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(document, \"up\", this._binded_mouse_callback);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(canvas, \"move\", this._binded_mouse_callback);\n  } else if (is_inside && (e.type == \"mousewheel\" || e.type == \"wheel\" || e.type == \"DOMMouseScroll\")) {\n    e.eventType = \"mousewheel\";\n    if (e.type == \"wheel\") {\n      e.wheel = -e.deltaY;\n    } else {\n      e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n    }\n\n    //from stack overflow\n    e.delta = e.wheelDelta ? e.wheelDelta / 40 : e.deltaY ? -e.deltaY / 3 : 0;\n    this.changeDeltaScale(1.0 + e.delta * 0.05);\n  }\n  this.last_mouse[0] = x;\n  this.last_mouse[1] = y;\n  if (is_inside) {\n    e.preventDefault();\n    e.stopPropagation();\n    return false;\n  }\n};\nDragAndScale.prototype.toCanvasContext = function (ctx) {\n  ctx.scale(this.scale, this.scale);\n  ctx.translate(this.offset[0], this.offset[1]);\n};\nDragAndScale.prototype.convertOffsetToCanvas = function (pos) {\n  //return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n  return [(pos[0] + this.offset[0]) * this.scale, (pos[1] + this.offset[1]) * this.scale];\n};\nDragAndScale.prototype.convertCanvasToOffset = function (pos, out) {\n  out = out || [0, 0];\n  out[0] = pos[0] / this.scale - this.offset[0];\n  out[1] = pos[1] / this.scale - this.offset[1];\n  return out;\n};\nDragAndScale.prototype.mouseDrag = function (x, y) {\n  this.offset[0] += x / this.scale;\n  this.offset[1] += y / this.scale;\n  if (this.onredraw) {\n    this.onredraw(this);\n  }\n};\nDragAndScale.prototype.changeScale = function (value, zooming_center) {\n  if (value < this.min_scale) {\n    value = this.min_scale;\n  } else if (value > this.max_scale) {\n    value = this.max_scale;\n  }\n  if (value == this.scale) {\n    return;\n  }\n  if (!this.element) {\n    return;\n  }\n  var rect = this.element.getBoundingClientRect();\n  if (!rect) {\n    return;\n  }\n  zooming_center = zooming_center || [rect.width * 0.5, rect.height * 0.5];\n  var center = this.convertCanvasToOffset(zooming_center);\n  this.scale = value;\n  if (Math.abs(this.scale - 1) < 0.01) {\n    this.scale = 1;\n  }\n  var new_center = this.convertCanvasToOffset(zooming_center);\n  var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];\n  this.offset[0] += delta_offset[0];\n  this.offset[1] += delta_offset[1];\n  if (this.onredraw) {\n    this.onredraw(this);\n  }\n};\nDragAndScale.prototype.changeDeltaScale = function (value, zooming_center) {\n  this.changeScale(this.scale * value, zooming_center);\n};\nDragAndScale.prototype.reset = function () {\n  this.scale = 1;\n  this.offset[0] = 0;\n  this.offset[1] = 0;\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/drag_and_scale.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/index.js":
/*!************************************************!*\
  !*** ./members/GraphRender/litegraph/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraph: () => (/* reexport safe */ _l_graph_class_js__WEBPACK_IMPORTED_MODULE_1__.LGraph),\n/* harmony export */   LGraphCanvas: () => (/* reexport safe */ _l_graph_canvas_js__WEBPACK_IMPORTED_MODULE_2__.LGraphCanvas),\n/* harmony export */   LiteGraph: () => (/* reexport safe */ _litegraph_class_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph)\n/* harmony export */ });\n/* harmony import */ var _litegraph_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph_class.js */ \"./members/GraphRender/litegraph/litegraph_class.js\");\n/* harmony import */ var _l_graph_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./l_graph_class.js */ \"./members/GraphRender/litegraph/l_graph_class.js\");\n/* harmony import */ var _l_graph_canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./l_graph_canvas.js */ \"./members/GraphRender/litegraph/l_graph_canvas.js\");\n\n\n\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/index.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/l_graph_canvas.js":
/*!*********************************************************!*\
  !*** ./members/GraphRender/litegraph/l_graph_canvas.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphCanvas: () => (/* binding */ LGraphCanvas)\n/* harmony export */ });\n/* harmony import */ var _libs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs.js */ \"./members/GraphRender/litegraph/libs.js\");\n/* harmony import */ var _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./litegraph_class.js */ \"./members/GraphRender/litegraph/litegraph_class.js\");\n/* harmony import */ var _l_graph_group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./l_graph_group.js */ \"./members/GraphRender/litegraph/l_graph_group.js\");\n/* harmony import */ var _context_menu_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context_menu.js */ \"./members/GraphRender/litegraph/context_menu.js\");\n/* harmony import */ var _node_colors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_colors.js */ \"./members/GraphRender/litegraph/node_colors.js\");\n/* harmony import */ var _drag_and_scale_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drag_and_scale.js */ \"./members/GraphRender/litegraph/drag_and_scale.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"./members/GraphRender/litegraph/settings.js\");\n\n\n\n\n\n\n\nconst NODE_TITLE_TEXT_Y = 20;\nconst NODE_TITLE_COLOR = \"#999\";\nconst NODE_SELECTED_TITLE_COLOR = \"#FFF\";\nconst NODE_TEXT_COLOR = \"#AAA\";\nconst NODE_SUBTEXT_SIZE = 12;\nconst NODE_DEFAULT_COLOR = \"#333\";\nconst NODE_DEFAULT_BGCOLOR = \"#353535\";\nconst NODE_DEFAULT_BOXCOLOR = \"#666\";\nconst NODE_BOX_OUTLINE_COLOR = \"#FFF\";\n\n/*********************************************************************************\n// LGraphCanvas: LGraph renderer CLASS\n//*********************************************************************************\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.\n * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked\n *\n * @class LGraphCanvas\n * @constructor\n * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)\n * @param {LGraph} graph [optional]\n * @param {Object} options [optional] { skip_rendering, viewport }\n */\nfunction LGraphCanvas(canvas, graph, options) {\n  this.options = options = options || {};\n\n  //if(graph === undefined)\n  //\tthrow (\"No graph assigned\");\n  this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n  if (canvas && canvas.constructor === String) {\n    canvas = document.querySelector(canvas);\n  }\n  this.ds = new _drag_and_scale_js__WEBPACK_IMPORTED_MODULE_5__.DragAndScale();\n  this.zoom_modify_alpha = true; //otherwise it generates ugly patterns when scaling down too much\n\n  this.title_text_font = \"\" + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TEXT_SIZE + \"px Arial\";\n  this.inner_text_font = \"normal \" + NODE_SUBTEXT_SIZE + \"px Arial\";\n  this.node_title_color = NODE_TITLE_COLOR;\n  this.default_link_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LINK_COLOR;\n  this.default_connection_color = {\n    input_off: \"#778\",\n    input_on: \"#7F7\",\n    //\"#BBD\"\n    output_off: \"#778\",\n    output_on: \"#7F7\" //\"#BBD\"\n  };\n  this.default_connection_color_byType = {\n    /*number: \"#7F7\",\n    string: \"#77F\",\n    boolean: \"#F77\",*/\n  };\n  this.default_connection_color_byTypeOff = {\n    /*number: \"#474\",\n    string: \"#447\",\n    boolean: \"#744\",*/\n  };\n  this.highquality_render = true;\n  this.use_gradients = false; //set to true to render titlebar with gradients\n  this.editor_alpha = 1; //used for transition\n  this.pause_rendering = false;\n  this.clear_background = true;\n  this.clear_background_color = \"#222\";\n  this.read_only = false; //if set to true users cannot modify the graph\n  this.render_only_selected = true;\n  this.live_mode = false;\n  this.show_info = true;\n  this.allow_dragcanvas = true;\n  this.allow_dragnodes = true;\n  this.allow_interaction = true; //allow to control widgets, buttons, collapse, etc\n  this.multi_select = false; //allow selecting multi nodes without pressing extra keys\n  this.allow_searchbox = true;\n  this.allow_reconnect_links = true; //allows to change a connection with having to redo it again\n  this.align_to_grid = false; //snap to grid\n\n  this.drag_mode = false;\n  this.dragging_rectangle = null;\n  this.filter = null; //allows to filter to only accept some type of nodes in a graph\n\n  this.set_canvas_dirty_on_mouse_event = true; //forces to redraw the canvas if the mouse does anything\n  this.always_render_background = false;\n  this.render_shadows = true;\n  this.render_canvas_border = true;\n  this.render_connections_shadows = false; //too much cpu\n  this.render_connections_border = true;\n  this.render_curved_connections = false;\n  this.render_connection_arrows = false;\n  this.render_collapsed_slots = true;\n  this.render_execution_order = false;\n  this.render_title_colored = true;\n  this.render_link_tooltip = true;\n  this.links_render_mode = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.SPLINE_LINK;\n  this.mouse = [0, 0]; //mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle\n  this.graph_mouse = [0, 0]; //mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle\n  this.canvas_mouse = this.graph_mouse; //LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n  //to personalize the search box\n  this.onSearchBox = null;\n  this.onSearchBoxSelection = null;\n\n  //callbacks\n  this.onMouse = null;\n  this.onDrawBackground = null; //to render background objects (behind nodes and connections) in the canvas affected by transform\n  this.onDrawForeground = null; //to render foreground objects (above nodes and connections) in the canvas affected by transform\n  this.onDrawOverlay = null; //to render foreground objects not affected by transform (for GUIs)\n  this.onDrawLinkTooltip = null; //called when rendering a tooltip\n  this.onNodeMoved = null; //called after moving a node\n  this.onSelectionChange = null; //called if the selection changes\n  this.onConnectingChange = null; //called before any link changes\n  this.onBeforeChange = null; //called before modifying the graph\n  this.onAfterChange = null; //called after modifying the graph\n\n  this.connections_width = 3;\n  this.round_radius = 8;\n  this.current_node = null;\n  this.node_widget = null; //used for widgets\n  this.over_link_center = null;\n  this.last_mouse_position = [0, 0];\n  this.visible_area = this.ds.visible_area;\n  this.visible_links = [];\n  this.viewport = options.viewport || null; //to constraint render area to a portion of the canvas\n\n  //link canvas and graph\n  if (graph) {\n    graph.attachCanvas(this);\n  }\n  this.setCanvas(canvas, options.skip_events);\n  this.clear();\n  if (!options.skip_render) {\n    this.startRendering();\n  }\n}\nLGraphCanvas.DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\";\nLGraphCanvas.link_type_colors = {\n  \"-1\": _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT_LINK_COLOR,\n  number: \"#AAA\",\n  node: \"#DCA\"\n};\nLGraphCanvas.gradients = {}; //cache of gradients\n\n/**\n * clears all the data inside\n *\n * @method clear\n */\nLGraphCanvas.prototype.clear = function () {\n  this.frame = 0;\n  this.last_draw_time = 0;\n  this.render_time = 0;\n  this.fps = 0;\n\n  //this.scale = 1;\n  //this.offset = [0,0];\n\n  this.dragging_rectangle = null;\n  this.selected_nodes = {};\n  this.selected_group = null;\n  this.visible_nodes = [];\n  this.node_dragged = null;\n  this.node_over = null;\n  this.node_capturing_input = null;\n  this.connecting_node = null;\n  this.highlighted_links = {};\n  this.dragging_canvas = false;\n  this.dirty_canvas = true;\n  this.dirty_bgcanvas = true;\n  this.dirty_area = null;\n  this.node_in_panel = null;\n  this.node_widget = null;\n  this.last_mouse = [0, 0];\n  this.last_mouseclick = 0;\n  this.pointer_is_down = false;\n  this.pointer_is_double = false;\n  this.visible_area.set([0, 0, 0, 0]);\n  if (this.onClear) {\n    this.onClear();\n  }\n};\n\n/**\n * assigns a graph, you can reassign graphs to the same canvas\n *\n * @method setGraph\n * @param {LGraph} graph\n */\nLGraphCanvas.prototype.setGraph = function (graph, skip_clear) {\n  if (this.graph == graph) {\n    return;\n  }\n  if (!skip_clear) {\n    this.clear();\n  }\n  if (!graph && this.graph) {\n    this.graph.detachCanvas(this);\n    return;\n  }\n  graph.attachCanvas(this);\n\n  //remove the graph stack in case a subgraph was open\n  if (this._graph_stack) this._graph_stack = null;\n  this.setDirty(true, true);\n};\n\n/**\n * returns the top level graph (in case there are subgraphs open on the canvas)\n *\n * @method getTopGraph\n * @return {LGraph} graph\n */\nLGraphCanvas.prototype.getTopGraph = function () {\n  if (this._graph_stack.length) return this._graph_stack[0];\n  return this.graph;\n};\n\n/**\n * opens a graph contained inside a node in the current graph\n *\n * @method openSubgraph\n * @param {LGraph} graph\n */\nLGraphCanvas.prototype.openSubgraph = function (graph) {\n  if (!graph) {\n    throw \"graph cannot be null\";\n  }\n  if (this.graph == graph) {\n    throw \"graph cannot be the same\";\n  }\n  this.clear();\n  if (this.graph) {\n    if (!this._graph_stack) {\n      this._graph_stack = [];\n    }\n    this._graph_stack.push(this.graph);\n  }\n  graph.attachCanvas(this);\n  this.checkPanels();\n  this.setDirty(true, true);\n};\n\n/**\n * closes a subgraph contained inside a node\n *\n * @method closeSubgraph\n * @param {LGraph} assigns a graph\n */\nLGraphCanvas.prototype.closeSubgraph = function () {\n  if (!this._graph_stack || this._graph_stack.length == 0) {\n    return;\n  }\n  var subgraph_node = this.graph._subgraph_node;\n  var graph = this._graph_stack.pop();\n  this.selected_nodes = {};\n  this.highlighted_links = {};\n  graph.attachCanvas(this);\n  this.setDirty(true, true);\n  if (subgraph_node) {\n    this.centerOnNode(subgraph_node);\n    this.selectNodes([subgraph_node]);\n  }\n  // when close sub graph back to offset [0, 0] scale 1\n  this.ds.offset = [0, 0];\n  this.ds.scale = 1;\n};\n\n/**\n * returns the visually active graph (in case there are more in the stack)\n * @method getCurrentGraph\n * @return {LGraph} the active graph\n */\nLGraphCanvas.prototype.getCurrentGraph = function () {\n  return this.graph;\n};\n\n/**\n * assigns a canvas\n *\n * @method setCanvas\n * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)\n */\nLGraphCanvas.prototype.setCanvas = function (canvas, skip_events) {\n  if (canvas) {\n    if (canvas.constructor === String) {\n      canvas = document.getElementById(canvas);\n      if (!canvas) {\n        throw \"Error creating LiteGraph canvas: Canvas not found\";\n      }\n    }\n  }\n  if (canvas === this.canvas) {\n    return;\n  }\n  if (!canvas && this.canvas) {\n    //maybe detach events from old_canvas\n    if (!skip_events) {\n      this.unbindEvents();\n    }\n  }\n  this.canvas = canvas;\n  this.ds.element = canvas;\n  if (!canvas) {\n    return;\n  }\n\n  //this.canvas.tabindex = \"1000\";\n  canvas.className += \" lgraphcanvas\";\n  canvas.data = this;\n  canvas.tabindex = \"1\"; //to allow key events\n\n  //bg canvas: used for non changing stuff\n  this.bgcanvas = null;\n  if (!this.bgcanvas) {\n    this.bgcanvas = document.createElement(\"canvas\");\n    this.bgcanvas.width = this.canvas.width;\n    this.bgcanvas.height = this.canvas.height;\n  }\n  if (canvas.getContext == null) {\n    if (canvas.localName != \"canvas\") {\n      throw \"Element supplied for LGraphCanvas must be a <canvas> element, you passed a \" + canvas.localName;\n    }\n    throw \"This browser doesn't support Canvas\";\n  }\n  var ctx = this.ctx = canvas.getContext(\"2d\");\n  if (ctx == null) {\n    if (!canvas.webgl_enabled) {\n      console.warn(\"This canvas seems to be WebGL, enabling WebGL renderer\");\n    }\n    this.enableWebGL();\n  }\n  if (!skip_events) {\n    this.bindEvents();\n  }\n  const ref_window = this.getCanvasWindow();\n  this.resize(ref_window.innerWidth, ref_window.innerHeight);\n};\n\n//used in some events to capture them\nLGraphCanvas.prototype._doNothing = function doNothing(e) {\n  //console.log(\"pointerevents: _doNothing \"+e.type);\n  e.preventDefault();\n  return false;\n};\nLGraphCanvas.prototype._doReturnTrue = function doNothing(e) {\n  e.preventDefault();\n  return true;\n};\n\n/**\n * binds mouse, keyboard, touch and drag events to the canvas\n * @method bindEvents\n **/\nLGraphCanvas.prototype.bindEvents = function () {\n  if (this._events_binded) {\n    console.warn(\"LGraphCanvas: events already binded\");\n    return;\n  }\n\n  //console.log(\"pointerevents: bindEvents\");\n\n  var canvas = this.canvas;\n  var ref_window = this.getCanvasWindow();\n  var document = ref_window.document; //hack used when moving canvas between windows\n\n  this._mousedown_callback = this.processMouseDown.bind(this);\n  this._mousewheel_callback = this.processMouseWheel.bind(this);\n  // why mousemove and mouseup were not binded here?\n  this._mousemove_callback = this.processMouseMove.bind(this);\n  this._mouseup_callback = this.processMouseUp.bind(this);\n  this._resize_callback = () => this.resize(ref_window.innerWidth, ref_window.innerHeight);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(canvas, \"down\", this._mousedown_callback, true); //down do not need to store the binded\n  canvas.addEventListener(\"mousewheel\", this._mousewheel_callback, false);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(canvas, \"up\", this._mouseup_callback, true); // CHECK: ??? binded or not\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(canvas, \"move\", this._mousemove_callback);\n  canvas.addEventListener(\"contextmenu\", this._doNothing);\n  canvas.addEventListener(\"DOMMouseScroll\", this._mousewheel_callback, false);\n\n  //Keyboard ******************\n  this._key_callback = this.processKey.bind(this);\n  canvas.setAttribute(\"tabindex\", 1); //otherwise key events are ignored\n  canvas.addEventListener(\"keydown\", this._key_callback, true);\n  document.addEventListener(\"keyup\", this._key_callback, true); //in document, otherwise it doesn't fire keyup\n\n  //Dropping Stuff over nodes ************************************\n  this._ondrop_callback = this.processDrop.bind(this);\n  canvas.addEventListener(\"dragover\", this._doNothing, false);\n  canvas.addEventListener(\"dragend\", this._doNothing, false);\n  canvas.addEventListener(\"drop\", this._ondrop_callback, false);\n  canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n  ref_window.addEventListener(\"resize\", this._resize_callback);\n  this._events_binded = true;\n};\n\n/**\n * unbinds mouse events from the canvas\n * @method unbindEvents\n **/\nLGraphCanvas.prototype.unbindEvents = function () {\n  if (!this._events_binded) {\n    console.warn(\"LGraphCanvas: no events binded\");\n    return;\n  }\n\n  //console.log(\"pointerevents: unbindEvents\");\n\n  var ref_window = this.getCanvasWindow();\n  var document = ref_window.document;\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(this.canvas, \"move\", this._mousedown_callback);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(this.canvas, \"up\", this._mousedown_callback);\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(this.canvas, \"down\", this._mousedown_callback);\n  this.canvas.removeEventListener(\"mousewheel\", this._mousewheel_callback);\n  this.canvas.removeEventListener(\"DOMMouseScroll\", this._mousewheel_callback);\n  this.canvas.removeEventListener(\"keydown\", this._key_callback);\n  document.removeEventListener(\"keyup\", this._key_callback);\n  this.canvas.removeEventListener(\"contextmenu\", this._doNothing);\n  this.canvas.removeEventListener(\"drop\", this._ondrop_callback);\n  this.canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n  ref_window.removeEventListener(\"resize\", this._resize_callback);\n  this._mousedown_callback = null;\n  this._mousewheel_callback = null;\n  this._key_callback = null;\n  this._ondrop_callback = null;\n  this._events_binded = false;\n};\nLGraphCanvas.getFileExtension = function (url) {\n  var question = url.indexOf(\"?\");\n  if (question != -1) {\n    url = url.substr(0, question);\n  }\n  var point = url.lastIndexOf(\".\");\n  if (point == -1) {\n    return \"\";\n  }\n  return url.substr(point + 1).toLowerCase();\n};\n\n/**\n * this function allows to render the canvas using WebGL instead of Canvas2D\n * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n * @method enableWebGL\n **/\nLGraphCanvas.prototype.enableWebGL = function () {\n  if (typeof GL === \"undefined\") {\n    throw \"litegl.js must be included to use a WebGL canvas\";\n  }\n  if (typeof enableWebGLCanvas === \"undefined\") {\n    throw \"webglCanvas.js must be included to use this feature\";\n  }\n  this.gl = this.ctx = enableWebGLCanvas(this.canvas);\n  this.ctx.webgl = true;\n  this.bgcanvas = this.canvas;\n  this.bgctx = this.gl;\n  this.canvas.webgl_enabled = true;\n\n  /*\n  GL.create({ canvas: this.bgcanvas });\n  this.bgctx = enableWebGLCanvas( this.bgcanvas );\n  window.gl = this.gl;\n  */\n};\n\n/**\n * marks as dirty the canvas, this way it will be rendered again\n *\n * @class LGraphCanvas\n * @method setDirty\n * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)\n * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)\n */\nLGraphCanvas.prototype.setDirty = function (fgcanvas, bgcanvas) {\n  if (fgcanvas) {\n    this.dirty_canvas = true;\n  }\n  if (bgcanvas) {\n    this.dirty_bgcanvas = true;\n  }\n};\n\n/**\n * Used to attach the canvas in a popup\n *\n * @method getCanvasWindow\n * @return {window} returns the window where the canvas is attached (the DOM root node)\n */\nLGraphCanvas.prototype.getCanvasWindow = function () {\n  if (!this.canvas) {\n    return window;\n  }\n  var doc = this.canvas.ownerDocument;\n  return doc.defaultView || doc.parentWindow;\n};\n\n/**\n * starts rendering the content of the canvas when needed\n *\n * @method startRendering\n */\nLGraphCanvas.prototype.startRendering = function () {\n  if (this.is_rendering) {\n    return;\n  } //already rendering\n\n  this.is_rendering = true;\n  renderFrame.call(this);\n  function renderFrame() {\n    if (!this.pause_rendering) {\n      this.draw();\n    }\n    var window = this.getCanvasWindow();\n    if (this.is_rendering) {\n      window.requestAnimationFrame(renderFrame.bind(this));\n    }\n  }\n};\n\n/**\n * stops rendering the content of the canvas (to save resources)\n *\n * @method stopRendering\n */\nLGraphCanvas.prototype.stopRendering = function () {\n  this.is_rendering = false;\n};\n\n/* LiteGraphCanvas input */\n\n//used to block future mouse events (because of im gui)\nLGraphCanvas.prototype.blockClick = function () {\n  this.block_click = true;\n  this.last_mouseclick = 0;\n};\nLGraphCanvas.prototype.processMouseDown = function (e) {\n  if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n  if (!this.graph) {\n    return;\n  }\n  this.adjustMouseEvent(e);\n  var ref_window = this.getCanvasWindow();\n  var document = ref_window.document;\n  LGraphCanvas.active_canvas = this;\n  var that = this;\n  var x = e.clientX;\n  var y = e.clientY;\n  //console.log(y,this.viewport);\n  //console.log(\"pointerevents: processMouseDown pointerId:\"+e.pointerId+\" which:\"+e.which+\" isPrimary:\"+e.isPrimary+\" :: x y \"+x+\" \"+y);\n\n  this.ds.viewport = this.viewport;\n  var is_inside = !this.viewport || this.viewport && x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] && y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3];\n\n  //move mouse move event to the window in case it drags outside of the canvas\n  if (!this.options.skip_events) {\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(this.canvas, \"move\", this._mousemove_callback);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(ref_window.document, \"move\", this._mousemove_callback, true); //catch for the entire window\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(ref_window.document, \"up\", this._mouseup_callback, true);\n  }\n  if (!is_inside) {\n    return;\n  }\n  var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);\n  var skip_dragging = false;\n  var skip_action = false;\n  var now = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  var is_primary = e.isPrimary === undefined || !e.isPrimary;\n  var is_double_click = now - this.last_mouseclick < 300 && is_primary;\n  this.mouse[0] = e.clientX;\n  this.mouse[1] = e.clientY;\n  this.graph_mouse[0] = e.canvasX;\n  this.graph_mouse[1] = e.canvasY;\n  this.last_click_position = [this.mouse[0], this.mouse[1]];\n  if (this.pointer_is_down && is_primary) {\n    this.pointer_is_double = true;\n    //console.log(\"pointerevents: pointer_is_double start\");\n  } else {\n    this.pointer_is_double = false;\n  }\n  this.pointer_is_down = true;\n  this.canvas.focus();\n  closeAllContextMenus(ref_window);\n  if (this.onMouse) {\n    if (this.onMouse(e) == true) return;\n  }\n\n  //left button mouse / single finger\n  if (e.which == 1 && !this.pointer_is_double) {\n    if (e.ctrlKey) {\n      this.dragging_rectangle = new Float32Array(4);\n      this.dragging_rectangle[0] = e.canvasX;\n      this.dragging_rectangle[1] = e.canvasY;\n      this.dragging_rectangle[2] = 1;\n      this.dragging_rectangle[3] = 1;\n      skip_action = true;\n    }\n\n    // clone node ALT dragging\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.alt_drag_do_clone_nodes && e.altKey && node && this.allow_interaction && !skip_action && !this.read_only) {\n      if (cloned = node.clone()) {\n        cloned.pos[0] += 5;\n        cloned.pos[1] += 5;\n        this.graph.add(cloned, false, {\n          doCalcSize: false\n        });\n        node = cloned;\n        skip_action = true;\n        if (!block_drag_node) {\n          if (this.allow_dragnodes) {\n            this.graph.beforeChange();\n            this.node_dragged = node;\n          }\n          if (!this.selected_nodes[node.id]) {\n            this.processNodeSelected(node, e);\n          }\n        }\n      }\n    }\n    var clicking_canvas_bg = false;\n\n    //when clicked on top of a node\n    //and it is not interactive\n    if (node && (this.allow_interaction || node.flags.allow_interaction) && !skip_action && !this.read_only) {\n      if (!this.live_mode && !node.flags.pinned) {\n        this.bringToFront(node);\n      } //if it wasn't selected?\n\n      //not dragging mouse to connect two slots\n      if (this.allow_interaction && !this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n        //Search for corner for resize\n        if (!skip_action && node.resizable !== false && isInsideRectangle(e.canvasX, e.canvasY, node.pos[0] + node.size[0] - 5, node.pos[1] + node.size[1] - 5, 10, 10)) {\n          this.graph.beforeChange();\n          this.resizing_node = node;\n          this.canvas.style.cursor = \"se-resize\";\n          skip_action = true;\n        } else {\n          //search for outputs\n          if (node.outputs) {\n            for (var i = 0, l = node.outputs.length; i < l; ++i) {\n              var output = node.outputs[i];\n              var link_pos = node.getConnectionPos(false, i);\n              if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n                this.connecting_node = node;\n                this.connecting_output = output;\n                this.connecting_output.slot_index = i;\n                this.connecting_pos = node.getConnectionPos(false, i);\n                this.connecting_slot = i;\n                if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.shift_click_do_break_link_from) {\n                  if (e.shiftKey) {\n                    node.disconnectOutput(i);\n                  }\n                }\n                if (is_double_click) {\n                  if (node.onOutputDblClick) {\n                    node.onOutputDblClick(i, e);\n                  }\n                } else {\n                  if (node.onOutputClick) {\n                    node.onOutputClick(i, e);\n                  }\n                }\n                skip_action = true;\n                break;\n              }\n            }\n          }\n\n          //search for inputs\n          if (node.inputs) {\n            for (var i = 0, l = node.inputs.length; i < l; ++i) {\n              var input = node.inputs[i];\n              var link_pos = node.getConnectionPos(true, i);\n              if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n                if (is_double_click) {\n                  if (node.onInputDblClick) {\n                    node.onInputDblClick(i, e);\n                  }\n                } else {\n                  if (node.onInputClick) {\n                    node.onInputClick(i, e);\n                  }\n                }\n                if (input.link !== null) {\n                  var link_info = this.graph.links[input.link]; //before disconnecting\n                  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.click_do_break_link_to) {\n                    node.disconnectInput(i);\n                    this.dirty_bgcanvas = true;\n                    skip_action = true;\n                  } else {\n                    // do same action as has not node ?\n                  }\n                  if (this.allow_reconnect_links ||\n                  //this.move_destination_link_without_shift ||\n                  e.shiftKey) {\n                    if (!_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.click_do_break_link_to) {\n                      node.disconnectInput(i);\n                    }\n                    this.connecting_node = this.graph._nodes_by_id[link_info.origin_id];\n                    this.connecting_slot = link_info.origin_slot;\n                    this.connecting_output = this.connecting_node.outputs[this.connecting_slot];\n                    this.connecting_pos = this.connecting_node.getConnectionPos(false, this.connecting_slot);\n                    this.dirty_bgcanvas = true;\n                    skip_action = true;\n                  }\n                } else {\n                  // has not node\n                }\n                if (!skip_action) {\n                  // connect from in to out, from to to from\n                  this.connecting_node = node;\n                  this.connecting_input = input;\n                  this.connecting_input.slot_index = i;\n                  this.connecting_pos = node.getConnectionPos(true, i);\n                  this.connecting_slot = i;\n                  this.dirty_bgcanvas = true;\n                  skip_action = true;\n                }\n              }\n            }\n          }\n        } //not resizing\n      }\n\n      //it wasn't clicked on the links boxes\n      if (!skip_action) {\n        var block_drag_node = false;\n        var pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n        //widgets\n        var widget = this.processNodeWidgets(node, this.graph_mouse, e);\n        if (widget) {\n          block_drag_node = true;\n          this.node_widget = [node, widget];\n        }\n\n        //double clicking\n        if (this.allow_interaction && is_double_click && this.selected_nodes[node.id]) {\n          //double click node\n          if (node.onDblClick) {\n            node.onDblClick(e, pos, this);\n          }\n          this.processNodeDblClicked(node);\n          block_drag_node = true;\n        }\n\n        //if do not capture mouse\n        if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n          block_drag_node = true;\n        } else {\n          //open subgraph button\n          if (node.subgraph && !node.skip_subgraph_button) {\n            if (!node.flags.collapsed && pos[0] > node.size[0] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT && pos[1] < 0) {\n              var that = this;\n              setTimeout(function () {\n                that.openSubgraph(node.subgraph);\n              }, 10);\n            }\n          }\n          if (this.live_mode) {\n            clicking_canvas_bg = true;\n            block_drag_node = true;\n          }\n        }\n        if (!block_drag_node) {\n          if (this.allow_dragnodes) {\n            this.graph.beforeChange();\n            this.node_dragged = node;\n          }\n          this.processNodeSelected(node, e);\n        } else {\n          // double-click\n          /**\n           * Don't call the function if the block is already selected.\n           * Otherwise, it could cause the block to be unselected while its panel is open.\n           */\n          if (!node.is_selected) this.processNodeSelected(node, e);\n        }\n        this.dirty_canvas = true;\n      }\n    } //clicked outside of nodes\n    else {\n      if (!skip_action) {\n        //search for link connector\n        if (!this.read_only) {\n          for (var i = 0; i < this.visible_links.length; ++i) {\n            var link = this.visible_links[i];\n            var center = link._pos;\n            if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {\n              continue;\n            }\n            //link clicked\n            this.showLinkMenu(link, e);\n            this.over_link_center = null; //clear tooltip\n            break;\n          }\n        }\n        this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n        this.selected_group_resizing = false;\n        if (this.selected_group && !this.read_only) {\n          if (e.ctrlKey) {\n            this.dragging_rectangle = null;\n          }\n          var dist = distance([e.canvasX, e.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);\n          if (dist * this.ds.scale < 10) {\n            this.selected_group_resizing = true;\n          } else {\n            this.selected_group.recomputeInsideNodes();\n          }\n        }\n        if (is_double_click && !this.read_only && this.allow_searchbox) {\n          this.showSearchBox(e);\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        clicking_canvas_bg = true;\n      }\n    }\n    if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {\n      //console.log(\"pointerevents: dragging_canvas start\");\n      this.dragging_canvas = true;\n    }\n  } else if (e.which == 2) {\n    //middle button\n\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.middle_click_slot_add_default_node) {\n      if (node && this.allow_interaction && !skip_action && !this.read_only) {\n        //not dragging mouse to connect two slots\n        if (!this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n          var mClikSlot = false;\n          var mClikSlot_index = false;\n          var mClikSlot_isOut = false;\n          //search for outputs\n          if (node.outputs) {\n            for (var i = 0, l = node.outputs.length; i < l; ++i) {\n              var output = node.outputs[i];\n              var link_pos = node.getConnectionPos(false, i);\n              if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n                mClikSlot = output;\n                mClikSlot_index = i;\n                mClikSlot_isOut = true;\n                break;\n              }\n            }\n          }\n\n          //search for inputs\n          if (node.inputs) {\n            for (var i = 0, l = node.inputs.length; i < l; ++i) {\n              var input = node.inputs[i];\n              var link_pos = node.getConnectionPos(true, i);\n              if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n                mClikSlot = input;\n                mClikSlot_index = i;\n                mClikSlot_isOut = false;\n                break;\n              }\n            }\n          }\n          //console.log(\"middleClickSlots? \"+mClikSlot+\" & \"+(mClikSlot_index!==false));\n          if (mClikSlot && mClikSlot_index !== false) {\n            var alphaPosY = 0.5 - (mClikSlot_index + 1) / (mClikSlot_isOut ? node.outputs.length : node.inputs.length);\n            var node_bounding = node.getBounding();\n            // estimate a position: this is a bad semi-bad-working mess .. REFACTOR with a correct autoplacement that knows about the others slots and nodes\n            var posRef = [!mClikSlot_isOut ? node_bounding[0] : node_bounding[0] + node_bounding[2] // + node_bounding[0]/this.canvas.width*150\n            , e.canvasY - 80 // + node_bounding[0]/this.canvas.width*66 // vertical \"derive\"\n            ];\n            var nodeCreated = this.createDefaultNodeForSlot({\n              nodeFrom: !mClikSlot_isOut ? null : node,\n              slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,\n              nodeTo: !mClikSlot_isOut ? node : null,\n              slotTo: !mClikSlot_isOut ? mClikSlot_index : null,\n              position: posRef //,e: e\n              ,\n              nodeType: \"AUTO\" //nodeNewType\n              ,\n              posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130] //-alphaPosY*30]\n              ,\n              posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0] //-alphaPosY*2*/\n            });\n          }\n        }\n      }\n    } else if (!skip_action && this.allow_dragcanvas) {\n      //console.log(\"pointerevents: dragging_canvas start from middle button\");\n      this.dragging_canvas = true;\n    }\n  } else if (e.which == 3 || this.pointer_is_double) {\n    //right button\n    if (this.allow_interaction && !skip_action && !this.read_only) {\n      // is it hover a node ?\n      if (node) {\n        if (Object.keys(this.selected_nodes).length && (this.selected_nodes[node.id] || e.shiftKey || e.ctrlKey || e.metaKey)) {\n          // is multiselected or using shift to include the now node\n          if (!this.selected_nodes[node.id]) this.selectNodes([node], true); // add this if not present\n        } else {\n          // update selection\n          this.selectNodes([node]);\n        }\n      }\n\n      // show menu on this node\n      this.processContextMenu(node, e);\n    }\n  }\n\n  //TODO\n  //if(this.node_selected != prev_selected)\n  //\tthis.onNodeSelectionChange(this.node_selected);\n\n  this.last_mouse[0] = e.clientX;\n  this.last_mouse[1] = e.clientY;\n  this.last_mouseclick = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  this.last_mouse_dragging = true;\n\n  /*\n  if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n  this.draw();\n  */\n\n  this.graph.change();\n\n  //this is to ensure to defocus(blur) if a text input element is on focus\n  if (!ref_window.document.activeElement || ref_window.document.activeElement.nodeName.toLowerCase() != \"input\" && ref_window.document.activeElement.nodeName.toLowerCase() != \"textarea\") {\n    e.preventDefault();\n  }\n  e.stopPropagation();\n  if (this.onMouseDown) {\n    this.onMouseDown(e);\n  }\n  return false;\n};\n\n/**\n * Called when a mouse move event has to be processed\n * @method processMouseMove\n **/\nLGraphCanvas.prototype.processMouseMove = function (e) {\n  if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n  if (!this.graph) {\n    return;\n  }\n  LGraphCanvas.active_canvas = this;\n  this.adjustMouseEvent(e);\n  var mouse = [e.clientX, e.clientY];\n  this.mouse[0] = mouse[0];\n  this.mouse[1] = mouse[1];\n  var delta = [mouse[0] - this.last_mouse[0], mouse[1] - this.last_mouse[1]];\n  this.last_mouse = mouse;\n  this.graph_mouse[0] = e.canvasX;\n  this.graph_mouse[1] = e.canvasY;\n\n  //console.log(\"pointerevents: processMouseMove \"+e.pointerId+\" \"+e.isPrimary);\n\n  if (this.block_click) {\n    //console.log(\"pointerevents: processMouseMove block_click\");\n    e.preventDefault();\n    return false;\n  }\n  e.dragging = this.last_mouse_dragging;\n  if (this.node_widget) {\n    this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e, this.node_widget[1]);\n    this.dirty_canvas = true;\n  }\n\n  //get node over\n  var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n  if (this.dragging_rectangle) {\n    this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n    this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n    this.dirty_canvas = true;\n  } else if (this.selected_group && !this.read_only) {\n    //moving/resizing a group\n    if (this.selected_group_resizing) {\n      this.selected_group.size = [e.canvasX - this.selected_group.pos[0], e.canvasY - this.selected_group.pos[1]];\n    } else {\n      var deltax = delta[0] / this.ds.scale;\n      var deltay = delta[1] / this.ds.scale;\n      this.selected_group.move(deltax, deltay, e.ctrlKey);\n      if (this.selected_group._nodes.length) {\n        this.dirty_canvas = true;\n      }\n    }\n    this.dirty_bgcanvas = true;\n  } else if (this.dragging_canvas) {\n    ////console.log(\"pointerevents: processMouseMove is dragging_canvas\");\n    this.ds.offset[0] += delta[0] / this.ds.scale;\n    this.ds.offset[1] += delta[1] / this.ds.scale;\n    this.dirty_canvas = true;\n    this.dirty_bgcanvas = true;\n  } else if ((this.allow_interaction || node && node.flags.allow_interaction) && !this.read_only) {\n    if (this.connecting_node) {\n      this.dirty_canvas = true;\n    }\n\n    //remove mouseover flag\n    for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {\n      if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i]) {\n        //mouse leave\n        this.graph._nodes[i].mouseOver = false;\n        if (this.node_over && this.node_over.onMouseLeave) {\n          this.node_over.onMouseLeave(e);\n        }\n        this.node_over = null;\n        this.dirty_canvas = true;\n      }\n    }\n\n    //mouse over a node\n    if (node) {\n      if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n      //this.canvas.style.cursor = \"move\";\n      if (!node.mouseOver) {\n        //mouse enter\n        node.mouseOver = true;\n        this.node_over = node;\n        this.dirty_canvas = true;\n        if (node.onMouseEnter) {\n          node.onMouseEnter(e);\n        }\n      }\n\n      //in case the node wants to do something\n      if (node.onMouseMove) {\n        node.onMouseMove(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n      }\n\n      //if dragging a link\n      if (this.connecting_node) {\n        if (this.connecting_output) {\n          var pos = this._highlight_input || [0, 0]; //to store the output of isOverNodeInput\n\n          //on top of input\n          if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n            //mouse on top of the corner box, don't know what to do\n          } else {\n            //check if I have a slot below de mouse\n            var slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n            if (slot != -1 && node.inputs[slot]) {\n              var slot_type = node.inputs[slot].type;\n              if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(this.connecting_output.type, slot_type)) {\n                this._highlight_input = pos;\n                this._highlight_input_slot = node.inputs[slot]; // XXX CHECK THIS\n              }\n            } else {\n              this._highlight_input = null;\n              this._highlight_input_slot = null; // XXX CHECK THIS\n            }\n          }\n        } else if (this.connecting_input) {\n          var pos = this._highlight_output || [0, 0]; //to store the output of isOverNodeOutput\n\n          //on top of output\n          if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n            //mouse on top of the corner box, don't know what to do\n          } else {\n            //check if I have a slot below de mouse\n            var slot = this.isOverNodeOutput(node, e.canvasX, e.canvasY, pos);\n            if (slot != -1 && node.outputs[slot]) {\n              var slot_type = node.outputs[slot].type;\n              if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(this.connecting_input.type, slot_type)) {\n                this._highlight_output = pos;\n              }\n            } else {\n              this._highlight_output = null;\n            }\n          }\n        }\n      }\n\n      //Search for corner\n      if (this.canvas) {\n        if (isInsideRectangle(e.canvasX, e.canvasY, node.pos[0] + node.size[0] - 5, node.pos[1] + node.size[1] - 5, 5, 5)) {\n          this.canvas.style.cursor = \"se-resize\";\n        } else {\n          this.canvas.style.cursor = \"crosshair\";\n        }\n      }\n    } else {\n      //not over a node\n\n      //search for link connector\n      var over_link = null;\n      for (var i = 0; i < this.visible_links.length; ++i) {\n        var link = this.visible_links[i];\n        var center = link._pos;\n        if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {\n          continue;\n        }\n        over_link = link;\n        break;\n      }\n      if (over_link != this.over_link_center) {\n        this.over_link_center = over_link;\n        this.dirty_canvas = true;\n      }\n      if (this.canvas) {\n        this.canvas.style.cursor = \"\";\n      }\n    } //end\n\n    //send event to node if capturing input (used with widgets that allow drag outside of the area of the node)\n    if (this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove) {\n      this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n    }\n\n    //node being dragged\n    if (this.node_dragged && !this.live_mode) {\n      //console.log(\"draggin!\",this.selected_nodes);\n      for (var i in this.selected_nodes) {\n        var n = this.selected_nodes[i];\n        n.pos[0] += delta[0] / this.ds.scale;\n        n.pos[1] += delta[1] / this.ds.scale;\n        if (!n.is_selected) this.processNodeSelected(n, e); /*\n                                                            * Don't call the function if the block is already selected.\n                                                            * Otherwise, it could cause the block to be unselected while dragging.\n                                                            */\n      }\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n    }\n    if (this.resizing_node && !this.live_mode) {\n      //convert mouse to node space\n      var desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];\n      var min_size = this.resizing_node.computeSize();\n      desired_size[0] = Math.max(min_size[0], desired_size[0]);\n      desired_size[1] = Math.max(min_size[1], desired_size[1]);\n      this.resizing_node.setSize(desired_size);\n      this.canvas.style.cursor = \"se-resize\";\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n    }\n  }\n  e.preventDefault();\n  return false;\n};\n\n/**\n * Called when a mouse up event has to be processed\n * @method processMouseUp\n **/\nLGraphCanvas.prototype.processMouseUp = function (e) {\n  var is_primary = e.isPrimary === undefined || e.isPrimary;\n\n  //early exit for extra pointer\n  if (!is_primary) {\n    /*e.stopPropagation();\n    e.preventDefault();*/\n    //console.log(\"pointerevents: processMouseUp pointerN_stop \"+e.pointerId+\" \"+e.isPrimary);\n    return false;\n  }\n\n  //console.log(\"pointerevents: processMouseUp \"+e.pointerId+\" \"+e.isPrimary+\" :: \"+e.clientX+\" \"+e.clientY);\n\n  if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n  if (!this.graph) return;\n  var window = this.getCanvasWindow();\n  var document = window.document;\n  LGraphCanvas.active_canvas = this;\n\n  //restore the mousemove event back to the canvas\n  if (!this.options.skip_events) {\n    //console.log(\"pointerevents: processMouseUp adjustEventListener\");\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(document, \"move\", this._mousemove_callback, true);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(this.canvas, \"move\", this._mousemove_callback, true);\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerRemove)(document, \"up\", this._mouseup_callback, true);\n  }\n  this.adjustMouseEvent(e);\n  var now = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  e.click_time = now - this.last_mouseclick;\n  this.last_mouse_dragging = false;\n  this.last_click_position = null;\n  if (this.block_click) {\n    //console.log(\"pointerevents: processMouseUp block_clicks\");\n    this.block_click = false; //used to avoid sending twice a click in a immediate button\n  }\n\n  //console.log(\"pointerevents: processMouseUp which: \"+e.which);\n\n  if (e.which == 1) {\n    if (this.node_widget) {\n      this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n    }\n\n    //left button\n    this.node_widget = null;\n    if (this.selected_group) {\n      var diffx = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]);\n      var diffy = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]);\n      this.selected_group.move(diffx, diffy, e.ctrlKey);\n      this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);\n      this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);\n      if (this.selected_group._nodes.length) {\n        this.dirty_canvas = true;\n      }\n      this.selected_group = null;\n    }\n    this.selected_group_resizing = false;\n    var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n    if (this.dragging_rectangle) {\n      if (this.graph) {\n        var nodes = this.graph._nodes;\n        var node_bounding = new Float32Array(4);\n\n        //compute bounding and flip if left to right\n        var w = Math.abs(this.dragging_rectangle[2]);\n        var h = Math.abs(this.dragging_rectangle[3]);\n        var startx = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - w : this.dragging_rectangle[0];\n        var starty = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - h : this.dragging_rectangle[1];\n        this.dragging_rectangle[0] = startx;\n        this.dragging_rectangle[1] = starty;\n        this.dragging_rectangle[2] = w;\n        this.dragging_rectangle[3] = h;\n\n        // test dragging rect size, if minimun simulate a click\n        if (!node || w > 10 && h > 10) {\n          //test against all nodes (not visible because the rectangle maybe start outside\n          var to_select = [];\n          for (var i = 0; i < nodes.length; ++i) {\n            var nodeX = nodes[i];\n            nodeX.getBounding(node_bounding);\n            if (!overlapBounding(this.dragging_rectangle, node_bounding)) {\n              continue;\n            } //out of the visible area\n            to_select.push(nodeX);\n          }\n          if (to_select.length) {\n            this.selectNodes(to_select, e.shiftKey); // add to selection with shift\n          }\n        } else {\n          // will select of update selection\n          this.selectNodes([node], e.shiftKey || e.ctrlKey); // add to selection add to selection with ctrlKey or shiftKey\n        }\n      }\n      this.dragging_rectangle = null;\n    } else if (this.connecting_node) {\n      //dragging a connection\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n      var connInOrOut = this.connecting_output || this.connecting_input;\n      var connType = connInOrOut.type;\n\n      //node below mouse\n      if (node) {\n        /* no need to condition on event type.. just another type\n        if (\n            connType == LiteGraph.EVENT &&\n            this.isOverNodeBox(node, e.canvasX, e.canvasY)\n        ) {\n            \n            this.connecting_node.connect(\n                this.connecting_slot,\n                node,\n                LiteGraph.EVENT\n            );\n            \n        } else {*/\n\n        //slot below mouse? connect\n\n        if (this.connecting_output) {\n          var slot = this.isOverNodeInput(node, e.canvasX, e.canvasY);\n          if (slot != -1) {\n            this.connecting_node.connect(this.connecting_slot, node, slot);\n          } else {\n            //not on top of an input\n            // look for a good slot\n            this.connecting_node.connectByType(this.connecting_slot, node, connType);\n          }\n        } else if (this.connecting_input) {\n          var slot = this.isOverNodeOutput(node, e.canvasX, e.canvasY);\n          if (slot != -1) {\n            node.connect(slot, this.connecting_node, this.connecting_slot); // this is inverted has output-input nature like\n          } else {\n            //not on top of an input\n            // look for a good slot\n            this.connecting_node.connectByTypeOutput(this.connecting_slot, node, connType);\n          }\n        }\n\n        //}\n      } else {\n        // add menu when releasing link in empty space\n        if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.release_link_on_empty_shows_menu) {\n          if (e.shiftKey && this.allow_searchbox) {\n            if (this.connecting_output) {\n              this.showSearchBox(e, {\n                node_from: this.connecting_node,\n                slot_from: this.connecting_output,\n                type_filter_in: this.connecting_output.type\n              });\n            } else if (this.connecting_input) {\n              this.showSearchBox(e, {\n                node_to: this.connecting_node,\n                slot_from: this.connecting_input,\n                type_filter_out: this.connecting_input.type\n              });\n            }\n          } else {\n            if (this.connecting_output) {\n              this.showConnectionMenu({\n                nodeFrom: this.connecting_node,\n                slotFrom: this.connecting_output,\n                e: e\n              });\n            } else if (this.connecting_input) {\n              this.showConnectionMenu({\n                nodeTo: this.connecting_node,\n                slotTo: this.connecting_input,\n                e: e\n              });\n            }\n          }\n        }\n      }\n      this.connecting_output = null;\n      this.connecting_input = null;\n      this.connecting_pos = null;\n      this.connecting_node = null;\n      this.connecting_slot = -1;\n    } //not dragging connection\n    else if (this.resizing_node) {\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n      this.graph.afterChange(this.resizing_node);\n      this.resizing_node = null;\n    } else if (this.node_dragged) {\n      //node being dragged?\n      var node = this.node_dragged;\n      if (node && e.click_time < 300 && isInsideRectangle(e.canvasX, e.canvasY, node.pos[0], node.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT)) {\n        node.collapse();\n      }\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n      this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n      this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n      if (this.graph.config.align_to_grid || this.align_to_grid) {\n        this.node_dragged.alignToGrid();\n      }\n      if (this.onNodeMoved) this.onNodeMoved(this.node_dragged);\n      this.graph.afterChange(this.node_dragged);\n      this.node_dragged = null;\n    } //no node being dragged\n    else {\n      //get node over\n      var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n      if (!node && e.click_time < 300) {\n        this.deselectAllNodes();\n      }\n      this.dirty_canvas = true;\n      this.dragging_canvas = false;\n      if (this.node_over && this.node_over.onMouseUp) {\n        this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n      }\n      if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {\n        this.node_capturing_input.onMouseUp(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]]);\n      }\n    }\n  } else if (e.which == 2) {\n    //middle button\n    //trace(\"middle\");\n    this.dirty_canvas = true;\n    this.dragging_canvas = false;\n  } else if (e.which == 3) {\n    //right button\n    //trace(\"right\");\n    this.dirty_canvas = true;\n    this.dragging_canvas = false;\n  }\n\n  /*\n  if((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n      this.draw();\n  */\n\n  if (is_primary) {\n    this.pointer_is_down = false;\n    this.pointer_is_double = false;\n  }\n  this.graph.change();\n\n  //console.log(\"pointerevents: processMouseUp stopPropagation\");\n  e.stopPropagation();\n  e.preventDefault();\n  return false;\n};\n\n/**\n * Called when a mouse wheel event has to be processed\n * @method processMouseWheel\n **/\nLGraphCanvas.prototype.processMouseWheel = function (e) {\n  if (!this.graph || !this.allow_dragcanvas) {\n    return;\n  }\n  var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n  this.adjustMouseEvent(e);\n  var x = e.clientX;\n  var y = e.clientY;\n  var is_inside = !this.viewport || this.viewport && x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] && y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3];\n  if (!is_inside) return;\n  var scale = this.ds.scale;\n  if (delta > 0) {\n    scale *= 1.1;\n  } else if (delta < 0) {\n    scale *= 1 / 1.1;\n  }\n  this.ds.changeScale(scale, [e.clientX, e.clientY]);\n  this.graph.change();\n  e.preventDefault();\n  return false; // prevent default\n};\n\n/**\n * returns true if a position (in graph space) is on top of a node little corner box\n * @method isOverNodeBox\n **/\nLGraphCanvas.prototype.isOverNodeBox = function (node, canvasx, canvasy) {\n  var title_height = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n  if (isInsideRectangle(canvasx, canvasy, node.pos[0] + 2, node.pos[1] + 2 - title_height, title_height - 4, title_height - 4)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * returns the INDEX if a position (in graph space) is on top of a node input slot\n * @method isOverNodeInput\n **/\nLGraphCanvas.prototype.isOverNodeInput = function (node, canvasx, canvasy, slot_pos) {\n  if (node.inputs) {\n    for (var i = 0, l = node.inputs.length; i < l; ++i) {\n      var input = node.inputs[i];\n      var link_pos = node.getConnectionPos(true, i);\n      var is_inside = false;\n      if (node.horizontal) {\n        is_inside = isInsideRectangle(canvasx, canvasy, link_pos[0] - 5, link_pos[1] - 10, 10, 20);\n      } else {\n        is_inside = isInsideRectangle(canvasx, canvasy, link_pos[0] - 10, link_pos[1] - 5, 40, 10);\n      }\n      if (is_inside) {\n        if (slot_pos) {\n          slot_pos[0] = link_pos[0];\n          slot_pos[1] = link_pos[1];\n        }\n        return i;\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * returns the INDEX if a position (in graph space) is on top of a node output slot\n * @method isOverNodeOuput\n **/\nLGraphCanvas.prototype.isOverNodeOutput = function (node, canvasx, canvasy, slot_pos) {\n  if (node.outputs) {\n    for (var i = 0, l = node.outputs.length; i < l; ++i) {\n      var output = node.outputs[i];\n      var link_pos = node.getConnectionPos(false, i);\n      var is_inside = false;\n      if (node.horizontal) {\n        is_inside = isInsideRectangle(canvasx, canvasy, link_pos[0] - 5, link_pos[1] - 10, 10, 20);\n      } else {\n        is_inside = isInsideRectangle(canvasx, canvasy, link_pos[0] - 10, link_pos[1] - 5, 40, 10);\n      }\n      if (is_inside) {\n        if (slot_pos) {\n          slot_pos[0] = link_pos[0];\n          slot_pos[1] = link_pos[1];\n        }\n        return i;\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * process a key event\n * @method processKey\n **/\nLGraphCanvas.prototype.processKey = function (e) {\n  if (!this.graph) {\n    return;\n  }\n  var block_default = false;\n  //console.log(e); //debug\n\n  if (e.target.localName == \"input\") {\n    return;\n  }\n  if (e.type == \"keydown\") {\n    if (e.keyCode == 32) {\n      //space\n      this.dragging_canvas = true;\n      block_default = true;\n    }\n    if (e.keyCode == 27) {\n      //esc\n      if (this.node_panel) this.node_panel.close();\n      if (this.options_panel) this.options_panel.close();\n      block_default = true;\n    }\n\n    //select all Control A\n    if (e.keyCode == 65 && e.ctrlKey) {\n      this.selectNodes();\n      block_default = true;\n    }\n    if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n      //copy\n      if (this.selected_nodes) {\n        this.copyToClipboard();\n        block_default = true;\n      }\n    }\n    if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {\n      //paste\n      this.pasteFromClipboard(e.shiftKey);\n    }\n\n    //delete or backspace\n    if (e.keyCode == 46 || e.keyCode == 8) {\n      if (e.target.localName != \"input\" && e.target.localName != \"textarea\") {\n        this.deleteSelectedNodes();\n        block_default = true;\n      }\n    }\n\n    //collapse\n    //...\n\n    //TODO\n    if (this.selected_nodes) {\n      for (var i in this.selected_nodes) {\n        if (this.selected_nodes[i].onKeyDown) {\n          this.selected_nodes[i].onKeyDown(e);\n        }\n      }\n    }\n  } else if (e.type == \"keyup\") {\n    if (e.keyCode == 32) {\n      // space\n      this.dragging_canvas = false;\n    }\n    if (this.selected_nodes) {\n      for (var i in this.selected_nodes) {\n        if (this.selected_nodes[i].onKeyUp) {\n          this.selected_nodes[i].onKeyUp(e);\n        }\n      }\n    }\n  }\n  this.graph.change();\n  if (block_default) {\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    return false;\n  }\n};\nLGraphCanvas.prototype.copyToClipboard = function () {\n  var clipboard_info = {\n    nodes: [],\n    links: []\n  };\n  var index = 0;\n  var selected_nodes_array = [];\n  for (var i in this.selected_nodes) {\n    var node = this.selected_nodes[i];\n    if (node.clonable === false) continue;\n    node._relative_id = index;\n    selected_nodes_array.push(node);\n    index += 1;\n  }\n  for (var i = 0; i < selected_nodes_array.length; ++i) {\n    var node = selected_nodes_array[i];\n    if (node.clonable === false) continue;\n    var cloned = node.clone();\n    if (!cloned) {\n      console.warn(\"node type not found: \" + node.type);\n      continue;\n    }\n    clipboard_info.nodes.push(cloned.serialize());\n    if (node.inputs && node.inputs.length) {\n      for (var j = 0; j < node.inputs.length; ++j) {\n        var input = node.inputs[j];\n        if (!input || input.link == null) {\n          continue;\n        }\n        var link_info = this.graph.links[input.link];\n        if (!link_info) {\n          continue;\n        }\n        var target_node = this.graph.getNodeById(link_info.origin_id);\n        if (!target_node) {\n          continue;\n        }\n        clipboard_info.links.push([target_node._relative_id, link_info.origin_slot,\n        //j,\n        node._relative_id, link_info.target_slot, target_node.id]);\n      }\n    }\n  }\n  localStorage.setItem(\"litegrapheditor_clipboard\", JSON.stringify(clipboard_info));\n};\nLGraphCanvas.prototype.pasteFromClipboard = function (isConnectUnselected = false) {\n  // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior\n  if (!_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n    return;\n  }\n  var data = localStorage.getItem(\"litegrapheditor_clipboard\");\n  if (!data) {\n    return;\n  }\n  this.graph.beforeChange();\n\n  //create nodes\n  var clipboard_info = JSON.parse(data);\n  // calculate top-left node, could work without this processing but using diff with last node pos :: clipboard_info.nodes[clipboard_info.nodes.length-1].pos\n  var posMin = false;\n  var posMinIndexes = false;\n  for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n    if (posMin) {\n      if (posMin[0] > clipboard_info.nodes[i].pos[0]) {\n        posMin[0] = clipboard_info.nodes[i].pos[0];\n        posMinIndexes[0] = i;\n      }\n      if (posMin[1] > clipboard_info.nodes[i].pos[1]) {\n        posMin[1] = clipboard_info.nodes[i].pos[1];\n        posMinIndexes[1] = i;\n      }\n    } else {\n      posMin = [clipboard_info.nodes[i].pos[0], clipboard_info.nodes[i].pos[1]];\n      posMinIndexes = [i, i];\n    }\n  }\n  var nodes = [];\n  for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n    var node_data = clipboard_info.nodes[i];\n    var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(node_data.type);\n    if (node) {\n      node.configure(node_data);\n\n      //paste in last known mouse position\n      node.pos[0] += this.graph_mouse[0] - posMin[0]; //+= 5;\n      node.pos[1] += this.graph_mouse[1] - posMin[1]; //+= 5;\n\n      this.graph.add(node, {\n        doProcessChange: false\n      });\n      nodes.push(node);\n    }\n  }\n\n  //create links\n  for (var i = 0; i < clipboard_info.links.length; ++i) {\n    var link_info = clipboard_info.links[i];\n    var origin_node;\n    var origin_node_relative_id = link_info[0];\n    if (origin_node_relative_id != null) {\n      origin_node = nodes[origin_node_relative_id];\n    } else if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n      var origin_node_id = link_info[4];\n      if (origin_node_id) {\n        origin_node = this.graph.getNodeById(origin_node_id);\n      }\n    }\n    var target_node = nodes[link_info[2]];\n    if (origin_node && target_node) origin_node.connect(link_info[1], target_node, link_info[3]);else console.warn(\"Warning, nodes missing on pasting\");\n  }\n  this.selectNodes(nodes);\n  this.graph.afterChange();\n};\n\n/**\n * process a item drop event on top the canvas\n * @method processDrop\n **/\nLGraphCanvas.prototype.processDrop = function (e) {\n  e.preventDefault();\n  this.adjustMouseEvent(e);\n  var x = e.clientX;\n  var y = e.clientY;\n  var is_inside = !this.viewport || this.viewport && x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] && y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3];\n  if (!is_inside) {\n    return;\n    // --- BREAK ---\n  }\n  var pos = [e.canvasX, e.canvasY];\n  var node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n  if (!node) {\n    var r = null;\n    if (this.onDropItem) {\n      r = this.onDropItem(event);\n    }\n    if (!r) {\n      this.checkDropItem(e);\n    }\n    return;\n  }\n  if (node.onDropFile || node.onDropData) {\n    var files = e.dataTransfer.files;\n    if (files && files.length) {\n      for (var i = 0; i < files.length; i++) {\n        var file = e.dataTransfer.files[0];\n        var filename = file.name;\n        var ext = LGraphCanvas.getFileExtension(filename);\n        //console.log(file);\n\n        if (node.onDropFile) {\n          node.onDropFile(file);\n        }\n        if (node.onDropData) {\n          //prepare reader\n          var reader = new FileReader();\n          reader.onload = function (event) {\n            //console.log(event.target);\n            var data = event.target.result;\n            node.onDropData(data, filename, file);\n          };\n\n          //read data\n          var type = file.type.split(\"/\")[0];\n          if (type == \"text\" || type == \"\") {\n            reader.readAsText(file);\n          } else if (type == \"image\") {\n            reader.readAsDataURL(file);\n          } else {\n            reader.readAsArrayBuffer(file);\n          }\n        }\n      }\n    }\n  }\n  if (node.onDropItem) {\n    if (node.onDropItem(event)) {\n      return true;\n    }\n  }\n  if (this.onDropItem) {\n    return this.onDropItem(event);\n  }\n  return false;\n};\n\n//called if the graph doesn't have a default drop item behaviour\nLGraphCanvas.prototype.checkDropItem = function (e) {\n  if (e.dataTransfer.files.length) {\n    var file = e.dataTransfer.files[0];\n    var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();\n    var nodetype = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.node_types_by_file_extension[ext];\n    if (nodetype) {\n      this.graph.beforeChange();\n      var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(nodetype.type);\n      node.pos = [e.canvasX, e.canvasY];\n      this.graph.add(node);\n      if (node.onDropFile) {\n        node.onDropFile(file);\n      }\n      this.graph.afterChange();\n    }\n  }\n};\nLGraphCanvas.prototype.processNodeDblClicked = function (n) {\n  if (this.onShowNodePanel) {\n    this.onShowNodePanel(n);\n  } else {\n    this.showShowNodePanel(n);\n  }\n  if (this.onNodeDblClicked) {\n    this.onNodeDblClicked(n);\n  }\n  this.setDirty(true);\n};\nLGraphCanvas.prototype.processNodeSelected = function (node, e) {\n  this.selectNode(node, e && (e.shiftKey || e.ctrlKey || this.multi_select));\n  if (this.onNodeSelected) {\n    this.onNodeSelected(node);\n  }\n};\n\n/**\n * selects a given node (or adds it to the current selection)\n * @method selectNode\n **/\nLGraphCanvas.prototype.selectNode = function (node, add_to_current_selection) {\n  if (node == null) {\n    this.deselectAllNodes();\n  } else {\n    this.selectNodes([node], add_to_current_selection);\n  }\n};\n\n/**\n * selects several nodes (or adds them to the current selection)\n * @method selectNodes\n **/\nLGraphCanvas.prototype.selectNodes = function (nodes, add_to_current_selection) {\n  if (!add_to_current_selection) {\n    this.deselectAllNodes();\n  }\n  nodes = nodes || this.graph._nodes;\n  if (typeof nodes == \"string\") nodes = [nodes];\n  for (var i in nodes) {\n    var node = nodes[i];\n    if (node.is_selected) {\n      this.deselectNode(node);\n      continue;\n    }\n    if (!node.is_selected && node.onSelected) {\n      node.onSelected();\n    }\n    node.is_selected = true;\n    this.selected_nodes[node.id] = node;\n    if (node.inputs) {\n      for (var j = 0; j < node.inputs.length; ++j) {\n        this.highlighted_links[node.inputs[j].link] = true;\n      }\n    }\n    if (node.outputs) {\n      for (var j = 0; j < node.outputs.length; ++j) {\n        var out = node.outputs[j];\n        if (out.links) {\n          for (var k = 0; k < out.links.length; ++k) {\n            this.highlighted_links[out.links[k]] = true;\n          }\n        }\n      }\n    }\n  }\n  if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n  this.setDirty(true);\n};\n\n/**\n * removes a node from the current selection\n * @method deselectNode\n **/\nLGraphCanvas.prototype.deselectNode = function (node) {\n  if (!node.is_selected) {\n    return;\n  }\n  if (node.onDeselected) {\n    node.onDeselected();\n  }\n  node.is_selected = false;\n  if (this.onNodeDeselected) {\n    this.onNodeDeselected(node);\n  }\n\n  //remove highlighted\n  if (node.inputs) {\n    for (var i = 0; i < node.inputs.length; ++i) {\n      delete this.highlighted_links[node.inputs[i].link];\n    }\n  }\n  if (node.outputs) {\n    for (var i = 0; i < node.outputs.length; ++i) {\n      var out = node.outputs[i];\n      if (out.links) {\n        for (var j = 0; j < out.links.length; ++j) {\n          delete this.highlighted_links[out.links[j]];\n        }\n      }\n    }\n  }\n};\n\n/**\n * removes all nodes from the current selection\n * @method deselectAllNodes\n **/\nLGraphCanvas.prototype.deselectAllNodes = function () {\n  if (!this.graph) {\n    return;\n  }\n  var nodes = this.graph._nodes;\n  for (var i = 0, l = nodes.length; i < l; ++i) {\n    var node = nodes[i];\n    if (!node.is_selected) {\n      continue;\n    }\n    if (node.onDeselected) {\n      node.onDeselected();\n    }\n    node.is_selected = false;\n    if (this.onNodeDeselected) {\n      this.onNodeDeselected(node);\n    }\n  }\n  this.selected_nodes = {};\n  this.current_node = null;\n  this.highlighted_links = {};\n  if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n  this.setDirty(true);\n};\n\n/**\n * deletes all nodes in the current selection from the graph\n * @method deleteSelectedNodes\n **/\nLGraphCanvas.prototype.deleteSelectedNodes = function () {\n  this.graph.beforeChange();\n  for (var i in this.selected_nodes) {\n    var node = this.selected_nodes[i];\n    if (node.block_delete) continue;\n\n    //autoconnect when possible (very basic, only takes into account first input-output)\n    if (node.inputs && node.inputs.length && node.outputs && node.outputs.length && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(node.inputs[0].type, node.outputs[0].type) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length) {\n      var input_link = node.graph.links[node.inputs[0].link];\n      var output_link = node.graph.links[node.outputs[0].links[0]];\n      var input_node = node.getInputNode(0);\n      var output_node = node.getOutputNodes(0)[0];\n      if (input_node && output_node) input_node.connect(input_link.origin_slot, output_node, output_link.target_slot);\n    }\n    this.graph.remove(node);\n    if (this.onNodeDeselected) {\n      this.onNodeDeselected(node);\n    }\n  }\n  this.selected_nodes = {};\n  this.current_node = null;\n  this.highlighted_links = {};\n  this.setDirty(true);\n  this.graph.afterChange();\n};\n\n/**\n * centers the camera on a given node\n * @method centerOnNode\n **/\nLGraphCanvas.prototype.centerOnNode = function (node) {\n  this.ds.offset[0] = -node.pos[0] - node.size[0] * 0.5 + this.canvas.width * 0.5 / this.ds.scale;\n  this.ds.offset[1] = -node.pos[1] - node.size[1] * 0.5 + this.canvas.height * 0.5 / this.ds.scale;\n  this.setDirty(true, true);\n};\n\n/**\n * adds some useful properties to a mouse event, like the position in graph coordinates\n * @method adjustMouseEvent\n **/\nLGraphCanvas.prototype.adjustMouseEvent = function (e) {\n  var clientX_rel = 0;\n  var clientY_rel = 0;\n  if (this.canvas) {\n    var b = this.canvas.getBoundingClientRect();\n    clientX_rel = e.clientX - b.left;\n    clientY_rel = e.clientY - b.top;\n  } else {\n    clientX_rel = e.clientX;\n    clientY_rel = e.clientY;\n  }\n\n  // e.deltaX = clientX_rel - this.last_mouse_position[0];\n  // e.deltaY = clientY_rel- this.last_mouse_position[1];\n\n  this.last_mouse_position[0] = clientX_rel;\n  this.last_mouse_position[1] = clientY_rel;\n  e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];\n  e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];\n\n  //console.log(\"pointerevents: adjustMouseEvent \"+e.clientX+\":\"+e.clientY+\" \"+clientX_rel+\":\"+clientY_rel+\" \"+e.canvasX+\":\"+e.canvasY);\n};\n\n/**\n * converts a coordinate from graph coordinates to canvas2D coordinates\n * @method convertOffsetToCanvas\n **/\nLGraphCanvas.prototype.convertOffsetToCanvas = function (pos, out) {\n  return this.ds.convertOffsetToCanvas(pos, out);\n};\n\n/**\n * converts a coordinate from Canvas2D coordinates to graph space\n * @method convertCanvasToOffset\n **/\nLGraphCanvas.prototype.convertCanvasToOffset = function (pos, out) {\n  return this.ds.convertCanvasToOffset(pos, out);\n};\n\n//converts event coordinates from canvas2D to graph coordinates\nLGraphCanvas.prototype.convertEventToCanvasOffset = function (e) {\n  var rect = this.canvas.getBoundingClientRect();\n  return this.convertCanvasToOffset([e.clientX - rect.left, e.clientY - rect.top]);\n};\n\n/**\n * brings a node to front (above all other nodes)\n * @method bringToFront\n **/\nLGraphCanvas.prototype.bringToFront = function (node) {\n  var i = this.graph._nodes.indexOf(node);\n  if (i == -1) {\n    return;\n  }\n  this.graph._nodes.splice(i, 1);\n  this.graph._nodes.push(node);\n};\n\n/**\n * sends a node to the back (below all other nodes)\n * @method sendToBack\n **/\nLGraphCanvas.prototype.sendToBack = function (node) {\n  var i = this.graph._nodes.indexOf(node);\n  if (i == -1) {\n    return;\n  }\n  this.graph._nodes.splice(i, 1);\n  this.graph._nodes.unshift(node);\n};\n\n/* Interaction */\n\n/* LGraphCanvas render */\nvar temp = new Float32Array(4);\n\n/**\n * checks which nodes are visible (inside the camera area)\n * @method computeVisibleNodes\n **/\nLGraphCanvas.prototype.computeVisibleNodes = function (nodes, out) {\n  var visible_nodes = out || [];\n  visible_nodes.length = 0;\n  nodes = nodes || this.graph._nodes;\n  for (var i = 0, l = nodes.length; i < l; ++i) {\n    var n = nodes[i];\n\n    //skip rendering nodes in live mode\n    if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n      continue;\n    }\n    if (!overlapBounding(this.visible_area, n.getBounding(temp, true))) {\n      continue;\n    } //out of the visible area\n\n    visible_nodes.push(n);\n  }\n  return visible_nodes;\n};\n\n/**\n * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)\n * @method draw\n **/\nLGraphCanvas.prototype.draw = function (force_canvas, force_bgcanvas) {\n  if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {\n    return;\n  }\n\n  //fps counting\n  var now = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  this.render_time = (now - this.last_draw_time) * 0.001;\n  this.last_draw_time = now;\n  if (this.graph) {\n    this.ds.computeVisibleArea(this.viewport);\n  }\n  if (this.dirty_bgcanvas || force_bgcanvas || this.always_render_background || this.graph && this.graph._last_trigger_time && now - this.graph._last_trigger_time < 1000) {\n    this.drawBackCanvas();\n  }\n  if (this.dirty_canvas || force_canvas) {\n    this.drawFrontCanvas();\n  }\n  this.fps = this.render_time ? 1.0 / this.render_time : 0;\n  this.frame += 1;\n};\n\n/**\n * draws the front canvas (the one containing all the nodes)\n * @method drawFrontCanvas\n **/\nLGraphCanvas.prototype.drawFrontCanvas = function () {\n  this.dirty_canvas = false;\n  if (!this.ctx) {\n    this.ctx = this.bgcanvas.getContext(\"2d\");\n  }\n  var ctx = this.ctx;\n  if (!ctx) {\n    //maybe is using webgl...\n    return;\n  }\n  var canvas = this.canvas;\n  if (ctx.start2D && !this.viewport) {\n    ctx.start2D();\n    ctx.restore();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  //clip dirty area if there is one, otherwise work in full canvas\n  var area = this.viewport || this.dirty_area;\n  if (area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area[0], area[1], area[2], area[3]);\n    ctx.clip();\n  }\n\n  //clear\n  //canvas.width = canvas.width;\n  if (this.clear_background) {\n    if (area) ctx.clearRect(area[0], area[1], area[2], area[3]);else ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  //draw bg canvas\n  if (this.bgcanvas == this.canvas) {\n    this.drawBackCanvas();\n  } else {\n    ctx.drawImage(this.bgcanvas, 0, 0);\n  }\n\n  //rendering\n  if (this.onRender) {\n    this.onRender(canvas, ctx);\n  }\n\n  //info widget\n  if (this.show_info) {\n    this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0);\n  }\n  if (this.graph) {\n    //apply transformations\n    ctx.save();\n    this.ds.toCanvasContext(ctx);\n\n    //draw nodes\n    var drawn_nodes = 0;\n    var visible_nodes = this.computeVisibleNodes(null, this.visible_nodes);\n    for (var i = 0; i < visible_nodes.length; ++i) {\n      var node = visible_nodes[i];\n\n      //transform coords system\n      ctx.save();\n      ctx.translate(node.pos[0], node.pos[1]);\n\n      //Draw\n      this.drawNode(node, ctx);\n      drawn_nodes += 1;\n\n      //Restore\n      ctx.restore();\n    }\n\n    //on top (debug)\n    if (this.render_execution_order) {\n      this.drawExecutionOrder(ctx);\n    }\n\n    //connections ontop?\n    if (this.graph.config.links_ontop) {\n      if (!this.live_mode) {\n        this.drawConnections(ctx);\n      }\n    }\n\n    //current connection (the one being dragged by the mouse)\n    if (this.connecting_pos != null) {\n      ctx.lineWidth = this.connections_width;\n      var link_color = null;\n      var connInOrOut = this.connecting_output || this.connecting_input;\n      var connType = connInOrOut.type;\n      var connDir = connInOrOut.dir;\n      if (connDir == null) {\n        if (this.connecting_output) connDir = this.connecting_node.horizontal ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT;else connDir = this.connecting_node.horizontal ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT;\n      }\n      var connShape = connInOrOut.shape;\n      switch (connType) {\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT:\n          link_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT_LINK_COLOR;\n          break;\n        default:\n          link_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.CONNECTING_LINK_COLOR;\n      }\n\n      //the connection being dragged by the mouse\n      this.renderLink(ctx, this.connecting_pos, [this.graph_mouse[0], this.graph_mouse[1]], null, false, null, link_color, connDir, _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.CENTER);\n      ctx.beginPath();\n      if (connType === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || connShape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n        ctx.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.rect(this.graph_mouse[0] - 6 + 0.5, this.graph_mouse[1] - 5 + 0.5, 14, 10);\n      } else if (connShape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n        ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);\n        ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);\n        ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);\n        ctx.closePath();\n      } else {\n        ctx.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(this.graph_mouse[0], this.graph_mouse[1], 4, 0, Math.PI * 2);\n      }\n      ctx.fill();\n      ctx.fillStyle = \"#ffcc00\";\n      if (this._highlight_input) {\n        ctx.beginPath();\n        var shape = this._highlight_input_slot.shape;\n        if (shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n          ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);\n          ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);\n          ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);\n          ctx.closePath();\n        } else {\n          ctx.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, Math.PI * 2);\n        }\n        ctx.fill();\n      }\n      if (this._highlight_output) {\n        ctx.beginPath();\n        if (shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n          ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);\n          ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);\n          ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);\n          ctx.closePath();\n        } else {\n          ctx.arc(this._highlight_output[0], this._highlight_output[1], 6, 0, Math.PI * 2);\n        }\n        ctx.fill();\n      }\n    }\n\n    //the selection rectangle\n    if (this.dragging_rectangle) {\n      ctx.strokeStyle = \"#FFF\";\n      ctx.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]);\n    }\n\n    //on top of link center\n    if (this.over_link_center && this.render_link_tooltip) this.drawLinkTooltip(ctx, this.over_link_center);else if (this.onDrawLinkTooltip)\n      //to remove\n      this.onDrawLinkTooltip(ctx, null);\n\n    //custom info\n    if (this.onDrawForeground) {\n      this.onDrawForeground(ctx, this.visible_rect);\n    }\n    ctx.restore();\n  }\n\n  //draws panel in the corner \n  if (this._graph_stack && this._graph_stack.length) {\n    this.drawSubgraphPanel(ctx);\n  }\n  if (this.onDrawOverlay) {\n    this.onDrawOverlay(ctx);\n  }\n  if (area) {\n    ctx.restore();\n  }\n  if (ctx.finish2D) {\n    //this is a function I use in webgl renderer\n    ctx.finish2D();\n  }\n};\n\n/**\n * draws the panel in the corner that shows subgraph properties\n * @method drawSubgraphPanel\n **/\nLGraphCanvas.prototype.drawSubgraphPanel = function (ctx) {\n  var subgraph = this.graph;\n  var subnode = subgraph._subgraph_node;\n  if (!subnode) {\n    console.warn(\"subgraph without subnode\");\n    return;\n  }\n  this.drawSubgraphPanelLeft(subgraph, subnode, ctx);\n  this.drawSubgraphPanelRight(subgraph, subnode, ctx);\n};\nLGraphCanvas.prototype.drawSubgraphPanelLeft = function (subgraph, subnode, ctx) {\n  var num = subnode.inputs ? subnode.inputs.length : 0;\n  var w = 200;\n  var h = Math.floor(_settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 1.6);\n  ctx.fillStyle = \"#111\";\n  ctx.globalAlpha = 0.8;\n  ctx.beginPath();\n  ctx.roundRect(10, 10, w, (num + 1) * h + 50, [8]);\n  ctx.fill();\n  ctx.globalAlpha = 1;\n  ctx.fillStyle = \"#888\";\n  ctx.font = \"14px Arial\";\n  ctx.textAlign = \"left\";\n  ctx.fillText(\"Graph Inputs\", 20, 34);\n  // var pos = this.mouse;\n\n  if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n    this.closeSubgraph();\n    return;\n  }\n  var y = 50;\n  ctx.font = \"14px Arial\";\n  if (subnode.inputs) for (var i = 0; i < subnode.inputs.length; ++i) {\n    var input = subnode.inputs[i];\n    if (input.not_subgraph_input) continue;\n\n    //input button clicked\n    if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n      var type = subnode.constructor.input_node_type || \"graph/input\";\n      this.graph.beforeChange();\n      var newnode = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(type);\n      if (newnode) {\n        subgraph.add(newnode);\n        this.block_click = false;\n        this.last_click_position = null;\n        this.selectNodes([newnode]);\n        this.node_dragged = newnode;\n        this.dragging_canvas = false;\n        newnode.setProperty(\"name\", input.name);\n        newnode.setProperty(\"type\", input.type);\n        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n        this.graph.afterChange();\n      } else console.error(\"graph input node not found:\", type);\n    }\n    ctx.fillStyle = \"#9C9\";\n    ctx.beginPath();\n    ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.fillStyle = \"#AAA\";\n    ctx.fillText(input.name, 30, y + h * 0.75);\n    // var tw = ctx.measureText(input.name);\n    ctx.fillStyle = \"#777\";\n    ctx.fillText(input.type, 130, y + h * 0.75);\n    y += h;\n  }\n  //add + button\n  if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n    this.showSubgraphPropertiesDialog(subnode);\n  }\n};\nLGraphCanvas.prototype.drawSubgraphPanelRight = function (subgraph, subnode, ctx) {\n  var num = subnode.outputs ? subnode.outputs.length : 0;\n  var canvas_w = this.bgcanvas.width;\n  var w = 200;\n  var h = Math.floor(_settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 1.6);\n  ctx.fillStyle = \"#111\";\n  ctx.globalAlpha = 0.8;\n  ctx.beginPath();\n  ctx.roundRect(canvas_w - w - 10, 10, w, (num + 1) * h + 50, [8]);\n  ctx.fill();\n  ctx.globalAlpha = 1;\n  ctx.fillStyle = \"#888\";\n  ctx.font = \"14px Arial\";\n  ctx.textAlign = \"left\";\n  var title_text = \"Graph Outputs\";\n  var tw = ctx.measureText(title_text).width;\n  ctx.fillText(title_text, canvas_w - tw - 20, 34);\n  // var pos = this.mouse;\n  if (this.drawButton(canvas_w - w, 20, 20, 20, \"X\", \"#151515\")) {\n    this.closeSubgraph();\n    return;\n  }\n  var y = 50;\n  ctx.font = \"14px Arial\";\n  if (subnode.outputs) for (var i = 0; i < subnode.outputs.length; ++i) {\n    var output = subnode.outputs[i];\n    if (output.not_subgraph_input) continue;\n\n    //output button clicked\n    if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2)) {\n      var type = subnode.constructor.output_node_type || \"graph/output\";\n      this.graph.beforeChange();\n      var newnode = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(type);\n      if (newnode) {\n        subgraph.add(newnode);\n        this.block_click = false;\n        this.last_click_position = null;\n        this.selectNodes([newnode]);\n        this.node_dragged = newnode;\n        this.dragging_canvas = false;\n        newnode.setProperty(\"name\", output.name);\n        newnode.setProperty(\"type\", output.type);\n        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n        this.graph.afterChange();\n      } else console.error(\"graph input node not found:\", type);\n    }\n    ctx.fillStyle = \"#9C9\";\n    ctx.beginPath();\n    ctx.arc(canvas_w - w + 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.fillStyle = \"#AAA\";\n    ctx.fillText(output.name, canvas_w - w + 30, y + h * 0.75);\n    // var tw = ctx.measureText(input.name);\n    ctx.fillStyle = \"#777\";\n    ctx.fillText(output.type, canvas_w - w + 130, y + h * 0.75);\n    y += h;\n  }\n  //add + button\n  if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n    this.showSubgraphPropertiesDialogRight(subnode);\n  }\n};\n//Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm\nLGraphCanvas.prototype.drawButton = function (x, y, w, h, text, bgcolor, hovercolor, textcolor) {\n  var ctx = this.ctx;\n  bgcolor = bgcolor || NODE_DEFAULT_COLOR;\n  hovercolor = hovercolor || \"#555\";\n  textcolor = textcolor || NODE_TEXT_COLOR;\n  var pos = this.ds.convertOffsetToCanvas(this.graph_mouse);\n  var hover = isInsideRectangle(pos[0], pos[1], x, y, w, h);\n  pos = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;\n  if (pos) {\n    var rect = this.canvas.getBoundingClientRect();\n    pos[0] -= rect.left;\n    pos[1] -= rect.top;\n  }\n  var clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n  ctx.fillStyle = hover ? hovercolor : bgcolor;\n  if (clicked) ctx.fillStyle = \"#AAA\";\n  ctx.beginPath();\n  ctx.roundRect(x, y, w, h, [4]);\n  ctx.fill();\n  if (text != null) {\n    if (text.constructor == String) {\n      ctx.fillStyle = textcolor;\n      ctx.textAlign = \"center\";\n      ctx.font = (h * 0.65 | 0) + \"px Arial\";\n      ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n      ctx.textAlign = \"left\";\n    }\n  }\n  var was_clicked = clicked && !this.block_click;\n  if (clicked) this.blockClick();\n  return was_clicked;\n};\nLGraphCanvas.prototype.isAreaClicked = function (x, y, w, h, hold_click) {\n  var pos = this.mouse;\n  var hover = isInsideRectangle(pos[0], pos[1], x, y, w, h);\n  pos = this.last_click_position;\n  var clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n  var was_clicked = clicked && !this.block_click;\n  if (clicked && hold_click) this.blockClick();\n  return was_clicked;\n};\n\n/**\n * draws some useful stats in the corner of the canvas\n * @method renderInfo\n **/\nLGraphCanvas.prototype.renderInfo = function (ctx, x, y) {\n  x = x || 10;\n  y = y || this.canvas.height - 80;\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.font = \"10px Arial\";\n  ctx.fillStyle = \"#888\";\n  ctx.textAlign = \"left\";\n  if (this.graph) {\n    ctx.fillText(\"T: \" + this.graph.globaltime.toFixed(2) + \"s\", 5, 13 * 1);\n    ctx.fillText(\"I: \" + this.graph.iteration, 5, 13 * 2);\n    ctx.fillText(\"N: \" + this.graph._nodes.length + \" [\" + this.visible_nodes.length + \"]\", 5, 13 * 3);\n    ctx.fillText(\"V: \" + this.graph._version, 5, 13 * 4);\n    ctx.fillText(\"FPS:\" + this.fps.toFixed(2), 5, 13 * 5);\n  } else {\n    ctx.fillText(\"No graph selected\", 5, 13 * 1);\n  }\n  ctx.restore();\n};\n\n/**\n * draws the back canvas (the one containing the background and the connections)\n * @method drawBackCanvas\n **/\nLGraphCanvas.prototype.drawBackCanvas = function () {\n  var canvas = this.bgcanvas;\n  if (canvas.width != this.canvas.width || canvas.height != this.canvas.height) {\n    canvas.width = this.canvas.width;\n    canvas.height = this.canvas.height;\n  }\n  if (!this.bgctx) {\n    this.bgctx = this.bgcanvas.getContext(\"2d\");\n  }\n  var ctx = this.bgctx;\n  if (ctx.start) {\n    ctx.start();\n  }\n  var viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height];\n\n  //clear\n  if (this.clear_background) {\n    ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3]);\n  }\n\n  //show subgraph stack header\n  if (this._graph_stack && this._graph_stack.length) {\n    ctx.save();\n    var parent_graph = this._graph_stack[this._graph_stack.length - 1];\n    var subgraph_node = this.graph._subgraph_node;\n    ctx.strokeStyle = subgraph_node.bgcolor;\n    ctx.lineWidth = 10;\n    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n    ctx.lineWidth = 1;\n    ctx.font = \"40px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = subgraph_node.bgcolor || \"#AAA\";\n    var title = \"\";\n    for (var i = 1; i < this._graph_stack.length; ++i) {\n      title += this._graph_stack[i]._subgraph_node.getTitle() + \" >> \";\n    }\n    ctx.fillText(title + subgraph_node.getTitle(), canvas.width * 0.5, 40);\n    ctx.restore();\n  }\n  var bg_already_painted = false;\n  if (this.onRenderBackground) {\n    bg_already_painted = this.onRenderBackground(canvas, ctx);\n  }\n\n  //reset in case of error\n  if (!this.viewport) {\n    ctx.restore();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  }\n  this.visible_links.length = 0;\n  if (this.graph) {\n    //apply transformations\n    ctx.save();\n    this.ds.toCanvasContext(ctx);\n\n    //render BG\n    if (this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color) {\n      ctx.fillStyle = this.clear_background_color;\n      ctx.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]);\n    }\n    if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {\n      if (this.zoom_modify_alpha) {\n        ctx.globalAlpha = (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;\n      } else {\n        ctx.globalAlpha = this.editor_alpha;\n      }\n      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false; // ctx.mozImageSmoothingEnabled = \n      if (!this._bg_img || this._bg_img.name != this.background_image) {\n        this._bg_img = new Image();\n        this._bg_img.name = this.background_image;\n        this._bg_img.src = this.background_image;\n        var that = this;\n        this._bg_img.onload = function () {\n          that.draw(true, true);\n        };\n      }\n      var pattern = null;\n      if (this._pattern == null && this._bg_img.width > 0) {\n        pattern = ctx.createPattern(this._bg_img, \"repeat\");\n        this._pattern_img = this._bg_img;\n        this._pattern = pattern;\n      } else {\n        pattern = this._pattern;\n      }\n      if (pattern) {\n        ctx.fillStyle = pattern;\n        ctx.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]);\n        ctx.fillStyle = \"transparent\";\n      }\n      ctx.globalAlpha = 1.0;\n      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true; //= ctx.mozImageSmoothingEnabled\n    }\n\n    //groups\n    if (this.graph._groups.length && !this.live_mode) {\n      this.drawGroups(canvas, ctx);\n    }\n    if (this.onDrawBackground) {\n      this.onDrawBackground(ctx, this.visible_area);\n    }\n    if (this.onBackgroundRender) {\n      //LEGACY\n      console.error(\"WARNING! onBackgroundRender deprecated, now is named onDrawBackground \");\n      this.onBackgroundRender = null;\n    }\n\n    //DEBUG: show clipping area\n    //ctx.fillStyle = \"red\";\n    //ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);\n\n    //bg\n    if (this.render_canvas_border) {\n      ctx.strokeStyle = \"#235\";\n      ctx.strokeRect(0, 0, canvas.width, canvas.height);\n    }\n    if (this.render_connections_shadows) {\n      ctx.shadowColor = \"#000\";\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n      ctx.shadowBlur = 6;\n    } else {\n      ctx.shadowColor = \"rgba(0,0,0,0)\";\n    }\n\n    //draw connections\n    if (!this.live_mode) {\n      this.drawConnections(ctx);\n    }\n    ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n    //restore state\n    ctx.restore();\n  }\n  if (ctx.finish) {\n    ctx.finish();\n  }\n  this.dirty_bgcanvas = false;\n  this.dirty_canvas = true; //to force to repaint the front canvas with the bgcanvas\n};\nvar temp_vec2 = new Float32Array(2);\n\n/**\n * draws the given node inside the canvas\n * @method drawNode\n **/\nLGraphCanvas.prototype.drawNode = function (node, ctx) {\n  var glow = false;\n  this.current_node = node;\n  var color = node.color || node.constructor.color || NODE_DEFAULT_COLOR;\n  var bgcolor = node.bgcolor || node.constructor.bgcolor || NODE_DEFAULT_BGCOLOR;\n\n  //shadow and glow\n  if (node.mouseOver) {\n    glow = true;\n  }\n  var low_quality = this.ds.scale < 0.6; //zoomed out\n\n  //only render if it forces it to do it\n  if (this.live_mode) {\n    if (!node.flags.collapsed) {\n      ctx.shadowColor = \"transparent\";\n      if (node.onDrawForeground) {\n        node.onDrawForeground(ctx, this, this.canvas);\n      }\n    }\n    return;\n  }\n  var editor_alpha = this.editor_alpha;\n  ctx.globalAlpha = editor_alpha;\n  if (this.render_shadows && !low_quality) {\n    ctx.shadowColor = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DEFAULT_SHADOW_COLOR;\n    ctx.shadowOffsetX = 2 * this.ds.scale;\n    ctx.shadowOffsetY = 2 * this.ds.scale;\n    ctx.shadowBlur = 3 * this.ds.scale;\n  } else {\n    ctx.shadowColor = \"transparent\";\n  }\n\n  //custom draw collapsed method (draw after shadows because they are affected)\n  if (node.flags.collapsed && node.onDrawCollapsed && node.onDrawCollapsed(ctx, this) == true) {\n    return;\n  }\n\n  //clip if required (mask)\n  var shape = node._shape || _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE;\n  var size = temp_vec2;\n  temp_vec2.set(node.size);\n  var horizontal = node.horizontal; // || node.flags.horizontal;\n\n  if (node.flags.collapsed) {\n    ctx.font = this.inner_text_font;\n    var title = node.getTitle ? node.getTitle() : node.title;\n    if (title != null) {\n      node._collapsed_width = Math.min(node.size[0], ctx.measureText(title).width + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT * 2); //NODE_COLLAPSED_WIDTH;\n      size[0] = node._collapsed_width;\n      size[1] = 0;\n    }\n  }\n  if (node.clip_area) {\n    //Start clipping\n    ctx.save();\n    ctx.beginPath();\n    if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n      ctx.rect(0, 0, size[0], size[1]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE) {\n      ctx.roundRect(0, 0, size[0], size[1], [10]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CIRCLE_SHAPE) {\n      ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2);\n    }\n    ctx.clip();\n  }\n\n  //draw shape\n  if (node.has_errors) {\n    bgcolor = \"red\";\n  }\n  this.drawNodeShape(node, ctx, size, color, bgcolor, node.is_selected, node.mouseOver);\n  ctx.shadowColor = \"transparent\";\n\n  //draw foreground\n  if (node.onDrawForeground) {\n    node.onDrawForeground(ctx, this, this.canvas);\n  }\n\n  //connection slots\n  ctx.textAlign = horizontal ? \"center\" : \"left\";\n  ctx.font = this.inner_text_font;\n  var render_text = !low_quality;\n  var out_slot = this.connecting_output;\n  var in_slot = this.connecting_input;\n  ctx.lineWidth = 1;\n  var max_y = 0;\n  var slot_pos = new Float32Array(2); //to reuse\n\n  //render inputs and outputs\n  if (!node.flags.collapsed) {\n    //input connection slots\n    if (node.inputs) {\n      for (var i = 0; i < node.inputs.length; i++) {\n        var slot = node.inputs[i];\n        var slot_type = slot.type;\n        var slot_shape = slot.shape;\n        ctx.globalAlpha = editor_alpha;\n        //change opacity of incompatible slots when dragging a connection\n        if (this.connecting_output && !_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(slot.type, out_slot.type)) {\n          ctx.globalAlpha = 0.4 * editor_alpha;\n        }\n        ctx.fillStyle = slot.link != null ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_off;\n        var pos = node.getConnectionPos(true, i, slot_pos);\n        pos[0] -= node.pos[0];\n        pos[1] -= node.pos[1];\n        if (max_y < pos[1] + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 0.5) {\n          max_y = pos[1] + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 0.5;\n        }\n        ctx.beginPath();\n        if (slot_type == \"array\") {\n          slot_shape = _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.GRID_SHAPE; // place in addInput? addOutput instead?\n        }\n        var doStroke = true;\n        if (slot.type === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || slot.shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n          if (horizontal) {\n            ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n          } else {\n            ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n          }\n        } else if (slot_shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n          ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n          ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n          ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n          ctx.closePath();\n        } else if (slot_shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.GRID_SHAPE) {\n          ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);\n          doStroke = false;\n        } else {\n          if (low_quality) ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8); //faster\n          else ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n        }\n        ctx.fill();\n\n        //render name\n        if (render_text) {\n          var text = slot.label != null ? slot.label : slot.name;\n          if (text) {\n            ctx.fillStyle = NODE_TEXT_COLOR;\n            if (horizontal || slot.dir == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP) {\n              ctx.fillText(text, pos[0], pos[1] - 10);\n            } else {\n              ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n            }\n          }\n        }\n      }\n    }\n\n    //output connection slots\n\n    ctx.textAlign = horizontal ? \"center\" : \"right\";\n    ctx.strokeStyle = \"black\";\n    if (node.outputs) {\n      for (var i = 0; i < node.outputs.length; i++) {\n        var slot = node.outputs[i];\n        var slot_type = slot.type;\n        var slot_shape = slot.shape;\n\n        //change opacity of incompatible slots when dragging a connection\n        if (this.connecting_input && !_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(slot_type, in_slot.type)) {\n          ctx.globalAlpha = 0.4 * editor_alpha;\n        }\n        var pos = node.getConnectionPos(false, i, slot_pos);\n        pos[0] -= node.pos[0];\n        pos[1] -= node.pos[1];\n        if (max_y < pos[1] + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 0.5) {\n          max_y = pos[1] + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_SLOT_HEIGHT * 0.5;\n        }\n        ctx.fillStyle = slot.links && slot.links.length ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_off;\n        ctx.beginPath();\n        //ctx.rect( node.size[0] - 14,i*14,10,10);\n\n        if (slot_type == \"array\") {\n          slot_shape = _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.GRID_SHAPE;\n        }\n        var doStroke = true;\n        if (slot_type === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || slot_shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n          if (horizontal) {\n            ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n          } else {\n            ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n          }\n        } else if (slot_shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n          ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n          ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n          ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n          ctx.closePath();\n        } else if (slot_shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.GRID_SHAPE) {\n          ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);\n          ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);\n          ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);\n          ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);\n          ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);\n          doStroke = false;\n        } else {\n          if (low_quality) ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);else ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n        }\n\n        //trigger\n        //if(slot.node_id != null && slot.slot == -1)\n        //\tctx.fillStyle = \"#F85\";\n\n        //if(slot.links != null && slot.links.length)\n        ctx.fill();\n        if (!low_quality && doStroke) ctx.stroke();\n\n        //render output name\n        if (render_text) {\n          var text = slot.label != null ? slot.label : slot.name;\n          if (text) {\n            ctx.fillStyle = NODE_TEXT_COLOR;\n            if (horizontal || slot.dir == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN) {\n              ctx.fillText(text, pos[0], pos[1] - 8);\n            } else {\n              ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n            }\n          }\n        }\n      }\n    }\n    ctx.textAlign = \"left\";\n    ctx.globalAlpha = 1;\n    if (node.widgets) {\n      var widgets_y = max_y;\n      if (horizontal || node.widgets_up) {\n        widgets_y = 2;\n      }\n      if (node.widgets_start_y != null) widgets_y = node.widgets_start_y;\n      this.drawNodeWidgets(node, widgets_y, ctx, this.node_widget && this.node_widget[0] == node ? this.node_widget[1] : null);\n    }\n  } else if (this.render_collapsed_slots) {\n    //if collapsed\n    var input_slot = null;\n    var output_slot = null;\n\n    //get first connected slot to render\n    if (node.inputs) {\n      for (var i = 0; i < node.inputs.length; i++) {\n        var slot = node.inputs[i];\n        if (slot.link == null) {\n          continue;\n        }\n        input_slot = slot;\n        break;\n      }\n    }\n    if (node.outputs) {\n      for (var i = 0; i < node.outputs.length; i++) {\n        var slot = node.outputs[i];\n        if (!slot.links || !slot.links.length) {\n          continue;\n        }\n        output_slot = slot;\n      }\n    }\n    if (input_slot) {\n      var x = 0;\n      var y = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT * -0.5; //center\n      if (horizontal) {\n        x = node._collapsed_width * 0.5;\n        y = -_settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n      }\n      ctx.fillStyle = \"#686\";\n      ctx.beginPath();\n      if (slot.type === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || slot.shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n        ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n      } else if (slot.shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n        ctx.moveTo(x + 8, y);\n        ctx.lineTo(x + -4, y - 4);\n        ctx.lineTo(x + -4, y + 4);\n        ctx.closePath();\n      } else {\n        ctx.arc(x, y, 4, 0, Math.PI * 2);\n      }\n      ctx.fill();\n    }\n    if (output_slot) {\n      var x = node._collapsed_width;\n      var y = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT * -0.5; //center\n      if (horizontal) {\n        x = node._collapsed_width * 0.5;\n        y = 0;\n      }\n      ctx.fillStyle = \"#686\";\n      ctx.strokeStyle = \"black\";\n      ctx.beginPath();\n      if (slot.type === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || slot.shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n        ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n      } else if (slot.shape === _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ARROW_SHAPE) {\n        ctx.moveTo(x + 6, y);\n        ctx.lineTo(x - 6, y - 4);\n        ctx.lineTo(x - 6, y + 4);\n        ctx.closePath();\n      } else {\n        ctx.arc(x, y, 4, 0, Math.PI * 2);\n      }\n      ctx.fill();\n      //ctx.stroke();\n    }\n  }\n  if (node.clip_area) {\n    ctx.restore();\n  }\n  ctx.globalAlpha = 1.0;\n};\n\n//used by this.over_link_center\nLGraphCanvas.prototype.drawLinkTooltip = function (ctx, link) {\n  var pos = link._pos;\n  ctx.fillStyle = \"black\";\n  ctx.beginPath();\n  ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n  ctx.fill();\n  if (link.data == null) return;\n  if (this.onDrawLinkTooltip) if (this.onDrawLinkTooltip(ctx, link, this) == true) return;\n  var data = link.data;\n  var text = null;\n  if (data.constructor === Number) text = data.toFixed(2);else if (data.constructor === String) text = \"\\\"\" + data + \"\\\"\";else if (data.constructor === Boolean) text = String(data);else if (data.toToolTip) text = data.toToolTip();else text = \"[\" + data.constructor.name + \"]\";\n  if (text == null) return;\n  text = text.substr(0, 30); //avoid weird\n\n  ctx.font = \"14px Courier New\";\n  var info = ctx.measureText(text);\n  var w = info.width + 20;\n  var h = 24;\n  ctx.shadowColor = \"black\";\n  ctx.shadowOffsetX = 2;\n  ctx.shadowOffsetY = 2;\n  ctx.shadowBlur = 3;\n  ctx.fillStyle = \"#454\";\n  ctx.beginPath();\n  ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, [3]);\n  ctx.moveTo(pos[0] - 10, pos[1] - 15);\n  ctx.lineTo(pos[0] + 10, pos[1] - 15);\n  ctx.lineTo(pos[0], pos[1] - 5);\n  ctx.fill();\n  ctx.shadowColor = \"transparent\";\n  ctx.textAlign = \"center\";\n  ctx.fillStyle = \"#CEC\";\n  ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n};\n\n/**\n * draws the shape of the given node in the canvas\n * @method drawNodeShape\n **/\nvar tmp_area = new Float32Array(4);\nLGraphCanvas.prototype.drawNodeShape = function (node, ctx, size, fgcolor, bgcolor, selected, mouse_over) {\n  //bg rect\n  ctx.strokeStyle = fgcolor;\n  ctx.fillStyle = bgcolor;\n  var title_height = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n  var low_quality = this.ds.scale < 0.5;\n\n  //render node area depending on shape\n  var shape = node._shape || node.constructor.shape || _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE;\n  var title_mode = node.constructor.title_mode;\n  var render_title = true;\n  if (title_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.TRANSPARENT_TITLE || title_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NO_TITLE) {\n    render_title = false;\n  } else if (title_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.AUTOHIDE_TITLE && mouse_over) {\n    render_title = true;\n  }\n  var area = tmp_area;\n  area[0] = 0; //x\n  area[1] = render_title ? -title_height : 0; //y\n  area[2] = size[0] + 1; //w\n  area[3] = render_title ? size[1] + title_height : size[1]; //h\n\n  var old_alpha = ctx.globalAlpha;\n\n  //full node shape\n  //if(node.flags.collapsed)\n  {\n    ctx.beginPath();\n    if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE || low_quality) {\n      ctx.fillRect(area[0], area[1], area[2], area[3]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE || shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE) {\n      ctx.roundRect(area[0], area[1], area[2], area[3], shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CIRCLE_SHAPE) {\n      ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2);\n    }\n    ctx.fill();\n\n    //separator\n    if (!node.flags.collapsed && render_title) {\n      ctx.shadowColor = \"transparent\";\n      ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n      ctx.fillRect(0, -1, area[2], 2);\n    }\n  }\n  ctx.shadowColor = \"transparent\";\n  if (node.onDrawBackground) {\n    node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);\n  }\n\n  //title bg (remember, it is rendered ABOVE the node)\n  if (render_title || title_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.TRANSPARENT_TITLE) {\n    //title bar\n    if (node.onDrawTitleBar) {\n      node.onDrawTitleBar(ctx, title_height, size, this.ds.scale, fgcolor);\n    } else if (title_mode != _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.TRANSPARENT_TITLE && (node.constructor.title_color || this.render_title_colored)) {\n      var title_color = node.constructor.title_color || fgcolor;\n      if (node.flags.collapsed) {\n        ctx.shadowColor = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DEFAULT_SHADOW_COLOR;\n      }\n\n      //* gradient test\n      if (this.use_gradients) {\n        var grad = LGraphCanvas.gradients[title_color];\n        if (!grad) {\n          grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);\n          grad.addColorStop(0, title_color); // TODO refactor: validate color !! prevent DOMException\n          grad.addColorStop(1, \"#000\");\n        }\n        ctx.fillStyle = grad;\n      } else {\n        ctx.fillStyle = title_color;\n      }\n\n      //ctx.globalAlpha = 0.5 * old_alpha;\n      ctx.beginPath();\n      if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE || low_quality) {\n        ctx.rect(0, -title_height, size[0] + 1, title_height);\n      } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE || shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE) {\n        ctx.roundRect(0, -title_height, size[0] + 1, title_height, node.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]);\n      }\n      ctx.fill();\n      ctx.shadowColor = \"transparent\";\n    }\n    var colState = false;\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.node_box_coloured_by_mode) {\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES_COLORS[node.mode]) {\n        colState = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES_COLORS[node.mode];\n      }\n    }\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.node_box_coloured_when_on) {\n      colState = node.action_triggered ? \"#FFF\" : node.execute_triggered ? \"#AAA\" : colState;\n    }\n\n    //title box\n    var box_size = 10;\n    if (node.onDrawTitleBox) {\n      node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE || shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CIRCLE_SHAPE || shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE) {\n      if (low_quality) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(title_height * 0.5, title_height * -0.5, box_size * 0.5 + 1, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      ctx.fillStyle = node.boxcolor || colState || NODE_DEFAULT_BOXCOLOR;\n      if (low_quality) ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);else {\n        ctx.beginPath();\n        ctx.arc(title_height * 0.5, title_height * -0.5, box_size * 0.5, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    } else {\n      if (low_quality) {\n        ctx.fillStyle = \"black\";\n        ctx.fillRect((title_height - box_size) * 0.5 - 1, (title_height + box_size) * -0.5 - 1, box_size + 2, box_size + 2);\n      }\n      ctx.fillStyle = node.boxcolor || colState || NODE_DEFAULT_BOXCOLOR;\n      ctx.fillRect((title_height - box_size) * 0.5, (title_height + box_size) * -0.5, box_size, box_size);\n    }\n    ctx.globalAlpha = old_alpha;\n\n    //title text\n    if (node.onDrawTitleText) {\n      node.onDrawTitleText(ctx, title_height, size, this.ds.scale, this.title_text_font, selected);\n    }\n    if (!low_quality) {\n      ctx.font = this.title_text_font;\n      var title = String(node.getTitle());\n      if (title) {\n        if (selected) {\n          ctx.fillStyle = NODE_SELECTED_TITLE_COLOR;\n        } else {\n          ctx.fillStyle = node.constructor.title_text_color || this.node_title_color;\n        }\n        if (node.flags.collapsed) {\n          ctx.textAlign = \"left\";\n          var measure = ctx.measureText(title);\n          ctx.fillText(title.substr(0, 20),\n          //avoid urls too long\n          title_height,\n          // + measure.width * 0.5,\n          NODE_TITLE_TEXT_Y - title_height);\n          ctx.textAlign = \"left\";\n        } else {\n          ctx.textAlign = \"left\";\n          ctx.fillText(title, title_height, NODE_TITLE_TEXT_Y - title_height);\n        }\n      }\n    }\n\n    //subgraph box\n    if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n      var w = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n      var x = node.size[0] - w;\n      var over = isInsideRectangle(this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x + 2, -w + 2, w - 4, w - 4);\n      ctx.fillStyle = over ? \"#888\" : \"#555\";\n      if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE || low_quality) ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);else {\n        ctx.beginPath();\n        ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, [4]);\n        ctx.fill();\n      }\n      ctx.fillStyle = \"#333\";\n      ctx.beginPath();\n      ctx.moveTo(x + w * 0.2, -w * 0.6);\n      ctx.lineTo(x + w * 0.8, -w * 0.6);\n      ctx.lineTo(x + w * 0.5, -w * 0.3);\n      ctx.fill();\n    }\n\n    //custom title render\n    if (node.onDrawTitle) {\n      node.onDrawTitle(ctx);\n    }\n  }\n\n  //render selection marker\n  if (selected) {\n    if (node.onBounding) {\n      node.onBounding(area);\n    }\n    if (title_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.TRANSPARENT_TITLE) {\n      area[1] -= title_height;\n      area[3] += title_height;\n    }\n    ctx.lineWidth = 1;\n    ctx.globalAlpha = 0.8;\n    ctx.beginPath();\n    if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.BOX_SHAPE) {\n      ctx.rect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.ROUND_SHAPE || shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE && node.flags.collapsed) {\n      ctx.roundRect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3], [this.round_radius * 2]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CARD_SHAPE) {\n      ctx.roundRect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3], [this.round_radius * 2, 2, this.round_radius * 2, 2]);\n    } else if (shape == _settings_js__WEBPACK_IMPORTED_MODULE_6__.SHAPES.CIRCLE_SHAPE) {\n      ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5 + 6, 0, Math.PI * 2);\n    }\n    ctx.strokeStyle = NODE_BOX_OUTLINE_COLOR;\n    ctx.stroke();\n    ctx.strokeStyle = fgcolor;\n    ctx.globalAlpha = 1;\n  }\n\n  // these counter helps in conditioning drawing based on if the node has been executed or an action occurred\n  if (node.execute_triggered > 0) node.execute_triggered--;\n  if (node.action_triggered > 0) node.action_triggered--;\n};\nvar margin_area = new Float32Array(4);\nvar link_bounding = new Float32Array(4);\nvar tempA = new Float32Array(2);\nvar tempB = new Float32Array(2);\n\n/**\n * draws every connection visible in the canvas\n * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n * @method drawConnections\n **/\nLGraphCanvas.prototype.drawConnections = function (ctx) {\n  var now = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  var visible_area = this.visible_area;\n  margin_area[0] = visible_area[0] - 20;\n  margin_area[1] = visible_area[1] - 20;\n  margin_area[2] = visible_area[2] + 40;\n  margin_area[3] = visible_area[3] + 40;\n\n  //draw connections\n  ctx.lineWidth = this.connections_width;\n  ctx.fillStyle = \"#AAA\";\n  ctx.strokeStyle = \"#AAA\";\n  ctx.globalAlpha = this.editor_alpha;\n  //for every node\n  var nodes = this.graph._nodes;\n  for (var n = 0, l = nodes.length; n < l; ++n) {\n    var node = nodes[n];\n    //for every input (we render just inputs because it is easier as every slot can only have one input)\n    if (!node.inputs || !node.inputs.length) {\n      continue;\n    }\n    for (var i = 0; i < node.inputs.length; ++i) {\n      var input = node.inputs[i];\n      if (!input || input.link == null) {\n        continue;\n      }\n      var link_id = input.link;\n      var link = this.graph.links[link_id];\n      if (!link) {\n        continue;\n      }\n\n      //find link info\n      var start_node = this.graph.getNodeById(link.origin_id);\n      if (start_node == null) {\n        continue;\n      }\n      var start_node_slot = link.origin_slot;\n      var start_node_slotpos = null;\n      if (start_node_slot == -1) {\n        start_node_slotpos = [start_node.pos[0] + 10, start_node.pos[1] + 10];\n      } else {\n        start_node_slotpos = start_node.getConnectionPos(false, start_node_slot, tempA);\n      }\n      var end_node_slotpos = node.getConnectionPos(true, i, tempB);\n\n      //compute link bounding\n      link_bounding[0] = start_node_slotpos[0];\n      link_bounding[1] = start_node_slotpos[1];\n      link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];\n      link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];\n      if (link_bounding[2] < 0) {\n        link_bounding[0] += link_bounding[2];\n        link_bounding[2] = Math.abs(link_bounding[2]);\n      }\n      if (link_bounding[3] < 0) {\n        link_bounding[1] += link_bounding[3];\n        link_bounding[3] = Math.abs(link_bounding[3]);\n      }\n\n      //skip links outside of the visible area of the canvas\n      if (!overlapBounding(link_bounding, margin_area)) {\n        continue;\n      }\n      var start_slot = start_node.outputs[start_node_slot];\n      var end_slot = node.inputs[i];\n      if (!start_slot || !end_slot) {\n        continue;\n      }\n      var start_dir = start_slot.dir || (start_node.horizontal ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT);\n      var end_dir = end_slot.dir || (node.horizontal ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT);\n      this.renderLink(ctx, start_node_slotpos, end_node_slotpos, link, false, 0, null, start_dir, end_dir);\n\n      //event triggered rendered on top\n      if (link && link._last_time && now - link._last_time < 1000) {\n        var f = 2.0 - (now - link._last_time) * 0.002;\n        var tmp = ctx.globalAlpha;\n        ctx.globalAlpha = tmp * f;\n        this.renderLink(ctx, start_node_slotpos, end_node_slotpos, link, true, f, \"white\", start_dir, end_dir);\n        ctx.globalAlpha = tmp;\n      }\n    }\n  }\n  ctx.globalAlpha = 1;\n};\n\n/**\n * draws a link between two points\n * @method renderLink\n * @param {vec2} a start pos\n * @param {vec2} b end pos\n * @param {Object} link the link object with all the link info\n * @param {boolean} skip_border ignore the shadow of the link\n * @param {boolean} flow show flow animation (for events)\n * @param {string} color the color for the link\n * @param {number} start_dir the direction enum\n * @param {number} end_dir the direction enum\n * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)\n **/\nLGraphCanvas.prototype.renderLink = function (ctx, a, b, link, skip_border, flow, color, start_dir, end_dir, num_sublines) {\n  if (link) {\n    this.visible_links.push(link);\n  }\n\n  //choose color\n  if (!color && link) {\n    color = link.color || LGraphCanvas.link_type_colors[link.type];\n  }\n  if (!color) {\n    color = this.default_link_color;\n  }\n  if (link != null && this.highlighted_links[link.id]) {\n    color = \"#FFF\";\n  }\n  start_dir = start_dir || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT;\n  end_dir = end_dir || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT;\n  var dist = distance(a, b);\n  if (this.render_connections_border && this.ds.scale > 0.6) {\n    ctx.lineWidth = this.connections_width + 4;\n  }\n  ctx.lineJoin = \"round\";\n  num_sublines = num_sublines || 1;\n  if (num_sublines > 1) {\n    ctx.lineWidth = 0.5;\n  }\n\n  //begin line shape\n  ctx.beginPath();\n  for (var i = 0; i < num_sublines; i += 1) {\n    var offsety = (i - (num_sublines - 1) * 0.5) * 5;\n    if (this.links_render_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.SPLINE_LINK) {\n      ctx.moveTo(a[0], a[1] + offsety);\n      var start_offset_x = 0;\n      var start_offset_y = 0;\n      var end_offset_x = 0;\n      var end_offset_y = 0;\n      switch (start_dir) {\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n          start_offset_x = dist * -0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n          start_offset_x = dist * 0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n          start_offset_y = dist * -0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n          start_offset_y = dist * 0.25;\n          break;\n      }\n      switch (end_dir) {\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n          end_offset_x = dist * -0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n          end_offset_x = dist * 0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n          end_offset_y = dist * -0.25;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n          end_offset_y = dist * 0.25;\n          break;\n      }\n      ctx.bezierCurveTo(a[0] + start_offset_x, a[1] + start_offset_y + offsety, b[0] + end_offset_x, b[1] + end_offset_y + offsety, b[0], b[1] + offsety);\n    } else if (this.links_render_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LINEAR_LINK) {\n      ctx.moveTo(a[0], a[1] + offsety);\n      var start_offset_x = 0;\n      var start_offset_y = 0;\n      var end_offset_x = 0;\n      var end_offset_y = 0;\n      switch (start_dir) {\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n          start_offset_x = -1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n          start_offset_x = 1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n          start_offset_y = -1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n          start_offset_y = 1;\n          break;\n      }\n      switch (end_dir) {\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n          end_offset_x = -1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n          end_offset_x = 1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n          end_offset_y = -1;\n          break;\n        case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n          end_offset_y = 1;\n          break;\n      }\n      var l = 15;\n      ctx.lineTo(a[0] + start_offset_x * l, a[1] + start_offset_y * l + offsety);\n      ctx.lineTo(b[0] + end_offset_x * l, b[1] + end_offset_y * l + offsety);\n      ctx.lineTo(b[0], b[1] + offsety);\n    } else if (this.links_render_mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.STRAIGHT_LINK) {\n      ctx.moveTo(a[0], a[1]);\n      var start_x = a[0];\n      var start_y = a[1];\n      var end_x = b[0];\n      var end_y = b[1];\n      if (start_dir == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT) {\n        start_x += 10;\n      } else {\n        start_y += 10;\n      }\n      if (end_dir == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT) {\n        end_x -= 10;\n      } else {\n        end_y -= 10;\n      }\n      ctx.lineTo(start_x, start_y);\n      ctx.lineTo((start_x + end_x) * 0.5, start_y);\n      ctx.lineTo((start_x + end_x) * 0.5, end_y);\n      ctx.lineTo(end_x, end_y);\n      ctx.lineTo(b[0], b[1]);\n    } else {\n      return;\n    } //unknown\n  }\n\n  //rendering the outline of the connection can be a little bit slow\n  if (this.render_connections_border && this.ds.scale > 0.6 && !skip_border) {\n    ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n    ctx.stroke();\n  }\n  ctx.lineWidth = this.connections_width;\n  ctx.fillStyle = ctx.strokeStyle = color;\n  ctx.stroke();\n  //end line shape\n\n  var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);\n  if (link && link._pos) {\n    link._pos[0] = pos[0];\n    link._pos[1] = pos[1];\n  }\n\n  //render arrow in the middle\n  if (this.ds.scale >= 0.6 && this.highquality_render && end_dir != _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.CENTER) {\n    //render arrow\n    if (this.render_connection_arrows) {\n      //compute two points in the connection\n      var posA = this.computeConnectionPoint(a, b, 0.25, start_dir, end_dir);\n      var posB = this.computeConnectionPoint(a, b, 0.26, start_dir, end_dir);\n      var posC = this.computeConnectionPoint(a, b, 0.75, start_dir, end_dir);\n      var posD = this.computeConnectionPoint(a, b, 0.76, start_dir, end_dir);\n\n      //compute the angle between them so the arrow points in the right direction\n      var angleA = 0;\n      var angleB = 0;\n      if (this.render_curved_connections) {\n        angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n        angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n      } else {\n        angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n      }\n\n      //render arrow\n      ctx.save();\n      ctx.translate(posA[0], posA[1]);\n      ctx.rotate(angleA);\n      ctx.beginPath();\n      ctx.moveTo(-5, -3);\n      ctx.lineTo(0, +7);\n      ctx.lineTo(+5, -3);\n      ctx.fill();\n      ctx.restore();\n      ctx.save();\n      ctx.translate(posC[0], posC[1]);\n      ctx.rotate(angleB);\n      ctx.beginPath();\n      ctx.moveTo(-5, -3);\n      ctx.lineTo(0, +7);\n      ctx.lineTo(+5, -3);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    //circle\n    ctx.beginPath();\n    ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  //render flowing points\n  if (flow) {\n    ctx.fillStyle = color;\n    for (var i = 0; i < 5; ++i) {\n      var f = ((0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)() * 0.001 + i * 0.2) % 1;\n      var pos = this.computeConnectionPoint(a, b, f, start_dir, end_dir);\n      ctx.beginPath();\n      ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n};\n\n//returns the link center point based on curvature\nLGraphCanvas.prototype.computeConnectionPoint = function (a, b, t, start_dir, end_dir) {\n  start_dir = start_dir || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT;\n  end_dir = end_dir || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT;\n  var dist = distance(a, b);\n  var p0 = a;\n  var p1 = [a[0], a[1]];\n  var p2 = [b[0], b[1]];\n  var p3 = b;\n  switch (start_dir) {\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n      p1[0] += dist * -0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n      p1[0] += dist * 0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n      p1[1] += dist * -0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n      p1[1] += dist * 0.25;\n      break;\n  }\n  switch (end_dir) {\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LEFT:\n      p2[0] += dist * -0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.RIGHT:\n      p2[0] += dist * 0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.UP:\n      p2[1] += dist * -0.25;\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DOWN:\n      p2[1] += dist * 0.25;\n      break;\n  }\n  var c1 = (1 - t) * (1 - t) * (1 - t);\n  var c2 = 3 * ((1 - t) * (1 - t)) * t;\n  var c3 = 3 * (1 - t) * (t * t);\n  var c4 = t * t * t;\n  var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n  var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n  return [x, y];\n};\nLGraphCanvas.prototype.drawExecutionOrder = function (ctx) {\n  ctx.shadowColor = \"transparent\";\n  ctx.globalAlpha = 0.25;\n  ctx.textAlign = \"center\";\n  ctx.strokeStyle = \"white\";\n  ctx.globalAlpha = 0.75;\n  var visible_nodes = this.visible_nodes;\n  for (var i = 0; i < visible_nodes.length; ++i) {\n    var node = visible_nodes[i];\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(node.pos[0] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, node.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT);\n    if (node.order == 0) {\n      ctx.strokeRect(node.pos[0] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT + 0.5, node.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT + 0.5, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT, _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT);\n    }\n    ctx.fillStyle = \"#FFF\";\n    ctx.fillText(node.order, node.pos[0] + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT * -0.5, node.pos[1] - 6);\n  }\n  ctx.globalAlpha = 1;\n};\n\n/**\n * draws the widgets stored inside a node\n * @method drawNodeWidgets\n **/\nLGraphCanvas.prototype.drawNodeWidgets = function (node, posY, ctx, active_widget) {\n  if (!node.widgets || !node.widgets.length) {\n    return 0;\n  }\n  var width = node.size[0];\n  var widgets = node.widgets;\n  posY += 2;\n  var H = _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_WIDGET_HEIGHT;\n  var show_text = this.ds.scale > 0.5;\n  ctx.save();\n  ctx.globalAlpha = this.editor_alpha;\n  var outline_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.WIDGET_OUTLINE_COLOR;\n  var background_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.WIDGET_BGCOLOR;\n  var text_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.WIDGET_TEXT_COLOR;\n  var secondary_text_color = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;\n  var margin = 15;\n  for (var i = 0; i < widgets.length; ++i) {\n    var w = widgets[i];\n    var y = posY;\n    if (w.y) {\n      y = w.y;\n    }\n    w.last_y = y;\n    ctx.strokeStyle = outline_color;\n    ctx.fillStyle = \"#222\";\n    ctx.textAlign = \"left\";\n    //ctx.lineWidth = 2;\n    if (w.disabled) ctx.globalAlpha *= 0.5;\n    var widget_width = w.width || width;\n    switch (w.type) {\n      case \"button\":\n        if (w.clicked) {\n          ctx.fillStyle = \"#AAA\";\n          w.clicked = false;\n          this.dirty_canvas = true;\n        }\n        ctx.fillRect(margin, y, widget_width - margin * 2, H);\n        if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n        if (show_text) {\n          ctx.textAlign = \"center\";\n          ctx.fillStyle = text_color;\n          ctx.fillText(w.label || w.name, widget_width * 0.5, y + H * 0.7);\n        }\n        break;\n      case \"toggle\":\n        ctx.textAlign = \"left\";\n        ctx.strokeStyle = outline_color;\n        ctx.fillStyle = background_color;\n        ctx.beginPath();\n        if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n        ctx.fill();\n        if (show_text && !w.disabled) ctx.stroke();\n        ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n        ctx.beginPath();\n        ctx.arc(widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n        ctx.fill();\n        if (show_text) {\n          ctx.fillStyle = secondary_text_color;\n          const label = w.label || w.name;\n          if (label != null) {\n            ctx.fillText(label, margin * 2, y + H * 0.7);\n          }\n          ctx.fillStyle = w.value ? text_color : secondary_text_color;\n          ctx.textAlign = \"right\";\n          ctx.fillText(w.value ? w.options.on || \"true\" : w.options.off || \"false\", widget_width - 40, y + H * 0.7);\n        }\n        break;\n      case \"slider\":\n        ctx.fillStyle = background_color;\n        ctx.fillRect(margin, y, widget_width - margin * 2, H);\n        var range = w.options.max - w.options.min;\n        var nvalue = (w.value - w.options.min) / range;\n        if (nvalue < 0.0) nvalue = 0.0;\n        if (nvalue > 1.0) nvalue = 1.0;\n        ctx.fillStyle = w.options.hasOwnProperty(\"slider_color\") ? w.options.slider_color : active_widget == w ? \"#89A\" : \"#678\";\n        ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);\n        if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n        if (w.marker) {\n          var marker_nvalue = (w.marker - w.options.min) / range;\n          if (marker_nvalue < 0.0) marker_nvalue = 0.0;\n          if (marker_nvalue > 1.0) marker_nvalue = 1.0;\n          ctx.fillStyle = w.options.hasOwnProperty(\"marker_color\") ? w.options.marker_color : \"#AA9\";\n          ctx.fillRect(margin + marker_nvalue * (widget_width - margin * 2), y, 2, H);\n        }\n        if (show_text) {\n          ctx.textAlign = \"center\";\n          ctx.fillStyle = text_color;\n          ctx.fillText(w.label || w.name + \"  \" + Number(w.value).toFixed(w.options.precision != null ? w.options.precision : 3), widget_width * 0.5, y + H * 0.7);\n        }\n        break;\n      case \"number\":\n      case \"combo\":\n        ctx.textAlign = \"left\";\n        ctx.strokeStyle = outline_color;\n        ctx.fillStyle = background_color;\n        ctx.beginPath();\n        if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n        ctx.fill();\n        if (show_text) {\n          if (!w.disabled) ctx.stroke();\n          ctx.fillStyle = text_color;\n          if (!w.disabled) {\n            ctx.beginPath();\n            ctx.moveTo(margin + 16, y + 5);\n            ctx.lineTo(margin + 6, y + H * 0.5);\n            ctx.lineTo(margin + 16, y + H - 5);\n            ctx.fill();\n            ctx.beginPath();\n            ctx.moveTo(widget_width - margin - 16, y + 5);\n            ctx.lineTo(widget_width - margin - 6, y + H * 0.5);\n            ctx.lineTo(widget_width - margin - 16, y + H - 5);\n            ctx.fill();\n          }\n          ctx.fillStyle = secondary_text_color;\n          ctx.fillText(w.label || w.name, margin * 2 + 5, y + H * 0.7);\n          ctx.fillStyle = text_color;\n          ctx.textAlign = \"right\";\n          if (w.type == \"number\") {\n            ctx.fillText(Number(w.value).toFixed(w.options.precision !== undefined ? w.options.precision : 3), widget_width - margin * 2 - 20, y + H * 0.7);\n          } else {\n            var v = w.value;\n            if (w.options.values) {\n              var values = w.options.values;\n              if (values.constructor === Function) values = values();\n              if (values && values.constructor !== Array) v = values[w.value];\n            }\n            ctx.fillText(v, widget_width - margin * 2 - 20, y + H * 0.7);\n          }\n        }\n        break;\n      case \"string\":\n      case \"text\":\n        ctx.textAlign = \"left\";\n        ctx.strokeStyle = outline_color;\n        ctx.fillStyle = background_color;\n        ctx.beginPath();\n        if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n        ctx.fill();\n        if (show_text) {\n          if (!w.disabled) ctx.stroke();\n          ctx.save();\n          ctx.beginPath();\n          ctx.rect(margin, y, widget_width - margin * 2, H);\n          ctx.clip();\n\n          //ctx.stroke();\n          ctx.fillStyle = secondary_text_color;\n          const label = w.label || w.name;\n          if (label != null) {\n            ctx.fillText(label, margin * 2, y + H * 0.7);\n          }\n          ctx.fillStyle = text_color;\n          ctx.textAlign = \"right\";\n          ctx.fillText(String(w.value).substr(0, 30), widget_width - margin * 2, y + H * 0.7); //30 chars max\n          ctx.restore();\n        }\n        break;\n      default:\n        if (w.draw) {\n          w.draw(ctx, node, widget_width, y, H);\n        }\n        break;\n    }\n    posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;\n    ctx.globalAlpha = this.editor_alpha;\n  }\n  ctx.restore();\n  ctx.textAlign = \"left\";\n};\n\n/**\n * process an event on widgets\n * @method processNodeWidgets\n **/\nLGraphCanvas.prototype.processNodeWidgets = function (node, pos, event, active_widget) {\n  if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) {\n    return null;\n  }\n  var x = pos[0] - node.pos[0];\n  var y = pos[1] - node.pos[1];\n  var width = node.size[0];\n  var deltaX = event.deltaX || event.deltax || 0;\n  var that = this;\n  var ref_window = this.getCanvasWindow();\n  for (var i = 0; i < node.widgets.length; ++i) {\n    var w = node.widgets[i];\n    if (!w || w.disabled) continue;\n    var widget_height = w.computeSize ? w.computeSize(width)[1] : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_WIDGET_HEIGHT;\n    var widget_width = w.width || width;\n    //outside\n    if (w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined)) continue;\n    var old_value = w.value;\n\n    //if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {\n    //inside widget\n    switch (w.type) {\n      case \"button\":\n        if (event.type === _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"down\") {\n          if (w.callback) {\n            setTimeout(function () {\n              w.callback(w, that, node, pos, event);\n            }, 20);\n          }\n          w.clicked = true;\n          this.dirty_canvas = true;\n        }\n        break;\n      case \"slider\":\n        var old_value = w.value;\n        var nvalue = clamp((x - 15) / (widget_width - 30), 0, 1);\n        if (w.options.read_only) break;\n        w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n        if (old_value != w.value) {\n          setTimeout(function () {\n            inner_value_change(w, w.value);\n          }, 20);\n        }\n        this.dirty_canvas = true;\n        break;\n      case \"number\":\n      case \"combo\":\n        var old_value = w.value;\n        if (event.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"move\" && w.type == \"number\") {\n          if (deltaX) w.value += deltaX * 0.1 * (w.options.step || 1);\n          if (w.options.min != null && w.value < w.options.min) {\n            w.value = w.options.min;\n          }\n          if (w.options.max != null && w.value > w.options.max) {\n            w.value = w.options.max;\n          }\n        } else if (event.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"down\") {\n          var values = w.options.values;\n          if (values && values.constructor === Function) {\n            values = w.options.values(w, node);\n          }\n          var values_list = null;\n          if (w.type != \"number\") values_list = values.constructor === Array ? values : Object.keys(values);\n          var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n          if (w.type == \"number\") {\n            w.value += delta * 0.1 * (w.options.step || 1);\n            if (w.options.min != null && w.value < w.options.min) {\n              w.value = w.options.min;\n            }\n            if (w.options.max != null && w.value > w.options.max) {\n              w.value = w.options.max;\n            }\n          } else if (delta) {\n            //clicked in arrow, used for combos \n            var index = -1;\n            this.last_mouseclick = 0; //avoids dobl click event\n            if (values.constructor === Object) index = values_list.indexOf(String(w.value)) + delta;else index = values_list.indexOf(w.value) + delta;\n            if (index >= values_list.length) {\n              index = values_list.length - 1;\n            }\n            if (index < 0) {\n              index = 0;\n            }\n            if (values.constructor === Array) w.value = values[index];else w.value = index;\n          } else {\n            //combo clicked \n            var text_values = values != values_list ? Object.values(values) : values;\n            var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(text_values, {\n              scale: Math.max(1, this.ds.scale),\n              event: event,\n              className: \"dark\",\n              callback: inner_clicked.bind(w)\n            }, ref_window);\n            function inner_clicked(v, option, event) {\n              if (values != values_list) v = text_values.indexOf(v);\n              this.value = v;\n              inner_value_change(this, v);\n              that.dirty_canvas = true;\n              return false;\n            }\n          }\n        } //end mousedown\n        else if (event.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"up\" && w.type == \"number\") {\n          var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n          if (event.click_time < 200 && delta == 0) {\n            this.prompt(\"Value\", w.value, function (v) {\n              // check if v is a valid equation or a number\n              if (/^[0-9+\\-*/()\\s]+|\\d+\\.\\d+$/.test(v)) {\n                try {\n                  //solve the equation if possible\n                  v = eval(v);\n                } catch (e) {}\n              }\n              this.value = Number(v);\n              inner_value_change(this, this.value);\n            }.bind(w), event);\n          }\n        }\n        if (old_value != w.value) setTimeout(function () {\n          inner_value_change(this, this.value);\n        }.bind(w), 20);\n        this.dirty_canvas = true;\n        break;\n      case \"toggle\":\n        if (event.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"down\") {\n          w.value = !w.value;\n          setTimeout(function () {\n            inner_value_change(w, w.value);\n          }, 20);\n        }\n        break;\n      case \"string\":\n      case \"text\":\n        if (event.type == _libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerevents_method + \"down\") {\n          this.prompt(\"Value\", w.value, function (v) {\n            inner_value_change(this, v);\n          }.bind(w), event, w.options ? w.options.multiline : false);\n        }\n        break;\n      default:\n        if (w.mouse) {\n          this.dirty_canvas = w.mouse(event, [x, y], node);\n        }\n        break;\n    } //end switch\n\n    //value changed\n    if (old_value != w.value) {\n      if (node.onWidgetChanged) node.onWidgetChanged(w.name, w.value, old_value, w);\n      node.graph._version++;\n    }\n    return w;\n  } //end for\n\n  function inner_value_change(widget, value) {\n    if (widget.type == \"number\") {\n      value = Number(value);\n    }\n    widget.value = value;\n    if (widget.options && widget.options.property && node.properties[widget.options.property] !== undefined) {\n      node.setProperty(widget.options.property, value);\n    }\n    if (widget.callback) {\n      widget.callback(widget.value, that, node, pos, event);\n    }\n  }\n  return null;\n};\n\n/**\n * draws every group area in the background\n * @method drawGroups\n **/\nLGraphCanvas.prototype.drawGroups = function (canvas, ctx) {\n  if (!this.graph) {\n    return;\n  }\n  var groups = this.graph._groups;\n  ctx.save();\n  ctx.globalAlpha = 0.5 * this.editor_alpha;\n  for (var i = 0; i < groups.length; ++i) {\n    var group = groups[i];\n    if (!overlapBounding(this.visible_area, group._bounding)) {\n      continue;\n    } //out of the visible area\n\n    ctx.fillStyle = group.color || \"#335\";\n    ctx.strokeStyle = group.color || \"#335\";\n    var pos = group._pos;\n    var size = group._size;\n    ctx.globalAlpha = 0.25 * this.editor_alpha;\n    ctx.beginPath();\n    ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n    ctx.fill();\n    ctx.globalAlpha = this.editor_alpha;\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n    ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n    ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n    ctx.fill();\n    var font_size = group.font_size || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.DEFAULT_GROUP_FONT_SIZE;\n    ctx.font = font_size + \"px Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);\n  }\n  ctx.restore();\n};\nLGraphCanvas.prototype.adjustNodesSize = function () {\n  var nodes = this.graph._nodes;\n  for (var i = 0; i < nodes.length; ++i) {\n    nodes[i].size = nodes[i].computeSize();\n  }\n  this.setDirty(true, true);\n};\n\n/**\n * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode\n * @method resize\n **/\nLGraphCanvas.prototype.resize = function (width, height) {\n  if (!width && !height) {\n    var parent = this.canvas.parentNode;\n    width = parent.offsetWidth;\n    height = parent.offsetHeight;\n  }\n  if (this.canvas.width == width && this.canvas.height == height) {\n    return;\n  }\n  this.canvas.width = width;\n  this.canvas.height = height;\n  this.bgcanvas.width = this.canvas.width;\n  this.bgcanvas.height = this.canvas.height;\n  this.setDirty(true, true);\n};\n\n/**\n * switches to live mode (node shapes are not rendered, only the content)\n * this feature was designed when graphs where meant to create user interfaces\n * @method switchLiveMode\n **/\nLGraphCanvas.prototype.switchLiveMode = function (transition) {\n  if (!transition) {\n    this.live_mode = !this.live_mode;\n    this.dirty_canvas = true;\n    this.dirty_bgcanvas = true;\n    return;\n  }\n  var self = this;\n  var delta = this.live_mode ? 1.1 : 0.9;\n  if (this.live_mode) {\n    this.live_mode = false;\n    this.editor_alpha = 0.1;\n  }\n  var t = setInterval(function () {\n    self.editor_alpha *= delta;\n    self.dirty_canvas = true;\n    self.dirty_bgcanvas = true;\n    if (delta < 1 && self.editor_alpha < 0.01) {\n      clearInterval(t);\n      if (delta < 1) {\n        self.live_mode = true;\n      }\n    }\n    if (delta > 1 && self.editor_alpha > 0.99) {\n      clearInterval(t);\n      self.editor_alpha = 1;\n    }\n  }, 1);\n};\nLGraphCanvas.prototype.onNodeSelectionChange = function (node) {\n  return; //disabled\n};\n\n/* CONTEXT MENU ********************/\n\nLGraphCanvas.onGroupAdd = function (info, entry, mouse_event) {\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var group = new _l_graph_group_js__WEBPACK_IMPORTED_MODULE_2__.LGraphGroup();\n  group.pos = canvas.convertEventToCanvasOffset(mouse_event);\n  canvas.graph.add(group);\n};\n\n/**\n * Determines the furthest nodes in each direction\n * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted\n * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\n */\nLGraphCanvas.getBoundaryNodes = function (nodes) {\n  let top = null;\n  let right = null;\n  let bottom = null;\n  let left = null;\n  for (const nID in nodes) {\n    const node = nodes[nID];\n    const [x, y] = node.pos;\n    const [width, height] = node.size;\n    if (top === null || y < top.pos[1]) {\n      top = node;\n    }\n    if (right === null || x + width > right.pos[0] + right.size[0]) {\n      right = node;\n    }\n    if (bottom === null || y + height > bottom.pos[1] + bottom.size[1]) {\n      bottom = node;\n    }\n    if (left === null || x < left.pos[0]) {\n      left = node;\n    }\n  }\n  return {\n    \"top\": top,\n    \"right\": right,\n    \"bottom\": bottom,\n    \"left\": left\n  };\n};\n/**\n * Determines the furthest nodes in each direction for the currently selected nodes\n * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\n */\nLGraphCanvas.prototype.boundaryNodesForSelection = function () {\n  return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));\n};\n\n/**\n *\n * @param {LGraphNode[]} nodes a list of nodes\n * @param {\"top\"|\"bottom\"|\"left\"|\"right\"} direction Direction to align the nodes\n * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)\n */\nLGraphCanvas.alignNodes = function (nodes, direction, align_to) {\n  if (!nodes) {\n    return;\n  }\n  const canvas = LGraphCanvas.active_canvas;\n  let boundaryNodes = [];\n  if (align_to === undefined) {\n    boundaryNodes = LGraphCanvas.getBoundaryNodes(nodes);\n  } else {\n    boundaryNodes = {\n      \"top\": align_to,\n      \"right\": align_to,\n      \"bottom\": align_to,\n      \"left\": align_to\n    };\n  }\n  for (const [_, node] of Object.entries(canvas.selected_nodes)) {\n    switch (direction) {\n      case \"right\":\n        node.pos[0] = boundaryNodes[\"right\"].pos[0] + boundaryNodes[\"right\"].size[0] - node.size[0];\n        break;\n      case \"left\":\n        node.pos[0] = boundaryNodes[\"left\"].pos[0];\n        break;\n      case \"top\":\n        node.pos[1] = boundaryNodes[\"top\"].pos[1];\n        break;\n      case \"bottom\":\n        node.pos[1] = boundaryNodes[\"bottom\"].pos[1] + boundaryNodes[\"bottom\"].size[1] - node.size[1];\n        break;\n    }\n  }\n  canvas.dirty_canvas = true;\n  canvas.dirty_bgcanvas = true;\n};\nLGraphCanvas.onNodeAlign = function (value, options, event, prev_menu, node) {\n  new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n    event: event,\n    callback: inner_clicked,\n    parentMenu: prev_menu\n  });\n  function inner_clicked(value) {\n    LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase(), node);\n  }\n};\nLGraphCanvas.onGroupAlign = function (value, options, event, prev_menu) {\n  new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n    event: event,\n    callback: inner_clicked,\n    parentMenu: prev_menu\n  });\n  function inner_clicked(value) {\n    LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase());\n  }\n};\nLGraphCanvas.onMenuAdd = function (node, options, e, prev_menu, callback) {\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var graph = canvas.graph;\n  if (!graph) return;\n  function inner_onMenuAdded(base_category, prev_menu) {\n    var categories = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function (category) {\n      return category.startsWith(base_category);\n    });\n    var entries = [];\n    categories.map(function (category) {\n      if (!category) return;\n      var base_category_regex = new RegExp('^(' + base_category + ')');\n      var category_name = category.replace(base_category_regex, \"\").split('/')[0];\n      var category_path = base_category === '' ? category_name + '/' : base_category + category_name + '/';\n      var name = category_name;\n      if (name.indexOf(\"::\") != -1)\n        //in case it has a namespace like \"shader::math/rand\" it hides the namespace\n        name = name.split(\"::\")[1];\n      var index = entries.findIndex(function (entry) {\n        return entry.value === category_path;\n      });\n      if (index === -1) {\n        entries.push({\n          value: category_path,\n          content: name,\n          has_submenu: true,\n          callback: function (value, event, mouseEvent, contextMenu) {\n            inner_onMenuAdded(value.value, contextMenu);\n          }\n        });\n      }\n    });\n    var nodes = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n    nodes.map(function (node) {\n      if (node.skip_list) return;\n      var entry = {\n        value: node.type,\n        content: node.title,\n        has_submenu: false,\n        callback: function (value, event, mouseEvent, contextMenu) {\n          var first_event = contextMenu.getFirstEvent();\n          canvas.graph.beforeChange();\n          var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(value.value);\n          if (node) {\n            node.pos = canvas.convertEventToCanvasOffset(first_event);\n            canvas.graph.add(node);\n          }\n          if (callback) callback(node);\n          canvas.graph.afterChange();\n        }\n      };\n      entries.push(entry);\n    });\n    new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(entries, {\n      event: e,\n      parentMenu: prev_menu\n    }, ref_window);\n  }\n  inner_onMenuAdded('', prev_menu);\n  return false;\n};\nLGraphCanvas.onMenuCollapseAll = function () {};\nLGraphCanvas.onMenuNodeEdit = function () {};\nLGraphCanvas.showMenuNodeOptionalInputs = function (v, options, e, prev_menu, node) {\n  if (!node) {\n    return;\n  }\n  var that = this;\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var options = node.optional_inputs;\n  if (node.onGetInputs) {\n    options = node.onGetInputs();\n  }\n  var entries = [];\n  if (options) {\n    for (var i = 0; i < options.length; i++) {\n      var entry = options[i];\n      if (!entry) {\n        entries.push(null);\n        continue;\n      }\n      var label = entry[0];\n      if (!entry[2]) entry[2] = {};\n      if (entry[2].label) {\n        label = entry[2].label;\n      }\n      entry[2].removable = true;\n      var data = {\n        content: label,\n        value: entry\n      };\n      if (entry[1] == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ACTION) {\n        data.className = \"event\";\n      }\n      entries.push(data);\n    }\n  }\n  if (node.onMenuNodeInputs) {\n    var retEntries = node.onMenuNodeInputs(entries);\n    if (retEntries) entries = retEntries;\n  }\n  if (!entries.length) {\n    console.log(\"no input entries\");\n    return;\n  }\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(entries, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: prev_menu,\n    node: node\n  }, ref_window);\n  function inner_clicked(v, e, prev) {\n    if (!node) {\n      return;\n    }\n    if (v.callback) {\n      v.callback.call(that, node, v, e, prev);\n    }\n    if (v.value) {\n      node.graph.beforeChange();\n      node.addInput(v.value[0], v.value[1], v.value[2]);\n      if (node.onNodeInputAdd) {\n        // callback to the node when adding a slot\n        node.onNodeInputAdd(v.value);\n      }\n      node.setDirtyCanvas(true, true);\n      node.graph.afterChange();\n    }\n  }\n  return false;\n};\nLGraphCanvas.showMenuNodeOptionalOutputs = function (v, options, e, prev_menu, node) {\n  if (!node) {\n    return;\n  }\n  var that = this;\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var options = node.optional_outputs;\n  if (node.onGetOutputs) {\n    options = node.onGetOutputs();\n  }\n  var entries = [];\n  if (options) {\n    for (var i = 0; i < options.length; i++) {\n      var entry = options[i];\n      if (!entry) {\n        //separator?\n        entries.push(null);\n        continue;\n      }\n      if (node.flags && node.flags.skip_repeated_outputs && node.findOutputSlot(entry[0]) != -1) {\n        continue;\n      } //skip the ones already on\n      var label = entry[0];\n      if (!entry[2]) entry[2] = {};\n      if (entry[2].label) {\n        label = entry[2].label;\n      }\n      entry[2].removable = true;\n      var data = {\n        content: label,\n        value: entry\n      };\n      if (entry[1] == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT) {\n        data.className = \"event\";\n      }\n      entries.push(data);\n    }\n  }\n  if (this.onMenuNodeOutputs) {\n    entries = this.onMenuNodeOutputs(entries);\n  }\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.do_add_triggers_slots) {\n    //canvas.allow_addOutSlot_onExecuted\n    if (node.findOutputSlot(\"onExecuted\") == -1) {\n      entries.push({\n        content: \"On Executed\",\n        value: [\"onExecuted\", _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT, {\n          nameLocked: true\n        }],\n        className: \"event\"\n      }); //, opts: {}\n    }\n  }\n  // add callback for modifing the menu elements onMenuNodeOutputs\n  if (node.onMenuNodeOutputs) {\n    var retEntries = node.onMenuNodeOutputs(entries);\n    if (retEntries) entries = retEntries;\n  }\n  if (!entries.length) {\n    return;\n  }\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(entries, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: prev_menu,\n    node: node\n  }, ref_window);\n  function inner_clicked(v, e, prev) {\n    if (!node) {\n      return;\n    }\n    if (v.callback) {\n      v.callback.call(that, node, v, e, prev);\n    }\n    if (!v.value) {\n      return;\n    }\n    var value = v.value[1];\n    if (value && (value.constructor === Object || value.constructor === Array)) {\n      //submenu why?\n      var entries = [];\n      for (var i in value) {\n        entries.push({\n          content: i,\n          value: value[i]\n        });\n      }\n      new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(entries, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        node: node\n      });\n      return false;\n    } else {\n      node.graph.beforeChange();\n      node.addOutput(v.value[0], v.value[1], v.value[2]);\n      if (node.onNodeOutputAdd) {\n        // a callback to the node when adding a slot\n        node.onNodeOutputAdd(v.value);\n      }\n      node.setDirtyCanvas(true, true);\n      node.graph.afterChange();\n    }\n  }\n  return false;\n};\nLGraphCanvas.onShowMenuNodeProperties = function (value, options, e, prev_menu, node) {\n  if (!node || !node.properties) {\n    return;\n  }\n  var that = this;\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var entries = [];\n  for (var i in node.properties) {\n    var value = node.properties[i] !== undefined ? node.properties[i] : \" \";\n    if (typeof value == \"object\") value = JSON.stringify(value);\n    var info = node.getPropertyInfo(i);\n    if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n    //value could contain invalid html characters, clean that\n    value = LGraphCanvas.decodeHTML(value);\n    entries.push({\n      content: \"<span class='property_name'>\" + (info.label ? info.label : i) + \"</span>\" + \"<span class='property_value'>\" + value + \"</span>\",\n      value: i\n    });\n  }\n  if (!entries.length) {\n    return;\n  }\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(entries, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: prev_menu,\n    allow_html: true,\n    node: node\n  }, ref_window);\n  function inner_clicked(v, options, e, prev) {\n    if (!node) {\n      return;\n    }\n    var rect = this.getBoundingClientRect();\n    canvas.showEditPropertyValue(node, v.value, {\n      position: [rect.left, rect.top]\n    });\n  }\n  return false;\n};\nLGraphCanvas.decodeHTML = function (str) {\n  var e = document.createElement(\"div\");\n  e.innerText = str;\n  return e.innerHTML;\n};\nLGraphCanvas.onMenuResizeNode = function (value, options, e, menu, node) {\n  if (!node) {\n    return;\n  }\n  var fApplyMultiNode = function (node) {\n    node.size = node.computeSize();\n    if (node.onResize) node.onResize(node.size);\n  };\n  var graphcanvas = LGraphCanvas.active_canvas;\n  if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n    fApplyMultiNode(node);\n  } else {\n    for (var i in graphcanvas.selected_nodes) {\n      fApplyMultiNode(graphcanvas.selected_nodes[i]);\n    }\n  }\n  node.setDirtyCanvas(true, true);\n};\nLGraphCanvas.prototype.showLinkMenu = function (link, e) {\n  var that = this;\n  // console.log(link);\n  var node_left = that.graph.getNodeById(link.origin_id);\n  var node_right = that.graph.getNodeById(link.target_id);\n  var fromType = false;\n  if (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;\n  var destType = false;\n  if (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;\n  var options = [\"Add Node\", null, \"Delete\", null];\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(options, {\n    event: e,\n    title: link.data != null ? link.data.constructor.name : null,\n    callback: inner_clicked\n  });\n  function inner_clicked(v, options, e) {\n    switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n          // console.debug(\"node autoconnect\");\n          if (!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length) {\n            return;\n          }\n          // leave the connection type checking inside connectByType\n          if (node_left.connectByType(link.origin_slot, node, fromType)) {\n            node.connectByType(link.target_slot, node_right, destType);\n            node.pos[0] -= node.size[0] * 0.5;\n          }\n        });\n        break;\n      case \"Delete\":\n        that.graph.removeLink(link.id);\n        break;\n      default:\n      /*var nodeCreated = createDefaultNodeForSlot({   nodeFrom: node_left\n                                                      ,slotFrom: link.origin_slot\n                                                      ,nodeTo: node\n                                                      ,slotTo: link.target_slot\n                                                      ,e: e\n                                                      ,nodeType: \"AUTO\"\n                                                  });\n      if(nodeCreated) console.log(\"new node in beetween \"+v+\" created\");*/\n    }\n  }\n  return false;\n};\nLGraphCanvas.prototype.createDefaultNodeForSlot = function (optPass) {\n  // addNodeMenu for connection\n  var optPass = optPass || {};\n  var opts = Object.assign({\n    nodeFrom: null // input\n    ,\n    slotFrom: null // input\n    ,\n    nodeTo: null // output\n    ,\n    slotTo: null // output\n    ,\n    position: [] // pass the event coords\n    ,\n    nodeType: null // choose a nodetype to add, AUTO to set at first good\n    ,\n    posAdd: [0, 0] // adjust x,y\n    ,\n    posSizeFix: [0, 0] // alpha, adjust the position x,y based on the new node size w,h\n  }, optPass);\n  var that = this;\n  var isFrom = opts.nodeFrom && opts.slotFrom !== null;\n  var isTo = !isFrom && opts.nodeTo && opts.slotTo !== null;\n  if (!isFrom && !isTo) {\n    console.warn(\"No data passed to createDefaultNodeForSlot \" + opts.nodeFrom + \" \" + opts.slotFrom + \" \" + opts.nodeTo + \" \" + opts.slotTo);\n    return false;\n  }\n  if (!opts.nodeType) {\n    console.warn(\"No type to createDefaultNodeForSlot\");\n    return false;\n  }\n  var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n  var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n  var iSlotConn = false;\n  switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n      break;\n    case \"object\":\n      // ok slotX\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n      break;\n    case \"number\":\n      iSlotConn = slotX;\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n      break;\n    case \"undefined\":\n    default:\n      // bad ?\n      //iSlotConn = 0;\n      console.warn(\"Cant get slot information \" + slotX);\n      return false;\n  }\n  if (slotX === false || iSlotConn === false) {\n    console.warn(\"createDefaultNodeForSlot bad slotX \" + slotX + \" \" + iSlotConn);\n  }\n\n  // check for defaults nodes for this slottype\n  var fromSlotType = slotX.type == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT ? \"_event_\" : slotX.type;\n  var slotTypesDefault = isFrom ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_default_out : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_default_in;\n  if (slotTypesDefault && slotTypesDefault[fromSlotType]) {\n    if (slotX.link !== null) {\n      // is connected\n    } else {\n      // is not not connected\n    }\n    nodeNewType = false;\n    if (typeof slotTypesDefault[fromSlotType] == \"object\" || typeof slotTypesDefault[fromSlotType] == \"array\") {\n      for (var typeX in slotTypesDefault[fromSlotType]) {\n        if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == \"AUTO\") {\n          nodeNewType = slotTypesDefault[fromSlotType][typeX];\n          // console.log(\"opts.nodeType == slotTypesDefault[fromSlotType][typeX] :: \"+opts.nodeType);\n          break; // --------\n        }\n      }\n    } else {\n      if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == \"AUTO\") nodeNewType = slotTypesDefault[fromSlotType];\n    }\n    if (nodeNewType) {\n      var nodeNewOpts = false;\n      if (typeof nodeNewType == \"object\" && nodeNewType.node) {\n        nodeNewOpts = nodeNewType;\n        nodeNewType = nodeNewType.node;\n      }\n\n      //that.graph.beforeChange();\n\n      var newNode = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(nodeNewType);\n      if (newNode) {\n        // if is object pass options\n        if (nodeNewOpts) {\n          if (nodeNewOpts.properties) {\n            for (var i in nodeNewOpts.properties) {\n              newNode.addProperty(i, nodeNewOpts.properties[i]);\n            }\n          }\n          if (nodeNewOpts.inputs) {\n            newNode.inputs = [];\n            for (var i in nodeNewOpts.inputs) {\n              newNode.addOutput(nodeNewOpts.inputs[i][0], nodeNewOpts.inputs[i][1]);\n            }\n          }\n          if (nodeNewOpts.outputs) {\n            newNode.outputs = [];\n            for (var i in nodeNewOpts.outputs) {\n              newNode.addOutput(nodeNewOpts.outputs[i][0], nodeNewOpts.outputs[i][1]);\n            }\n          }\n          if (nodeNewOpts.title) {\n            newNode.title = nodeNewOpts.title;\n          }\n          if (nodeNewOpts.json) {\n            newNode.configure(nodeNewOpts.json);\n          }\n        }\n\n        // add the node\n        that.graph.add(newNode);\n        newNode.pos = [opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0), opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0)]; //that.last_click_position; //[e.canvasX+30, e.canvasX+5];*/\n\n        //that.graph.afterChange();\n\n        // connect the two!\n        if (isFrom) {\n          opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType);\n        } else {\n          opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType);\n        }\n\n        // if connecting in between\n        if (isFrom && isTo) {\n          // TODO\n        }\n        return true;\n      } else {\n        console.log(\"failed creating \" + nodeNewType);\n      }\n    }\n  }\n  return false;\n};\nLGraphCanvas.prototype.showConnectionMenu = function (optPass) {\n  // addNodeMenu for connection\n  var optPass = optPass || {};\n  var opts = Object.assign({\n    nodeFrom: null // input\n    ,\n    slotFrom: null // input\n    ,\n    nodeTo: null // output\n    ,\n    slotTo: null // output\n    ,\n    e: null\n  }, optPass);\n  var that = this;\n  var isFrom = opts.nodeFrom && opts.slotFrom;\n  var isTo = !isFrom && opts.nodeTo && opts.slotTo;\n  if (!isFrom && !isTo) {\n    console.warn(\"No data passed to showConnectionMenu\");\n    return false;\n  }\n  var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n  var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n  var iSlotConn = false;\n  switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n      break;\n    case \"object\":\n      // ok slotX\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n      break;\n    case \"number\":\n      iSlotConn = slotX;\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n      break;\n    default:\n      // bad ?\n      //iSlotConn = 0;\n      console.warn(\"Cant get slot information \" + slotX);\n      return false;\n  }\n  var options = [\"Add Node\", null];\n  if (that.allow_searchbox) {\n    options.push(\"Search\");\n    options.push(null);\n  }\n\n  // get defaults nodes for this slottype\n  var fromSlotType = slotX.type == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT ? \"_event_\" : slotX.type;\n  var slotTypesDefault = isFrom ? _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_default_out : _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_default_in;\n  if (slotTypesDefault && slotTypesDefault[fromSlotType]) {\n    if (typeof slotTypesDefault[fromSlotType] == \"object\" || typeof slotTypesDefault[fromSlotType] == \"array\") {\n      for (var typeX in slotTypesDefault[fromSlotType]) {\n        options.push(slotTypesDefault[fromSlotType][typeX]);\n      }\n    } else {\n      options.push(slotTypesDefault[fromSlotType]);\n    }\n  }\n\n  // build menu\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(options, {\n    event: opts.e,\n    title: (slotX && slotX.name != \"\" ? slotX.name + (fromSlotType ? \" | \" : \"\") : \"\") + (slotX && fromSlotType ? fromSlotType : \"\"),\n    callback: inner_clicked\n  });\n\n  // callback\n  function inner_clicked(v, options, e) {\n    //console.log(\"Process showConnectionMenu selection\");\n    switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n          if (isFrom) {\n            opts.nodeFrom.connectByType(iSlotConn, node, fromSlotType);\n          } else {\n            opts.nodeTo.connectByTypeOutput(iSlotConn, node, fromSlotType);\n          }\n        });\n        break;\n      case \"Search\":\n        if (isFrom) {\n          that.showSearchBox(e, {\n            node_from: opts.nodeFrom,\n            slot_from: slotX,\n            type_filter_in: fromSlotType\n          });\n        } else {\n          that.showSearchBox(e, {\n            node_to: opts.nodeTo,\n            slot_from: slotX,\n            type_filter_out: fromSlotType\n          });\n        }\n        break;\n      default:\n        // check for defaults nodes for this slottype\n        var nodeCreated = that.createDefaultNodeForSlot(Object.assign(opts, {\n          position: [opts.e.canvasX, opts.e.canvasY],\n          nodeType: v\n        }));\n        if (nodeCreated) {\n          // new node created\n          //console.log(\"node \"+v+\" created\")\n        } else {\n          // failed or v is not in defaults\n        }\n        break;\n    }\n  }\n  return false;\n};\n\n// TODO refactor :: this is used fot title but not for properties!\nLGraphCanvas.onShowPropertyEditor = function (item, options, e, menu, node) {\n  var input_html = \"\";\n  var property = item.property || \"title\";\n  var value = node[property];\n\n  // TODO refactor :: use createDialog ?\n\n  var dialog = document.createElement(\"div\");\n  dialog.is_modified = false;\n  dialog.className = \"graphdialog\";\n  dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n  dialog.close = function () {\n    if (dialog.parentNode) {\n      dialog.parentNode.removeChild(dialog);\n    }\n  };\n  var title = dialog.querySelector(\".name\");\n  title.innerText = property;\n  var input = dialog.querySelector(\".value\");\n  if (input) {\n    input.value = value;\n    input.addEventListener(\"blur\", function (e) {\n      this.focus();\n    });\n    input.addEventListener(\"keydown\", function (e) {\n      dialog.is_modified = true;\n      if (e.keyCode == 27) {\n        //ESC\n        dialog.close();\n      } else if (e.keyCode == 13) {\n        inner(); // save\n      } else if (e.keyCode != 13 && e.target.localName != \"textarea\") {\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n    });\n  }\n  var graphcanvas = LGraphCanvas.active_canvas;\n  var canvas = graphcanvas.canvas;\n  var rect = canvas.getBoundingClientRect();\n  var offsetx = -20;\n  var offsety = -20;\n  if (rect) {\n    offsetx -= rect.left;\n    offsety -= rect.top;\n  }\n  if (event) {\n    dialog.style.left = event.clientX + offsetx + \"px\";\n    dialog.style.top = event.clientY + offsety + \"px\";\n  } else {\n    dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n    dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n  }\n  var button = dialog.querySelector(\"button\");\n  button.addEventListener(\"click\", inner);\n  canvas.parentNode.appendChild(dialog);\n  if (input) input.focus();\n  var dialogCloseTimer = null;\n  dialog.addEventListener(\"mouseleave\", function (e) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (!dialog.is_modified && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) dialogCloseTimer = setTimeout(dialog.close, _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n  });\n  dialog.addEventListener(\"mouseenter\", function (e) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (dialogCloseTimer) clearTimeout(dialogCloseTimer);\n  });\n  function inner() {\n    if (input) setValue(input.value);\n  }\n  function setValue(value) {\n    if (item.type == \"Number\") {\n      value = Number(value);\n    } else if (item.type == \"Boolean\") {\n      value = Boolean(value);\n    }\n    node[property] = value;\n    if (dialog.parentNode) {\n      dialog.parentNode.removeChild(dialog);\n    }\n    node.setDirtyCanvas(true, true);\n  }\n};\n\n// refactor: there are different dialogs, some uses createDialog some dont\nLGraphCanvas.prototype.prompt = function (title, value, callback, event, multiline) {\n  var that = this;\n  var input_html = \"\";\n  title = title || \"\";\n  var dialog = document.createElement(\"div\");\n  dialog.is_modified = false;\n  dialog.className = \"graphdialog rounded\";\n  if (multiline) dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";else dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n  dialog.close = function () {\n    that.prompt_box = null;\n    if (dialog.parentNode) {\n      dialog.parentNode.removeChild(dialog);\n    }\n  };\n  var graphcanvas = LGraphCanvas.active_canvas;\n  var canvas = graphcanvas.canvas;\n  canvas.parentNode.appendChild(dialog);\n  if (this.ds.scale > 1) {\n    dialog.style.transform = \"scale(\" + this.ds.scale + \")\";\n  }\n  var dialogCloseTimer = null;\n  var prevent_timeout = false;\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(dialog, \"leave\", function (e) {\n    if (prevent_timeout) return;\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (!dialog.is_modified && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) dialogCloseTimer = setTimeout(dialog.close, _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n  });\n  (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(dialog, \"enter\", function (e) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (dialogCloseTimer) clearTimeout(dialogCloseTimer);\n  });\n  var selInDia = dialog.querySelectorAll(\"select\");\n  if (selInDia) {\n    // if filtering, check focus changed to comboboxes and prevent closing\n    selInDia.forEach(function (selIn) {\n      selIn.addEventListener(\"click\", function (e) {\n        prevent_timeout++;\n      });\n      selIn.addEventListener(\"blur\", function (e) {\n        prevent_timeout = 0;\n      });\n      selIn.addEventListener(\"change\", function (e) {\n        prevent_timeout = -1;\n      });\n    });\n  }\n  if (that.prompt_box) {\n    that.prompt_box.close();\n  }\n  that.prompt_box = dialog;\n  var first = null;\n  var timeout = null;\n  var selected = null;\n  var name_element = dialog.querySelector(\".name\");\n  name_element.innerText = title;\n  var value_element = dialog.querySelector(\".value\");\n  value_element.value = value;\n  var input = value_element;\n  input.addEventListener(\"keydown\", function (e) {\n    dialog.is_modified = true;\n    if (e.keyCode == 27) {\n      //ESC\n      dialog.close();\n    } else if (e.keyCode == 13 && e.target.localName != \"textarea\") {\n      if (callback) {\n        callback(this.value);\n      }\n      dialog.close();\n    } else {\n      return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n  });\n  var button = dialog.querySelector(\"button\");\n  button.addEventListener(\"click\", function (e) {\n    if (callback) {\n      callback(input.value);\n    }\n    that.setDirty(true);\n    dialog.close();\n  });\n  var rect = canvas.getBoundingClientRect();\n  var offsetx = -20;\n  var offsety = -20;\n  if (rect) {\n    offsetx -= rect.left;\n    offsety -= rect.top;\n  }\n  if (event) {\n    dialog.style.left = event.clientX + offsetx + \"px\";\n    dialog.style.top = event.clientY + offsety + \"px\";\n  } else {\n    dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n    dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n  }\n  setTimeout(function () {\n    input.focus();\n  }, 10);\n  return dialog;\n};\nLGraphCanvas.search_limit = -1;\nLGraphCanvas.prototype.showSearchBox = function (event, options) {\n  // proposed defaults\n  var def_options = {\n    slot_from: null,\n    node_from: null,\n    node_to: null,\n    do_type_filter: _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.search_filter_enabled // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out\n    ,\n    type_filter_in: false // these are default: pass to set initially set values\n    ,\n    type_filter_out: false,\n    show_general_if_none_on_typefilter: true,\n    show_general_after_typefiltered: true,\n    hide_on_mouse_leave: _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.search_hide_on_mouse_leave,\n    show_all_if_empty: true,\n    show_all_on_open: _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.search_show_all_on_open\n  };\n  options = Object.assign(def_options, options || {});\n\n  //console.log(options);\n\n  var that = this;\n  var input_html = \"\";\n  var graphcanvas = LGraphCanvas.active_canvas;\n  var canvas = graphcanvas.canvas;\n  var root_document = canvas.ownerDocument || document;\n  var dialog = document.createElement(\"div\");\n  dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n  dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>\";\n  if (options.do_type_filter) {\n    dialog.innerHTML += \"<select class='slot_in_type_filter'><option value=''></option></select>\";\n    dialog.innerHTML += \"<select class='slot_out_type_filter'><option value=''></option></select>\";\n  }\n  dialog.innerHTML += \"<div class='helper'></div>\";\n  if (root_document.fullscreenElement) root_document.fullscreenElement.appendChild(dialog);else {\n    root_document.body.appendChild(dialog);\n    root_document.body.style.overflow = \"hidden\";\n  }\n  // dialog element has been appended\n\n  if (options.do_type_filter) {\n    var selIn = dialog.querySelector(\".slot_in_type_filter\");\n    var selOut = dialog.querySelector(\".slot_out_type_filter\");\n  }\n  dialog.close = function () {\n    that.search_box = null;\n    this.blur();\n    canvas.focus();\n    root_document.body.style.overflow = \"\";\n    setTimeout(function () {\n      that.canvas.focus();\n    }, 20); //important, if canvas loses focus keys wont be captured\n    if (dialog.parentNode) {\n      dialog.parentNode.removeChild(dialog);\n    }\n  };\n  if (this.ds.scale > 1) {\n    dialog.style.transform = \"scale(\" + this.ds.scale + \")\";\n  }\n\n  // hide on mouse leave\n  if (options.hide_on_mouse_leave) {\n    var prevent_timeout = false;\n    var timeout_close = null;\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(dialog, \"enter\", function (e) {\n      if (timeout_close) {\n        clearTimeout(timeout_close);\n        timeout_close = null;\n      }\n    });\n    (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.pointerListenerAdd)(dialog, \"leave\", function (e) {\n      if (prevent_timeout) {\n        return;\n      }\n      timeout_close = setTimeout(function () {\n        dialog.close();\n      }, 500);\n    });\n    // if filtering, check focus changed to comboboxes and prevent closing\n    if (options.do_type_filter) {\n      selIn.addEventListener(\"click\", function (e) {\n        prevent_timeout++;\n      });\n      selIn.addEventListener(\"blur\", function (e) {\n        prevent_timeout = 0;\n      });\n      selIn.addEventListener(\"change\", function (e) {\n        prevent_timeout = -1;\n      });\n      selOut.addEventListener(\"click\", function (e) {\n        prevent_timeout++;\n      });\n      selOut.addEventListener(\"blur\", function (e) {\n        prevent_timeout = 0;\n      });\n      selOut.addEventListener(\"change\", function (e) {\n        prevent_timeout = -1;\n      });\n    }\n  }\n  if (that.search_box) {\n    that.search_box.close();\n  }\n  that.search_box = dialog;\n  var helper = dialog.querySelector(\".helper\");\n  var first = null;\n  var timeout = null;\n  var selected = null;\n  var input = dialog.querySelector(\"input\");\n  if (input) {\n    input.addEventListener(\"blur\", function (e) {\n      if (that.search_box) this.focus();\n    });\n    input.addEventListener(\"keydown\", function (e) {\n      if (e.keyCode == 38) {\n        //UP\n        changeSelection(false);\n      } else if (e.keyCode == 40) {\n        //DOWN\n        changeSelection(true);\n      } else if (e.keyCode == 27) {\n        //ESC\n        dialog.close();\n      } else if (e.keyCode == 13) {\n        refreshHelper();\n        if (selected) {\n          select(selected.innerHTML);\n        } else if (first) {\n          select(first);\n        } else {\n          dialog.close();\n        }\n      } else {\n        if (timeout) {\n          clearInterval(timeout);\n        }\n        timeout = setTimeout(refreshHelper, 250);\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n      return true;\n    });\n  }\n\n  // if should filter on type, load and fill selected and choose elements if passed\n  if (options.do_type_filter) {\n    if (selIn) {\n      var aSlots = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_in;\n      var nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length;\n\n      if (options.type_filter_in == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || options.type_filter_in == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ACTION) options.type_filter_in = \"_event_\";\n      /* this will filter on * .. but better do it manually in case\n      else if(options.type_filter_in === \"\" || options.type_filter_in === 0)\n          options.type_filter_in = \"*\";*/\n\n      for (var iK = 0; iK < nSlots; iK++) {\n        var opt = document.createElement('option');\n        opt.value = aSlots[iK];\n        opt.innerHTML = aSlots[iK];\n        selIn.appendChild(opt);\n        if (options.type_filter_in !== false && (options.type_filter_in + \"\").toLowerCase() == (aSlots[iK] + \"\").toLowerCase()) {\n          //selIn.selectedIndex ..\n          opt.selected = true;\n          //console.log(\"comparing IN \"+options.type_filter_in+\" :: \"+aSlots[iK]);\n        } else {\n          //console.log(\"comparing OUT \"+options.type_filter_in+\" :: \"+aSlots[iK]);\n        }\n      }\n      selIn.addEventListener(\"change\", function () {\n        refreshHelper();\n      });\n    }\n    if (selOut) {\n      var aSlots = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.slot_types_out;\n      var nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length; \n\n      if (options.type_filter_out == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || options.type_filter_out == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ACTION) options.type_filter_out = \"_event_\";\n      /* this will filter on * .. but better do it manually in case\n      else if(options.type_filter_out === \"\" || options.type_filter_out === 0)\n          options.type_filter_out = \"*\";*/\n\n      for (var iK = 0; iK < nSlots; iK++) {\n        var opt = document.createElement('option');\n        opt.value = aSlots[iK];\n        opt.innerHTML = aSlots[iK];\n        selOut.appendChild(opt);\n        if (options.type_filter_out !== false && (options.type_filter_out + \"\").toLowerCase() == (aSlots[iK] + \"\").toLowerCase()) {\n          //selOut.selectedIndex ..\n          opt.selected = true;\n        }\n      }\n      selOut.addEventListener(\"change\", function () {\n        refreshHelper();\n      });\n    }\n  }\n\n  //compute best position\n  var rect = canvas.getBoundingClientRect();\n  var left = (event ? event.clientX : rect.left + rect.width * 0.5) - 80;\n  var top = (event ? event.clientY : rect.top + rect.height * 0.5) - 20;\n  dialog.style.left = left + \"px\";\n  dialog.style.top = top + \"px\";\n\n  //To avoid out of screen problems\n  if (event.layerY > rect.height - 200) helper.style.maxHeight = rect.height - event.layerY - 20 + \"px\";\n\n  /*\n  var offsetx = -20;\n  var offsety = -20;\n  if (rect) {\n      offsetx -= rect.left;\n      offsety -= rect.top;\n  }\n   if (event) {\n      dialog.style.left = event.clientX + offsetx + \"px\";\n      dialog.style.top = event.clientY + offsety + \"px\";\n  } else {\n      dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n      dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n  }\n  canvas.parentNode.appendChild(dialog);\n  */\n\n  input.focus();\n  if (options.show_all_on_open) refreshHelper();\n  function select(name) {\n    if (name) {\n      if (that.onSearchBoxSelection) {\n        that.onSearchBoxSelection(name, event, graphcanvas);\n      } else {\n        var extra = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.searchbox_extras[name.toLowerCase()];\n        if (extra) {\n          name = extra.type;\n        }\n        graphcanvas.graph.beforeChange();\n        var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(name);\n        if (node) {\n          node.pos = graphcanvas.convertEventToCanvasOffset(event);\n          graphcanvas.graph.add(node, false);\n        }\n        if (extra && extra.data) {\n          if (extra.data.properties) {\n            for (var i in extra.data.properties) {\n              node.addProperty(i, extra.data.properties[i]);\n            }\n          }\n          if (extra.data.inputs) {\n            node.inputs = [];\n            for (var i in extra.data.inputs) {\n              node.addOutput(extra.data.inputs[i][0], extra.data.inputs[i][1]);\n            }\n          }\n          if (extra.data.outputs) {\n            node.outputs = [];\n            for (var i in extra.data.outputs) {\n              node.addOutput(extra.data.outputs[i][0], extra.data.outputs[i][1]);\n            }\n          }\n          if (extra.data.title) {\n            node.title = extra.data.title;\n          }\n          if (extra.data.json) {\n            node.configure(extra.data.json);\n          }\n        }\n\n        // join node after inserting\n        if (options.node_from) {\n          var iS = false;\n          switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_from.findOutputSlot(options.slot_from);\n              break;\n            case \"object\":\n              if (options.slot_from.name) {\n                iS = options.node_from.findOutputSlot(options.slot_from.name);\n              } else {\n                iS = -1;\n              }\n              if (iS == -1 && typeof options.slot_from.slot_index !== \"undefined\") iS = options.slot_from.slot_index;\n              break;\n            case \"number\":\n              iS = options.slot_from;\n              break;\n            default:\n              iS = 0;\n            // try with first if no name set\n          }\n          if (typeof options.node_from.outputs[iS] !== \"undefined\") {\n            if (iS !== false && iS > -1) {\n              options.node_from.connectByType(iS, node, options.node_from.outputs[iS].type);\n            }\n          } else {\n            // console.warn(\"cant find slot \" + options.slot_from);\n          }\n        }\n        if (options.node_to) {\n          var iS = false;\n          switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_to.findInputSlot(options.slot_from);\n              break;\n            case \"object\":\n              if (options.slot_from.name) {\n                iS = options.node_to.findInputSlot(options.slot_from.name);\n              } else {\n                iS = -1;\n              }\n              if (iS == -1 && typeof options.slot_from.slot_index !== \"undefined\") iS = options.slot_from.slot_index;\n              break;\n            case \"number\":\n              iS = options.slot_from;\n              break;\n            default:\n              iS = 0;\n            // try with first if no name set\n          }\n          if (typeof options.node_to.inputs[iS] !== \"undefined\") {\n            if (iS !== false && iS > -1) {\n              // try connection\n              options.node_to.connectByTypeOutput(iS, node, options.node_to.inputs[iS].type);\n            }\n          } else {\n            // console.warn(\"cant find slot_nodeTO \" + options.slot_from);\n          }\n        }\n        graphcanvas.graph.afterChange();\n      }\n    }\n    dialog.close();\n  }\n  function changeSelection(forward) {\n    var prev = selected;\n    if (selected) {\n      selected.classList.remove(\"selected\");\n    }\n    if (!selected) {\n      selected = forward ? helper.childNodes[0] : helper.childNodes[helper.childNodes.length];\n    } else {\n      selected = forward ? selected.nextSibling : selected.previousSibling;\n      if (!selected) {\n        selected = prev;\n      }\n    }\n    if (!selected) {\n      return;\n    }\n    selected.classList.add(\"selected\");\n    selected.scrollIntoView({\n      block: \"end\",\n      behavior: \"smooth\"\n    });\n  }\n  function refreshHelper() {\n    timeout = null;\n    var str = input.value;\n    first = null;\n    helper.innerHTML = \"\";\n    if (!str && !options.show_all_if_empty) {\n      return;\n    }\n    if (that.onSearchBox) {\n      var list = that.onSearchBox(helper, str, graphcanvas);\n      if (list) {\n        for (var i = 0; i < list.length; ++i) {\n          addResult(list[i]);\n        }\n      }\n    } else {\n      var c = 0;\n      str = str.toLowerCase();\n      var filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n      // filter by type preprocess\n      if (options.do_type_filter && that.search_box) {\n        var sIn = that.search_box.querySelector(\".slot_in_type_filter\");\n        var sOut = that.search_box.querySelector(\".slot_out_type_filter\");\n      } else {\n        var sIn = false;\n        var sOut = false;\n      }\n\n      //extras\n      for (var i in _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.searchbox_extras) {\n        var extra = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.searchbox_extras[i];\n        if ((!options.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1) {\n          continue;\n        }\n        var ctor = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types[extra.type];\n        if (ctor && ctor.filter != filter) continue;\n        if (!inner_test_filter(extra.type)) continue;\n        addResult(extra.desc, \"searchbox_extra\");\n        if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n          break;\n        }\n      }\n      var filtered = null;\n      if (Array.prototype.filter) {\n        //filter supported\n        var keys = Object.keys(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types); //types\n        var filtered = keys.filter(inner_test_filter);\n      } else {\n        filtered = [];\n        for (var i in _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types) {\n          if (inner_test_filter(i)) filtered.push(i);\n        }\n      }\n      for (var i = 0; i < filtered.length; i++) {\n        addResult(filtered[i]);\n        if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n          break;\n        }\n      }\n\n      // add general type if filtering\n      if (options.show_general_after_typefiltered && (sIn.value || sOut.value)) {\n        filtered_extra = [];\n        for (var i in _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types) {\n          if (inner_test_filter(i, {\n            inTypeOverride: sIn && sIn.value ? \"*\" : false,\n            outTypeOverride: sOut && sOut.value ? \"*\" : false\n          })) filtered_extra.push(i);\n        }\n        for (var i = 0; i < filtered_extra.length; i++) {\n          addResult(filtered_extra[i], \"generic_type\");\n          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n            break;\n          }\n        }\n      }\n\n      // check il filtering gave no results\n      if ((sIn.value || sOut.value) && helper.childNodes.length == 0 && options.show_general_if_none_on_typefilter) {\n        filtered_extra = [];\n        for (var i in _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types) {\n          if (inner_test_filter(i, {\n            skipFilter: true\n          })) filtered_extra.push(i);\n        }\n        for (var i = 0; i < filtered_extra.length; i++) {\n          addResult(filtered_extra[i], \"not_in_filter\");\n          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n            break;\n          }\n        }\n      }\n      function inner_test_filter(type, optsIn) {\n        var optsIn = optsIn || {};\n        var optsDef = {\n          skipFilter: false,\n          inTypeOverride: false,\n          outTypeOverride: false\n        };\n        var opts = Object.assign(optsDef, optsIn);\n        var ctor = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_node_types[type];\n        if (filter && ctor.filter != filter) return false;\n        if ((!options.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1) return false;\n\n        // filter by slot IN, OUT types\n        if (options.do_type_filter && !opts.skipFilter) {\n          var sType = type;\n          var sV = sIn.value;\n          if (opts.inTypeOverride !== false) sV = opts.inTypeOverride;\n          //if (sV.toLowerCase() == \"_event_\") sV = LiteGraph.EVENT; // -1\n\n          if (sIn && sV) {\n            //console.log(\"will check filter against \"+sV);\n            if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_in_types[sV] && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_in_types[sV].nodes) {\n              // type is stored\n              //console.debug(\"check \"+sType+\" in \"+LiteGraph.registered_slot_in_types[sV].nodes);\n              var doesInc = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);\n              if (doesInc !== false) {\n                //console.log(sType+\" HAS \"+sV);\n              } else {\n                /*console.debug(LiteGraph.registered_slot_in_types[sV]);\n                console.log(+\" DONT includes \"+type);*/\n                return false;\n              }\n            }\n          }\n          var sV = sOut.value;\n          if (opts.outTypeOverride !== false) sV = opts.outTypeOverride;\n          //if (sV.toLowerCase() == \"_event_\") sV = LiteGraph.EVENT; // -1\n\n          if (sOut && sV) {\n            //console.log(\"search will check filter against \"+sV);\n            if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_out_types[sV] && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_out_types[sV].nodes) {\n              // type is stored\n              //console.debug(\"check \"+sType+\" in \"+LiteGraph.registered_slot_out_types[sV].nodes);\n              var doesInc = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);\n              if (doesInc !== false) {\n                //console.log(sType+\" HAS \"+sV);\n              } else {\n                /*console.debug(LiteGraph.registered_slot_out_types[sV]);\n                console.log(+\" DONT includes \"+type);*/\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      }\n    }\n    function addResult(type, className) {\n      var help = document.createElement(\"div\");\n      if (!first) {\n        first = type;\n      }\n      help.innerText = type;\n      help.dataset[\"type\"] = escape(type);\n      help.className = \"litegraph lite-search-item\";\n      if (className) {\n        help.className += \" \" + className;\n      }\n      help.addEventListener(\"click\", function (e) {\n        select(unescape(this.dataset[\"type\"]));\n      });\n      helper.appendChild(help);\n    }\n  }\n  return dialog;\n};\nLGraphCanvas.prototype.showEditPropertyValue = function (node, property, options) {\n  if (!node || node.properties[property] === undefined) {\n    return;\n  }\n  options = options || {};\n  var that = this;\n  var info = node.getPropertyInfo(property);\n  var type = info.type;\n  var input_html = \"\";\n  if (type == \"string\" || type == \"number\" || type == \"array\" || type == \"object\") {\n    input_html = \"<input autofocus type='text' class='value'/>\";\n  } else if ((type == \"enum\" || type == \"combo\") && info.values) {\n    input_html = \"<select autofocus type='text' class='value'>\";\n    for (var i in info.values) {\n      var v = i;\n      if (info.values.constructor === Array) v = info.values[i];\n      input_html += \"<option value='\" + v + \"' \" + (v == node.properties[property] ? \"selected\" : \"\") + \">\" + info.values[i] + \"</option>\";\n    }\n    input_html += \"</select>\";\n  } else if (type == \"boolean\" || type == \"toggle\") {\n    input_html = \"<input autofocus type='checkbox' class='value' \" + (node.properties[property] ? \"checked\" : \"\") + \"/>\";\n  } else {\n    console.warn(\"unknown type: \" + type);\n    return;\n  }\n  var dialog = this.createDialog(\"<span class='name'>\" + (info.label ? info.label : property) + \"</span>\" + input_html + \"<button>OK</button>\", options);\n  var input = false;\n  if ((type == \"enum\" || type == \"combo\") && info.values) {\n    input = dialog.querySelector(\"select\");\n    input.addEventListener(\"change\", function (e) {\n      dialog.modified();\n      setValue(e.target.value);\n      //var index = e.target.value;\n      //setValue( e.options[e.selectedIndex].value );\n    });\n  } else if (type == \"boolean\" || type == \"toggle\") {\n    input = dialog.querySelector(\"input\");\n    if (input) {\n      input.addEventListener(\"click\", function (e) {\n        dialog.modified();\n        setValue(!!input.checked);\n      });\n    }\n  } else {\n    input = dialog.querySelector(\"input\");\n    if (input) {\n      input.addEventListener(\"blur\", function (e) {\n        this.focus();\n      });\n      var v = node.properties[property] !== undefined ? node.properties[property] : \"\";\n      if (type !== 'string') {\n        v = JSON.stringify(v);\n      }\n      input.value = v;\n      input.addEventListener(\"keydown\", function (e) {\n        if (e.keyCode == 27) {\n          //ESC\n          dialog.close();\n        } else if (e.keyCode == 13) {\n          // ENTER\n          inner(); // save\n        } else if (e.keyCode != 13) {\n          dialog.modified();\n          return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      });\n    }\n  }\n  if (input) input.focus();\n  var button = dialog.querySelector(\"button\");\n  button.addEventListener(\"click\", inner);\n  function inner() {\n    setValue(input.value);\n  }\n  function setValue(value) {\n    if (info && info.values && info.values.constructor === Object && info.values[value] != undefined) value = info.values[value];\n    if (typeof node.properties[property] == \"number\") {\n      value = Number(value);\n    }\n    if (type == \"array\" || type == \"object\") {\n      value = JSON.parse(value);\n    }\n    node.properties[property] = value;\n    if (node.graph) {\n      node.graph._version++;\n    }\n    if (node.onPropertyChanged) {\n      node.onPropertyChanged(property, value);\n    }\n    if (options.onclose) options.onclose();\n    dialog.close();\n    node.setDirtyCanvas(true, true);\n  }\n  return dialog;\n};\n\n// TODO refactor, theer are different dialog, some uses createDialog, some dont\nLGraphCanvas.prototype.createDialog = function (html, options) {\n  var def_options = {\n    checkForInput: false,\n    closeOnLeave: true,\n    closeOnLeave_checkModified: true\n  };\n  options = Object.assign(def_options, options || {});\n  var dialog = document.createElement(\"div\");\n  dialog.className = \"graphdialog\";\n  dialog.innerHTML = html;\n  dialog.is_modified = false;\n  var rect = this.canvas.getBoundingClientRect();\n  var offsetx = -20;\n  var offsety = -20;\n  if (rect) {\n    offsetx -= rect.left;\n    offsety -= rect.top;\n  }\n  if (options.position) {\n    offsetx += options.position[0];\n    offsety += options.position[1];\n  } else if (options.event) {\n    offsetx += options.event.clientX;\n    offsety += options.event.clientY;\n  } //centered\n  else {\n    offsetx += this.canvas.width * 0.5;\n    offsety += this.canvas.height * 0.5;\n  }\n  dialog.style.left = offsetx + \"px\";\n  dialog.style.top = offsety + \"px\";\n  this.canvas.parentNode.appendChild(dialog);\n\n  // acheck for input and use default behaviour: save on enter, close on esc\n  if (options.checkForInput) {\n    var aI = [];\n    var focused = false;\n    if (aI = dialog.querySelectorAll(\"input\")) {\n      aI.forEach(function (iX) {\n        iX.addEventListener(\"keydown\", function (e) {\n          dialog.modified();\n          if (e.keyCode == 27) {\n            dialog.close();\n          } else if (e.keyCode != 13) {\n            return;\n          }\n          // set value ?\n          e.preventDefault();\n          e.stopPropagation();\n        });\n        if (!focused) iX.focus();\n      });\n    }\n  }\n  dialog.modified = function () {\n    dialog.is_modified = true;\n  };\n  dialog.close = function () {\n    if (dialog.parentNode) {\n      dialog.parentNode.removeChild(dialog);\n    }\n  };\n  var dialogCloseTimer = null;\n  var prevent_timeout = false;\n  dialog.addEventListener(\"mouseleave\", function (e) {\n    if (prevent_timeout) return;\n    if (options.closeOnLeave || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (!dialog.is_modified && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) dialogCloseTimer = setTimeout(dialog.close, _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n  });\n  dialog.addEventListener(\"mouseenter\", function (e) {\n    if (options.closeOnLeave || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.dialog_close_on_mouse_leave) if (dialogCloseTimer) clearTimeout(dialogCloseTimer);\n  });\n  var selInDia = dialog.querySelectorAll(\"select\");\n  if (selInDia) {\n    // if filtering, check focus changed to comboboxes and prevent closing\n    selInDia.forEach(function (selIn) {\n      selIn.addEventListener(\"click\", function (e) {\n        prevent_timeout++;\n      });\n      selIn.addEventListener(\"blur\", function (e) {\n        prevent_timeout = 0;\n      });\n      selIn.addEventListener(\"change\", function (e) {\n        prevent_timeout = -1;\n      });\n    });\n  }\n  return dialog;\n};\nLGraphCanvas.prototype.createPanel = function (title, options) {\n  options = options || {};\n  var ref_window = options.window || window;\n  var root = document.createElement(\"div\");\n  root.className = \"litegraph dialog\";\n  root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>\";\n  root.header = root.querySelector(\".dialog-header\");\n  if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n  if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n  if (options.closable) {\n    var close = document.createElement(\"span\");\n    close.innerHTML = \"&#10005;\";\n    close.classList.add(\"close\");\n    close.addEventListener(\"click\", function () {\n      root.close();\n    });\n    root.header.appendChild(close);\n  }\n  root.title_element = root.querySelector(\".dialog-title\");\n  root.title_element.innerText = title;\n  root.content = root.querySelector(\".dialog-content\");\n  root.alt_content = root.querySelector(\".dialog-alt-content\");\n  root.footer = root.querySelector(\".dialog-footer\");\n  root.close = function () {\n    if (root.onClose && typeof root.onClose == \"function\") {\n      root.onClose();\n    }\n    if (root.parentNode) root.parentNode.removeChild(root);\n    /* XXX CHECK THIS */\n    if (this.parentNode) {\n      this.parentNode.removeChild(this);\n    }\n    /* XXX this was not working, was fixed with an IF, check this */\n  };\n\n  // function to swap panel content\n  root.toggleAltContent = function (force) {\n    if (typeof force != \"undefined\") {\n      var vTo = force ? \"block\" : \"none\";\n      var vAlt = force ? \"none\" : \"block\";\n    } else {\n      var vTo = root.alt_content.style.display != \"block\" ? \"block\" : \"none\";\n      var vAlt = root.alt_content.style.display != \"block\" ? \"none\" : \"block\";\n    }\n    root.alt_content.style.display = vTo;\n    root.content.style.display = vAlt;\n  };\n  root.toggleFooterVisibility = function (force) {\n    if (typeof force != \"undefined\") {\n      var vTo = force ? \"block\" : \"none\";\n    } else {\n      var vTo = root.footer.style.display != \"block\" ? \"block\" : \"none\";\n    }\n    root.footer.style.display = vTo;\n  };\n  root.clear = function () {\n    this.content.innerHTML = \"\";\n  };\n  root.addHTML = function (code, classname, on_footer) {\n    var elem = document.createElement(\"div\");\n    if (classname) elem.className = classname;\n    elem.innerHTML = code;\n    if (on_footer) root.footer.appendChild(elem);else root.content.appendChild(elem);\n    return elem;\n  };\n  root.addButton = function (name, callback, options) {\n    var elem = document.createElement(\"button\");\n    elem.innerText = name;\n    elem.options = options;\n    elem.classList.add(\"btn\");\n    elem.addEventListener(\"click\", callback);\n    root.footer.appendChild(elem);\n    return elem;\n  };\n  root.addSeparator = function () {\n    var elem = document.createElement(\"div\");\n    elem.className = \"separator\";\n    root.content.appendChild(elem);\n  };\n  root.addWidget = function (type, name, value, options, callback) {\n    options = options || {};\n    var str_value = String(value);\n    type = type.toLowerCase();\n    if (type == \"number\") str_value = value.toFixed(3);\n    var elem = document.createElement(\"div\");\n    elem.className = \"property\";\n    elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n    elem.querySelector(\".property_name\").innerText = options.label || name;\n    var value_element = elem.querySelector(\".property_value\");\n    value_element.innerText = str_value;\n    elem.dataset[\"property\"] = name;\n    elem.dataset[\"type\"] = options.type || type;\n    elem.options = options;\n    elem.value = value;\n    if (type == \"code\") elem.addEventListener(\"click\", function (e) {\n      root.inner_showCodePad(this.dataset[\"property\"]);\n    });else if (type == \"boolean\") {\n      elem.classList.add(\"boolean\");\n      if (value) elem.classList.add(\"bool-on\");\n      elem.addEventListener(\"click\", function () {\n        //var v = node.properties[this.dataset[\"property\"]]; \n        //node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" : \"false\"; \n        var propname = this.dataset[\"property\"];\n        this.value = !this.value;\n        this.classList.toggle(\"bool-on\");\n        this.querySelector(\".property_value\").innerText = this.value ? \"true\" : \"false\";\n        innerChange(propname, this.value);\n      });\n    } else if (type == \"string\" || type == \"number\") {\n      value_element.setAttribute(\"contenteditable\", true);\n      value_element.addEventListener(\"keydown\", function (e) {\n        if (e.code == \"Enter\" && (type != \"string\" || !e.shiftKey))\n          // allow for multiline\n          {\n            e.preventDefault();\n            this.blur();\n          }\n      });\n      value_element.addEventListener(\"blur\", function () {\n        var v = this.innerText;\n        var propname = this.parentNode.dataset[\"property\"];\n        var proptype = this.parentNode.dataset[\"type\"];\n        if (proptype == \"number\") v = Number(v);\n        innerChange(propname, v);\n      });\n    } else if (type == \"enum\" || type == \"combo\") {\n      var str_value = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n      value_element.innerText = str_value;\n      value_element.addEventListener(\"click\", function (event) {\n        var values = options.values || [];\n        var propname = this.parentNode.dataset[\"property\"];\n        var elem_that = this;\n        var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(values, {\n          event: event,\n          className: \"dark\",\n          callback: inner_clicked\n        }, ref_window);\n        function inner_clicked(v, option, event) {\n          //node.setProperty(propname,v); \n          //graphcanvas.dirty_canvas = true;\n          elem_that.innerText = v;\n          innerChange(propname, v);\n          return false;\n        }\n      });\n    }\n    root.content.appendChild(elem);\n    function innerChange(name, value) {\n      //console.log(\"change\",name,value);\n      //that.dirty_canvas = true;\n      if (options.callback) options.callback(name, value, options);\n      if (callback) callback(name, value, options);\n    }\n    return elem;\n  };\n  if (root.onOpen && typeof root.onOpen == \"function\") root.onOpen();\n  return root;\n};\nLGraphCanvas.getPropertyPrintableValue = function (value, values) {\n  if (!values) return String(value);\n  if (values.constructor === Array) {\n    return String(value);\n  }\n  if (values.constructor === Object) {\n    var desc_value = \"\";\n    for (var k in values) {\n      if (values[k] != value) continue;\n      desc_value = k;\n      break;\n    }\n    return String(value) + \" (\" + desc_value + \")\";\n  }\n};\nLGraphCanvas.prototype.closePanels = function () {\n  var panel = document.querySelector(\"#node-panel\");\n  if (panel) panel.close();\n  var panel = document.querySelector(\"#option-panel\");\n  if (panel) panel.close();\n};\nLGraphCanvas.prototype.showShowGraphOptionsPanel = function (refOpts, obEv, refMenu, refMenu2) {\n  if (this.constructor && this.constructor.name == \"HTMLDivElement\") {\n    // assume coming from the menu event click\n    if (!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas) {\n      console.warn(\"Canvas not found\"); // need a ref to canvas obj\n      /*console.debug(event);\n      console.debug(event.target);*/\n      return;\n    }\n    var graphcanvas = obEv.event.target.lgraphcanvas;\n  } else {\n    // assume called internally\n    var graphcanvas = this;\n  }\n  graphcanvas.closePanels();\n  var ref_window = graphcanvas.getCanvasWindow();\n  panel = graphcanvas.createPanel(\"Options\", {\n    closable: true,\n    window: ref_window,\n    onOpen: function () {\n      graphcanvas.OPTIONPANEL_IS_OPEN = true;\n    },\n    onClose: function () {\n      graphcanvas.OPTIONPANEL_IS_OPEN = false;\n      graphcanvas.options_panel = null;\n    }\n  });\n  graphcanvas.options_panel = panel;\n  panel.id = \"option-panel\";\n  panel.classList.add(\"settings\");\n  function inner_refresh() {\n    panel.content.innerHTML = \"\"; //clear\n\n    var fUpdate = function (name, value, options) {\n      switch (name) {\n        /*case \"Render mode\":\n            // Case \"\".. \n            if (options.values && options.key){\n                var kV = Object.values(options.values).indexOf(value);\n                if (kV>=0 && options.values[kV]){\n                    console.debug(\"update graph options: \"+options.key+\": \"+kV);\n                    graphcanvas[options.key] = kV;\n                    //console.debug(graphcanvas);\n                    break;\n                }\n            }\n            console.warn(\"unexpected options\");\n            console.debug(options);\n            break;*/\n        default:\n          //console.debug(\"want to update graph options: \"+name+\": \"+value);\n          if (options && options.key) {\n            name = options.key;\n          }\n          if (options.values) {\n            value = Object.values(options.values).indexOf(value);\n          }\n          //console.debug(\"update graph option: \"+name+\": \"+value);\n          graphcanvas[name] = value;\n          break;\n      }\n    };\n\n    // panel.addWidget( \"string\", \"Graph name\", \"\", {}, fUpdate); // implement\n\n    var aProps = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.availableCanvasOptions;\n    aProps.sort();\n    for (var pI in aProps) {\n      var pX = aProps[pI];\n      panel.addWidget(\"boolean\", pX, graphcanvas[pX], {\n        key: pX,\n        on: \"True\",\n        off: \"False\"\n      }, fUpdate);\n    }\n    var aLinks = [graphcanvas.links_render_mode];\n    panel.addWidget(\"combo\", \"Render mode\", _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], {\n      key: \"links_render_mode\",\n      values: _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LINK_RENDER_MODES\n    }, fUpdate);\n    panel.addSeparator();\n    panel.footer.innerHTML = \"\"; // clear\n  }\n  inner_refresh();\n  graphcanvas.canvas.parentNode.appendChild(panel);\n};\nLGraphCanvas.prototype.showShowNodePanel = function (node) {\n  this.SELECTED_NODE = node;\n  this.closePanels();\n  var ref_window = this.getCanvasWindow();\n  var that = this;\n  var graphcanvas = this;\n  var panel = this.createPanel(node.title || \"\", {\n    closable: true,\n    window: ref_window,\n    onOpen: function () {\n      graphcanvas.NODEPANEL_IS_OPEN = true;\n    },\n    onClose: function () {\n      graphcanvas.NODEPANEL_IS_OPEN = false;\n      graphcanvas.node_panel = null;\n    }\n  });\n  graphcanvas.node_panel = panel;\n  panel.id = \"node-panel\";\n  panel.node = node;\n  panel.classList.add(\"settings\");\n  function inner_refresh() {\n    panel.content.innerHTML = \"\"; //clear\n    panel.addHTML(\"<span class='node_type'>\" + node.type + \"</span><span class='node_desc'>\" + (node.constructor.desc || \"\") + \"</span><span class='separator'></span>\");\n    panel.addHTML(\"<h3>Properties</h3>\");\n    var fUpdate = function (name, value) {\n      graphcanvas.graph.beforeChange(node);\n      switch (name) {\n        case \"Title\":\n          node.title = value;\n          break;\n        case \"Mode\":\n          var kV = Object.values(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES).indexOf(value);\n          if (kV >= 0 && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES[kV]) {\n            node.changeMode(kV);\n          } else {\n            console.warn(\"unexpected mode: \" + value);\n          }\n          break;\n        case \"Color\":\n          if (_node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[value]) {\n            node.color = _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[value].color;\n            node.bgcolor = _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[value].bgcolor;\n          } else {\n            console.warn(\"unexpected color: \" + value);\n          }\n          break;\n        default:\n          node.setProperty(name, value);\n          break;\n      }\n      graphcanvas.graph.afterChange();\n      graphcanvas.dirty_canvas = true;\n    };\n    panel.addWidget(\"string\", \"Title\", node.title, {}, fUpdate);\n    panel.addWidget(\"combo\", \"Mode\", _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES[node.mode], {\n      values: _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES\n    }, fUpdate);\n    var nodeCol = \"\";\n    if (node.color !== undefined) {\n      nodeCol = Object.keys(_node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors).filter(function (nK) {\n        return _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[nK].color == node.color;\n      });\n    }\n    panel.addWidget(\"combo\", \"Color\", nodeCol, {\n      values: Object.keys(_node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors)\n    }, fUpdate);\n    for (var pName in node.properties) {\n      var value = node.properties[pName];\n      var info = node.getPropertyInfo(pName);\n      var type = info.type || \"string\";\n\n      //in case the user wants control over the side panel widget\n      if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(pName, panel)) continue;\n      panel.addWidget(info.widget || info.type, pName, value, info, fUpdate);\n    }\n    panel.addSeparator();\n    if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n    panel.footer.innerHTML = \"\"; // clear\n    panel.addButton(\"Delete\", function () {\n      if (node.block_delete) return;\n      node.graph.remove(node);\n      panel.close();\n    }).classList.add(\"delete\");\n  }\n  panel.inner_showCodePad = function (propname) {\n    panel.classList.remove(\"settings\");\n    panel.classList.add(\"centered\");\n\n    /*if(window.CodeFlask) //disabled for now\n    {\n        panel.content.innerHTML = \"<div class='code'></div>\";\n        var flask = new CodeFlask( \"div.code\", { language: 'js' });\n        flask.updateCode(node.properties[propname]);\n        flask.onUpdate( function(code) {\n            node.setProperty(propname, code);\n        });\n    }\n    else\n    {*/\n    panel.alt_content.innerHTML = \"<textarea class='code'></textarea>\";\n    var textarea = panel.alt_content.querySelector(\"textarea\");\n    var fDoneWith = function () {\n      panel.toggleAltContent(false); //if(node_prop_div) node_prop_div.style.display = \"block\"; // panel.close();\n      panel.toggleFooterVisibility(true);\n      textarea.parentNode.removeChild(textarea);\n      panel.classList.add(\"settings\");\n      panel.classList.remove(\"centered\");\n      inner_refresh();\n    };\n    textarea.value = node.properties[propname];\n    textarea.addEventListener(\"keydown\", function (e) {\n      if (e.code == \"Enter\" && e.ctrlKey) {\n        node.setProperty(propname, textarea.value);\n        fDoneWith();\n      }\n    });\n    panel.toggleAltContent(true);\n    panel.toggleFooterVisibility(false);\n    textarea.style.height = \"calc(100% - 40px)\";\n    /*}*/\n    var assign = panel.addButton(\"Assign\", function () {\n      node.setProperty(propname, textarea.value);\n      fDoneWith();\n    });\n    panel.alt_content.appendChild(assign); //panel.content.appendChild(assign);\n    var button = panel.addButton(\"Close\", fDoneWith);\n    button.style.float = \"right\";\n    panel.alt_content.appendChild(button); // panel.content.appendChild(button);\n  };\n  inner_refresh();\n  this.canvas.parentNode.appendChild(panel);\n};\nLGraphCanvas.prototype.showSubgraphPropertiesDialog = function (node) {\n  console.log(\"showing subgraph properties dialog\");\n  var old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n  if (old_panel) old_panel.close();\n  var panel = this.createPanel(\"Subgraph Inputs\", {\n    closable: true,\n    width: 500\n  });\n  panel.node = node;\n  panel.classList.add(\"subgraph_dialog\");\n  function inner_refresh() {\n    panel.clear();\n\n    //show currents\n    if (node.inputs) for (var i = 0; i < node.inputs.length; ++i) {\n      var input = node.inputs[i];\n      if (input.not_subgraph_input) continue;\n      var html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n      var elem = panel.addHTML(html, \"subgraph_property\");\n      elem.dataset[\"name\"] = input.name;\n      elem.dataset[\"slot\"] = i;\n      elem.querySelector(\".name\").innerText = input.name;\n      elem.querySelector(\".type\").innerText = input.type;\n      elem.querySelector(\"button\").addEventListener(\"click\", function (e) {\n        node.removeInput(Number(this.parentNode.dataset[\"slot\"]));\n        inner_refresh();\n      });\n    }\n  }\n\n  //add extra\n  var html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>\";\n  var elem = panel.addHTML(html, \"subgraph_property extra\", true);\n  elem.querySelector(\"button\").addEventListener(\"click\", function (e) {\n    var elem = this.parentNode;\n    var name = elem.querySelector(\".name\").value;\n    var type = elem.querySelector(\".type\").value;\n    if (!name || node.findInputSlot(name) != -1) return;\n    node.addInput(name, type);\n    elem.querySelector(\".name\").value = \"\";\n    elem.querySelector(\".type\").value = \"\";\n    inner_refresh();\n  });\n  inner_refresh();\n  this.canvas.parentNode.appendChild(panel);\n  return panel;\n};\nLGraphCanvas.prototype.showSubgraphPropertiesDialogRight = function (node) {\n  // console.log(\"showing subgraph properties dialog\");\n  var that = this;\n  // old_panel if old_panel is exist close it\n  var old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n  if (old_panel) old_panel.close();\n  // new panel\n  var panel = this.createPanel(\"Subgraph Outputs\", {\n    closable: true,\n    width: 500\n  });\n  panel.node = node;\n  panel.classList.add(\"subgraph_dialog\");\n  function inner_refresh() {\n    panel.clear();\n    //show currents\n    if (node.outputs) for (var i = 0; i < node.outputs.length; ++i) {\n      var input = node.outputs[i];\n      if (input.not_subgraph_output) continue;\n      var html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n      var elem = panel.addHTML(html, \"subgraph_property\");\n      elem.dataset[\"name\"] = input.name;\n      elem.dataset[\"slot\"] = i;\n      elem.querySelector(\".name\").innerText = input.name;\n      elem.querySelector(\".type\").innerText = input.type;\n      elem.querySelector(\"button\").addEventListener(\"click\", function (e) {\n        node.removeOutput(Number(this.parentNode.dataset[\"slot\"]));\n        inner_refresh();\n      });\n    }\n  }\n\n  //add extra\n  var html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>\";\n  var elem = panel.addHTML(html, \"subgraph_property extra\", true);\n  elem.querySelector(\".name\").addEventListener(\"keydown\", function (e) {\n    if (e.keyCode == 13) {\n      addOutput.apply(this);\n    }\n  });\n  elem.querySelector(\"button\").addEventListener(\"click\", function (e) {\n    addOutput.apply(this);\n  });\n  function addOutput() {\n    var elem = this.parentNode;\n    var name = elem.querySelector(\".name\").value;\n    var type = elem.querySelector(\".type\").value;\n    if (!name || node.findOutputSlot(name) != -1) return;\n    node.addOutput(name, type);\n    elem.querySelector(\".name\").value = \"\";\n    elem.querySelector(\".type\").value = \"\";\n    inner_refresh();\n  }\n  inner_refresh();\n  this.canvas.parentNode.appendChild(panel);\n  return panel;\n};\nLGraphCanvas.prototype.checkPanels = function () {\n  if (!this.canvas) return;\n  var panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n  for (var i = 0; i < panels.length; ++i) {\n    var panel = panels[i];\n    if (!panel.node) continue;\n    if (!panel.node.graph || panel.graph != this.graph) panel.close();\n  }\n};\nLGraphCanvas.onMenuNodeCollapse = function (value, options, e, menu, node) {\n  node.graph.beforeChange( /*?*/);\n  var fApplyMultiNode = function (node) {\n    node.collapse();\n  };\n  var graphcanvas = LGraphCanvas.active_canvas;\n  if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n    fApplyMultiNode(node);\n  } else {\n    for (var i in graphcanvas.selected_nodes) {\n      fApplyMultiNode(graphcanvas.selected_nodes[i]);\n    }\n  }\n  node.graph.afterChange( /*?*/);\n};\nLGraphCanvas.onMenuNodePin = function (value, options, e, menu, node) {\n  node.pin();\n};\nLGraphCanvas.onMenuNodeMode = function (value, options, e, menu, node) {\n  new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: menu,\n    node: node\n  });\n  function inner_clicked(v) {\n    if (!node) {\n      return;\n    }\n    var kV = Object.values(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES).indexOf(v);\n    var fApplyMultiNode = function (node) {\n      if (kV >= 0 && _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_MODES[kV]) node.changeMode(kV);else {\n        console.warn(\"unexpected mode: \" + v);\n        node.changeMode(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ALWAYS);\n      }\n    };\n    var graphcanvas = LGraphCanvas.active_canvas;\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node);\n    } else {\n      for (var i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i]);\n      }\n    }\n  }\n  return false;\n};\nLGraphCanvas.onMenuNodeColors = function (value, options, e, menu, node) {\n  if (!node) {\n    throw \"no node for color\";\n  }\n  var values = [];\n  values.push({\n    value: null,\n    content: \"<span style='display: block; padding-left: 4px;'>No color</span>\"\n  });\n  for (var i in _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors) {\n    var color = _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[i];\n    var value = {\n      value: i,\n      content: \"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid \" + color.color + \"; background-color:\" + color.bgcolor + \"'>\" + i + \"</span>\"\n    };\n    values.push(value);\n  }\n  new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(values, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: menu,\n    node: node\n  });\n  function inner_clicked(v) {\n    if (!node) {\n      return;\n    }\n    var color = v.value ? _node_colors_js__WEBPACK_IMPORTED_MODULE_4__.node_colors[v.value] : null;\n    var fApplyColor = function (node) {\n      if (color) {\n        if (node.constructor === _l_graph_group_js__WEBPACK_IMPORTED_MODULE_2__.LGraphGroup) {\n          node.color = color.groupcolor;\n        } else {\n          node.color = color.color;\n          node.bgcolor = color.bgcolor;\n        }\n      } else {\n        delete node.color;\n        delete node.bgcolor;\n      }\n    };\n    var graphcanvas = LGraphCanvas.active_canvas;\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyColor(node);\n    } else {\n      for (var i in graphcanvas.selected_nodes) {\n        fApplyColor(graphcanvas.selected_nodes[i]);\n      }\n    }\n    node.setDirtyCanvas(true, true);\n  }\n  return false;\n};\nLGraphCanvas.onMenuNodeShapes = function (value, options, e, menu, node) {\n  if (!node) {\n    throw \"no node passed\";\n  }\n  new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.VALID_SHAPES, {\n    event: e,\n    callback: inner_clicked,\n    parentMenu: menu,\n    node: node\n  });\n  function inner_clicked(v) {\n    if (!node) {\n      return;\n    }\n    node.graph.beforeChange( /*?*/); //node\n\n    var fApplyMultiNode = function (node) {\n      node.shape = v;\n    };\n    var graphcanvas = LGraphCanvas.active_canvas;\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node);\n    } else {\n      for (var i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i]);\n      }\n    }\n    node.graph.afterChange( /*?*/); //node\n    node.setDirtyCanvas(true);\n  }\n  return false;\n};\nLGraphCanvas.onMenuNodeRemove = function (value, options, e, menu, node) {\n  if (!node) {\n    throw \"no node passed\";\n  }\n  var graph = node.graph;\n  graph.beforeChange();\n  var fApplyMultiNode = function (node) {\n    if (node.removable === false) {\n      return;\n    }\n    graph.remove(node);\n  };\n  var graphcanvas = LGraphCanvas.active_canvas;\n  if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n    fApplyMultiNode(node);\n  } else {\n    for (var i in graphcanvas.selected_nodes) {\n      fApplyMultiNode(graphcanvas.selected_nodes[i]);\n    }\n  }\n  graph.afterChange();\n  node.setDirtyCanvas(true, true);\n};\nLGraphCanvas.onMenuNodeToSubgraph = function (value, options, e, menu, node) {\n  var graph = node.graph;\n  var graphcanvas = LGraphCanvas.active_canvas;\n  if (!graphcanvas)\n    //??\n    return;\n  var nodes_list = Object.values(graphcanvas.selected_nodes || {});\n  if (!nodes_list.length) nodes_list = [node];\n  var subgraph_node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(\"graph/subgraph\");\n  subgraph_node.pos = node.pos.concat();\n  graph.add(subgraph_node);\n  subgraph_node.buildFromNodes(nodes_list);\n  graphcanvas.deselectAllNodes();\n  node.setDirtyCanvas(true, true);\n};\nLGraphCanvas.onMenuNodeClone = function (value, options, e, menu, node) {\n  node.graph.beforeChange();\n  var newSelected = {};\n  var fApplyMultiNode = function (node) {\n    if (node.clonable === false) {\n      return;\n    }\n    var newnode = node.clone();\n    if (!newnode) {\n      return;\n    }\n    newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n    node.graph.add(newnode);\n    newSelected[newnode.id] = newnode;\n  };\n  var graphcanvas = LGraphCanvas.active_canvas;\n  if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n    fApplyMultiNode(node);\n  } else {\n    for (var i in graphcanvas.selected_nodes) {\n      fApplyMultiNode(graphcanvas.selected_nodes[i]);\n    }\n  }\n  if (Object.keys(newSelected).length) {\n    graphcanvas.selectNodes(newSelected);\n  }\n  node.graph.afterChange();\n  node.setDirtyCanvas(true, true);\n};\nLGraphCanvas.prototype.getCanvasMenuOptions = function () {\n  var options = null;\n  var that = this;\n  if (this.getMenuOptions) {\n    options = this.getMenuOptions();\n  } else {\n    options = [{\n      content: \"Add Node\",\n      has_submenu: true,\n      callback: LGraphCanvas.onMenuAdd\n    }, {\n      content: \"Add Group\",\n      callback: LGraphCanvas.onGroupAdd\n    }\n    //{ content: \"Arrange\", callback: that.graph.arrange },\n    //{content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n    ];\n    /*if (LiteGraph.showCanvasOptions){\n        options.push({ content: \"Options\", callback: that.showShowGraphOptionsPanel });\n    }*/\n\n    if (Object.keys(this.selected_nodes).length > 1) {\n      options.push({\n        content: \"Align\",\n        has_submenu: true,\n        callback: LGraphCanvas.onGroupAlign\n      });\n    }\n    if (this._graph_stack && this._graph_stack.length > 0) {\n      options.push(null, {\n        content: \"Close subgraph\",\n        callback: this.closeSubgraph.bind(this)\n      });\n    }\n  }\n  if (this.getExtraMenuOptions) {\n    var extra = this.getExtraMenuOptions(this, options);\n    if (extra) {\n      options = options.concat(extra);\n    }\n  }\n  return options;\n};\n\n//called by processContextMenu to extract the menu list\nLGraphCanvas.prototype.getNodeMenuOptions = function (node) {\n  var options = null;\n  if (node.getMenuOptions) {\n    options = node.getMenuOptions(this);\n  } else {\n    options = [{\n      content: \"Inputs\",\n      has_submenu: true,\n      disabled: true,\n      callback: LGraphCanvas.showMenuNodeOptionalInputs\n    }, {\n      content: \"Outputs\",\n      has_submenu: true,\n      disabled: true,\n      callback: LGraphCanvas.showMenuNodeOptionalOutputs\n    }, null, {\n      content: \"Properties\",\n      has_submenu: true,\n      callback: LGraphCanvas.onShowMenuNodeProperties\n    }, null, {\n      content: \"Title\",\n      callback: LGraphCanvas.onShowPropertyEditor\n    }, {\n      content: \"Mode\",\n      has_submenu: true,\n      callback: LGraphCanvas.onMenuNodeMode\n    }];\n    if (node.resizable !== false) {\n      options.push({\n        content: \"Resize\",\n        callback: LGraphCanvas.onMenuResizeNode\n      });\n    }\n    options.push({\n      content: \"Collapse\",\n      callback: LGraphCanvas.onMenuNodeCollapse\n    }, {\n      content: \"Pin\",\n      callback: LGraphCanvas.onMenuNodePin\n    }, {\n      content: \"Colors\",\n      has_submenu: true,\n      callback: LGraphCanvas.onMenuNodeColors\n    }, {\n      content: \"Shapes\",\n      has_submenu: true,\n      callback: LGraphCanvas.onMenuNodeShapes\n    }, null);\n  }\n  if (node.onGetInputs) {\n    var inputs = node.onGetInputs();\n    if (inputs && inputs.length) {\n      options[0].disabled = false;\n    }\n  }\n  if (node.onGetOutputs) {\n    var outputs = node.onGetOutputs();\n    if (outputs && outputs.length) {\n      options[1].disabled = false;\n    }\n  }\n  if (node.getExtraMenuOptions) {\n    var extra = node.getExtraMenuOptions(this, options);\n    if (extra) {\n      extra.push(null);\n      options = extra.concat(options);\n    }\n  }\n  if (node.clonable !== false) {\n    options.push({\n      content: \"Clone\",\n      callback: LGraphCanvas.onMenuNodeClone\n    });\n  }\n  if (false)\n    //TODO\n    {}\n  if (Object.keys(this.selected_nodes).length > 1) {\n    options.push({\n      content: \"Align Selected To\",\n      has_submenu: true,\n      callback: LGraphCanvas.onNodeAlign\n    });\n  }\n  options.push(null, {\n    content: \"Remove\",\n    disabled: !(node.removable !== false && !node.block_delete),\n    callback: LGraphCanvas.onMenuNodeRemove\n  });\n  if (node.graph && node.graph.onGetNodeMenuOptions) {\n    node.graph.onGetNodeMenuOptions(options, node);\n  }\n  return options;\n};\nLGraphCanvas.prototype.getGroupMenuOptions = function (node) {\n  var o = [{\n    content: \"Title\",\n    callback: LGraphCanvas.onShowPropertyEditor\n  }, {\n    content: \"Color\",\n    has_submenu: true,\n    callback: LGraphCanvas.onMenuNodeColors\n  }, {\n    content: \"Font size\",\n    property: \"font_size\",\n    type: \"Number\",\n    callback: LGraphCanvas.onShowPropertyEditor\n  }, null, {\n    content: \"Remove\",\n    callback: LGraphCanvas.onMenuNodeRemove\n  }];\n  return o;\n};\nLGraphCanvas.prototype.processContextMenu = function (node, event) {\n  var that = this;\n  var canvas = LGraphCanvas.active_canvas;\n  var ref_window = canvas.getCanvasWindow();\n  var menu_info = null;\n  var options = {\n    event: event,\n    callback: inner_option_clicked,\n    extra: node\n  };\n  if (node) options.title = node.type;\n\n  //check if mouse is in input\n  var slot = null;\n  if (node) {\n    slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n    LGraphCanvas.active_node = node;\n  }\n  if (slot) {\n    //on slot\n    menu_info = [];\n    if (node.getSlotMenuOptions) {\n      menu_info = node.getSlotMenuOptions(slot);\n    } else {\n      if (slot && slot.output && slot.output.links && slot.output.links.length) {\n        menu_info.push({\n          content: \"Disconnect Links\",\n          slot: slot\n        });\n      }\n      var _slot = slot.input || slot.output;\n      if (_slot.removable) {\n        menu_info.push(_slot.locked ? \"Cannot remove\" : {\n          content: \"Remove Slot\",\n          slot: slot\n        });\n      }\n      if (!_slot.nameLocked) {\n        menu_info.push({\n          content: \"Rename Slot\",\n          slot: slot\n        });\n      }\n    }\n    options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\";\n    if (slot.input && slot.input.type == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ACTION) {\n      options.title = \"Action\";\n    }\n    if (slot.output && slot.output.type == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT) {\n      options.title = \"Event\";\n    }\n  } else {\n    if (node) {\n      //on node\n      menu_info = this.getNodeMenuOptions(node);\n    } else {\n      menu_info = this.getCanvasMenuOptions();\n      var group = this.graph.getGroupOnPos(event.canvasX, event.canvasY);\n      if (group) {\n        //on group\n        menu_info.push(null, {\n          content: \"Edit Group\",\n          has_submenu: true,\n          submenu: {\n            title: \"Group\",\n            extra: group,\n            options: this.getGroupMenuOptions(group)\n          }\n        });\n      }\n    }\n  }\n\n  //show menu\n  if (!menu_info) {\n    return;\n  }\n  var menu = new _context_menu_js__WEBPACK_IMPORTED_MODULE_3__.ContextMenu(menu_info, options, ref_window);\n  function inner_option_clicked(v, options, e) {\n    if (!v) {\n      return;\n    }\n    if (v.content == \"Remove Slot\") {\n      var info = v.slot;\n      node.graph.beforeChange();\n      if (info.input) {\n        node.removeInput(info.slot);\n      } else if (info.output) {\n        node.removeOutput(info.slot);\n      }\n      node.graph.afterChange();\n      return;\n    } else if (v.content == \"Disconnect Links\") {\n      var info = v.slot;\n      node.graph.beforeChange();\n      if (info.output) {\n        node.disconnectOutput(info.slot);\n      } else if (info.input) {\n        node.disconnectInput(info.slot);\n      }\n      node.graph.afterChange();\n      return;\n    } else if (v.content == \"Rename Slot\") {\n      var info = v.slot;\n      var slot_info = info.input ? node.getInputInfo(info.slot) : node.getOutputInfo(info.slot);\n      var dialog = that.createDialog(\"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\", options);\n      var input = dialog.querySelector(\"input\");\n      if (input && slot_info) {\n        input.value = slot_info.label || \"\";\n      }\n      var inner = function () {\n        node.graph.beforeChange();\n        if (input.value) {\n          if (slot_info) {\n            slot_info.label = input.value;\n          }\n          that.setDirty(true);\n        }\n        dialog.close();\n        node.graph.afterChange();\n      };\n      dialog.querySelector(\"button\").addEventListener(\"click\", inner);\n      input.addEventListener(\"keydown\", function (e) {\n        dialog.is_modified = true;\n        if (e.keyCode == 27) {\n          //ESC\n          dialog.close();\n        } else if (e.keyCode == 13) {\n          inner(); // save\n        } else if (e.keyCode != 13 && e.target.localName != \"textarea\") {\n          return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      });\n      input.focus();\n    }\n\n    //if(v.callback)\n    //\treturn v.callback.call(that, node, options, e, menu, that, event );\n  }\n};\nfunction closeAllContextMenus(ref_window) {\n  ref_window = ref_window || window;\n  var elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n  if (!elements.length) {\n    return;\n  }\n  var result = [];\n  for (var i = 0; i < elements.length; i++) {\n    result.push(elements[i]);\n  }\n  for (var i = 0; i < result.length; i++) {\n    if (result[i].close) {\n      result[i].close();\n    } else if (result[i].parentNode) {\n      result[i].parentNode.removeChild(result[i]);\n    }\n  }\n}\nfunction clamp(v, a, b) {\n  return a > v ? a : b < v ? b : v;\n}\n\n//bounding overlap, format: [ startx, starty, width, height ]\nfunction overlapBounding(a, b) {\n  var A_end_x = a[0] + a[2];\n  var A_end_y = a[1] + a[3];\n  var B_end_x = b[0] + b[2];\n  var B_end_y = b[1] + b[3];\n  if (a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]) {\n    return false;\n  }\n  return true;\n}\nfunction isInsideRectangle(x, y, left, top, width, height) {\n  if (left < x && left + width > x && top < y && top + height > y) {\n    return true;\n  }\n  return false;\n}\nfunction distance(a, b) {\n  return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));\n}\nif (typeof window != \"undefined\" && !window[\"requestAnimationFrame\"]) {\n  window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/l_graph_canvas.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/l_graph_class.js":
/*!********************************************************!*\
  !*** ./members/GraphRender/litegraph/l_graph_class.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraph: () => (/* binding */ LGraph)\n/* harmony export */ });\n/* harmony import */ var _libs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs.js */ \"./members/GraphRender/litegraph/libs.js\");\n/* harmony import */ var _l_link_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./l_link.js */ \"./members/GraphRender/litegraph/l_link.js\");\n/* harmony import */ var _l_graph_node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./l_graph_node.js */ \"./members/GraphRender/litegraph/l_graph_node.js\");\n/* harmony import */ var _l_graph_group_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./l_graph_group.js */ \"./members/GraphRender/litegraph/l_graph_group.js\");\n/* harmony import */ var _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./litegraph_class.js */ \"./members/GraphRender/litegraph/litegraph_class.js\");\n/* harmony import */ var _l_graph_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./l_graph_canvas.js */ \"./members/GraphRender/litegraph/l_graph_canvas.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"./members/GraphRender/litegraph/settings.js\");\n\n\n\n\n\n\n\n\n//*********************************************************************************\n// LGraph CLASS\n//*********************************************************************************\n\n/**\n * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n    + onNodeAdded: when a new node is added to the graph\n    + onNodeRemoved: when a node inside this graph is removed\n    + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n    *\n    * @class LGraph\n    * @constructor\n    * @param {Object} o data from previous serialization [optional]\n    */\n\nfunction LGraph(o) {\n  this.list_of_graphcanvas = null;\n  this.clear();\n  if (o) {\n    this.configure(o);\n  }\n}\n\n//default supported types\nLGraph.supported_types = [\"number\", \"string\", \"boolean\"];\n\n//used to know which types of connections support this graph (some graphs do not allow certain types)\nLGraph.prototype.getSupportedTypes = function () {\n  return this.supported_types || LGraph.supported_types;\n};\nLGraph.STATUS_STOPPED = 1;\nLGraph.STATUS_RUNNING = 2;\n\n/**\n * Removes all nodes from this graph\n * @method clear\n */\n\nLGraph.prototype.clear = function () {\n  this.stop();\n  this.status = LGraph.STATUS_STOPPED;\n  this.last_node_id = 0;\n  this.last_link_id = 0;\n  this._version = -1; //used to detect changes\n\n  //safe clear\n  if (this._nodes) {\n    for (var i = 0; i < this._nodes.length; ++i) {\n      var node = this._nodes[i];\n      if (node.onRemoved) {\n        node.onRemoved();\n      }\n    }\n  }\n\n  //nodes\n  this._nodes = [];\n  this._nodes_by_id = {};\n  this._nodes_in_order = []; //nodes sorted in execution order\n  this._nodes_executable = null; //nodes that contain onExecute sorted in execution order\n\n  //other scene stuff\n  this._groups = [];\n\n  //links\n  this.links = {}; //container with all the links\n\n  //iterations\n  this.iteration = 0;\n\n  //custom data\n  this.config = {};\n  this.vars = {};\n  this.extra = {}; //to store custom data\n\n  //timing\n  this.globaltime = 0;\n  this.runningtime = 0;\n  this.fixedtime = 0;\n  this.fixedtime_lapse = 0.01;\n  this.elapsed_time = 0.01;\n  this.last_update_time = 0;\n  this.starttime = 0;\n  this.catch_errors = true;\n  this.nodes_executing = [];\n  this.nodes_actioning = [];\n  this.nodes_executedAction = [];\n\n  //subgraph_data\n  this.inputs = {};\n  this.outputs = {};\n\n  //notify canvas to redraw\n  this.change();\n  this.sendActionToCanvas(\"clear\");\n};\n\n/**\n * Attach Canvas to this graph\n * @method attachCanvas\n * @param {GraphCanvas} graph_canvas\n */\n\nLGraph.prototype.attachCanvas = function (graphcanvas) {\n  if (graphcanvas.constructor != _l_graph_canvas_js__WEBPACK_IMPORTED_MODULE_5__.LGraphCanvas) {\n    throw \"attachCanvas expects a LGraphCanvas instance\";\n  }\n  if (graphcanvas.graph && graphcanvas.graph != this) {\n    graphcanvas.graph.detachCanvas(graphcanvas);\n  }\n  graphcanvas.graph = this;\n  if (!this.list_of_graphcanvas) {\n    this.list_of_graphcanvas = [];\n  }\n  this.list_of_graphcanvas.push(graphcanvas);\n};\n\n/**\n * Detach Canvas from this graph\n * @method detachCanvas\n * @param {GraphCanvas} graph_canvas\n */\nLGraph.prototype.detachCanvas = function (graphcanvas) {\n  if (!this.list_of_graphcanvas) {\n    return;\n  }\n  var pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n  if (pos == -1) {\n    return;\n  }\n  graphcanvas.graph = null;\n  this.list_of_graphcanvas.splice(pos, 1);\n};\n\n/**\n * Starts running this graph every interval milliseconds.\n * @method start\n * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate\n */\n\nLGraph.prototype.start = function (interval) {\n  if (this.status == LGraph.STATUS_RUNNING) {\n    return;\n  }\n  this.status = LGraph.STATUS_RUNNING;\n  if (this.onPlayEvent) {\n    this.onPlayEvent();\n  }\n  this.sendEventToAllNodes(\"onStart\");\n\n  //launch\n  this.starttime = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  this.last_update_time = this.starttime;\n  interval = interval || 0;\n  var that = this;\n\n  //execute once per frame\n  if (interval == 0 && typeof window != \"undefined\" && window.requestAnimationFrame) {\n    function on_frame() {\n      if (that.execution_timer_id != -1) {\n        return;\n      }\n      window.requestAnimationFrame(on_frame);\n      if (that.onBeforeStep) that.onBeforeStep();\n      that.runStep(1, !that.catch_errors);\n      if (that.onAfterStep) that.onAfterStep();\n    }\n    this.execution_timer_id = -1;\n    on_frame();\n  } else {\n    //execute every 'interval' ms\n    this.execution_timer_id = setInterval(function () {\n      //execute\n      if (that.onBeforeStep) that.onBeforeStep();\n      that.runStep(1, !that.catch_errors);\n      if (that.onAfterStep) that.onAfterStep();\n    }, interval);\n  }\n};\n\n/**\n * Stops the execution loop of the graph\n * @method stop execution\n */\n\nLGraph.prototype.stop = function () {\n  if (this.status == LGraph.STATUS_STOPPED) {\n    return;\n  }\n  this.status = LGraph.STATUS_STOPPED;\n  if (this.onStopEvent) {\n    this.onStopEvent();\n  }\n  if (this.execution_timer_id != null) {\n    if (this.execution_timer_id != -1) {\n      clearInterval(this.execution_timer_id);\n    }\n    this.execution_timer_id = null;\n  }\n  this.sendEventToAllNodes(\"onStop\");\n};\n\n/**\n * Run N steps (cycles) of the graph\n * @method runStep\n * @param {number} num number of steps to run, default is 1\n * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors \n * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n */\n\nLGraph.prototype.runStep = function (num, do_not_catch_errors, limit) {\n  num = num || 1;\n  var start = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  this.globaltime = 0.001 * (start - this.starttime);\n\n  //not optimal: executes possible pending actions in node, problem is it is not optimized\n  //it is done here as if it was done in the later loop it wont be called in the node missed the onExecute\n\n  //from now on it will iterate only on executable nodes which is faster\n  var nodes = this._nodes_executable ? this._nodes_executable : this._nodes;\n  if (!nodes) {\n    return;\n  }\n  limit = limit || nodes.length;\n  if (do_not_catch_errors) {\n    //iterations\n    for (var i = 0; i < num; i++) {\n      for (var j = 0; j < limit; ++j) {\n        var node = nodes[j];\n        if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.use_deferred_actions && node._waiting_actions && node._waiting_actions.length) node.executePendingActions();\n        if (node.mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.ALWAYS && node.onExecute) {\n          //wrap node.onExecute();\n          node.doExecute();\n        }\n      }\n      this.fixedtime += this.fixedtime_lapse;\n      if (this.onExecuteStep) {\n        this.onExecuteStep();\n      }\n    }\n    if (this.onAfterExecute) {\n      this.onAfterExecute();\n    }\n  } else {\n    //catch errors\n    try {\n      //iterations\n      for (var i = 0; i < num; i++) {\n        for (var j = 0; j < limit; ++j) {\n          var node = nodes[j];\n          if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.use_deferred_actions && node._waiting_actions && node._waiting_actions.length) node.executePendingActions();\n          if (node.mode == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.ALWAYS && node.onExecute) {\n            node.onExecute();\n          }\n        }\n        this.fixedtime += this.fixedtime_lapse;\n        if (this.onExecuteStep) {\n          this.onExecuteStep();\n        }\n      }\n      if (this.onAfterExecute) {\n        this.onAfterExecute();\n      }\n      this.errors_in_execution = false;\n    } catch (err) {\n      this.errors_in_execution = true;\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.throw_errors) {\n        throw err;\n      }\n      if (_settings_js__WEBPACK_IMPORTED_MODULE_6__.debug) {\n        console.log(\"Error during execution: \" + err);\n      }\n      this.stop();\n    }\n  }\n  var now = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  var elapsed = now - start;\n  if (elapsed == 0) {\n    elapsed = 1;\n  }\n  this.execution_time = 0.001 * elapsed;\n  this.globaltime += 0.001 * elapsed;\n  this.iteration += 1;\n  this.elapsed_time = (now - this.last_update_time) * 0.001;\n  this.last_update_time = now;\n  this.nodes_executing = [];\n  this.nodes_actioning = [];\n  this.nodes_executedAction = [];\n};\n\n/**\n * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than\n * nodes with only inputs.\n * @method updateExecutionOrder\n */\nLGraph.prototype.updateExecutionOrder = function () {\n  this._nodes_in_order = this.computeExecutionOrder(false);\n  this._nodes_executable = [];\n  for (var i = 0; i < this._nodes_in_order.length; ++i) {\n    if (this._nodes_in_order[i].onExecute) {\n      this._nodes_executable.push(this._nodes_in_order[i]);\n    }\n  }\n};\n\n//This is more internal, it computes the executable nodes in order and returns it\nLGraph.prototype.computeExecutionOrder = function (only_onExecute, set_level) {\n  var L = [];\n  var S = [];\n  var M = {};\n  var visited_links = {}; //to avoid repeating links\n  var remaining_links = {}; //to a\n\n  //search for the nodes without inputs (starting nodes)\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    var node = this._nodes[i];\n    if (only_onExecute && !node.onExecute) {\n      continue;\n    }\n    M[node.id] = node; //add to pending nodes\n\n    var num = 0; //num of input connections\n    if (node.inputs) {\n      for (var j = 0, l2 = node.inputs.length; j < l2; j++) {\n        if (node.inputs[j] && node.inputs[j].link != null) {\n          num += 1;\n        }\n      }\n    }\n    if (num == 0) {\n      //is a starting node\n      S.push(node);\n      if (set_level) {\n        node._level = 1;\n      }\n    } //num of input links\n    else {\n      if (set_level) {\n        node._level = 0;\n      }\n      remaining_links[node.id] = num;\n    }\n  }\n  while (true) {\n    if (S.length == 0) {\n      break;\n    }\n\n    //get an starting node\n    var node = S.shift();\n    L.push(node); //add to ordered list\n    delete M[node.id]; //remove from the pending nodes\n\n    if (!node.outputs) {\n      continue;\n    }\n\n    //for every output\n    for (var i = 0; i < node.outputs.length; i++) {\n      var output = node.outputs[i];\n      //not connected\n      if (output == null || output.links == null || output.links.length == 0) {\n        continue;\n      }\n\n      //for every connection\n      for (var j = 0; j < output.links.length; j++) {\n        var link_id = output.links[j];\n        var link = this.links[link_id];\n        if (!link) {\n          continue;\n        }\n\n        //already visited link (ignore it)\n        if (visited_links[link.id]) {\n          continue;\n        }\n        var target_node = this.getNodeById(link.target_id);\n        if (target_node == null) {\n          visited_links[link.id] = true;\n          continue;\n        }\n        if (set_level && (!target_node._level || target_node._level <= node._level)) {\n          target_node._level = node._level + 1;\n        }\n        visited_links[link.id] = true; //mark as visited\n        remaining_links[target_node.id] -= 1; //reduce the number of links remaining\n        if (remaining_links[target_node.id] == 0) {\n          S.push(target_node);\n        } //if no more links, then add to starters array\n      }\n    }\n  }\n\n  //the remaining ones (loops)\n  for (var i in M) {\n    L.push(M[i]);\n  }\n  if (L.length != this._nodes.length && _settings_js__WEBPACK_IMPORTED_MODULE_6__.debug) {\n    console.warn(\"something went wrong, nodes missing\");\n  }\n  var l = L.length;\n\n  //save order number in the node\n  for (var i = 0; i < l; ++i) {\n    L[i].order = i;\n  }\n\n  //sort now by priority\n  L = L.sort(function (A, B) {\n    var Ap = A.constructor.priority || A.priority || 0;\n    var Bp = B.constructor.priority || B.priority || 0;\n    if (Ap == Bp) {\n      //if same priority, sort by order\n      return A.order - B.order;\n    }\n    return Ap - Bp; //sort by priority\n  });\n\n  //save order number in the node, again...\n  for (var i = 0; i < l; ++i) {\n    L[i].order = i;\n  }\n  return L;\n};\n\n/**\n * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.\n * It doesn't include the node itself\n * @method getAncestors\n * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution\n */\nLGraph.prototype.getAncestors = function (node) {\n  var ancestors = [];\n  var pending = [node];\n  var visited = {};\n  while (pending.length) {\n    var current = pending.shift();\n    if (!current.inputs) {\n      continue;\n    }\n    if (!visited[current.id] && current != node) {\n      visited[current.id] = true;\n      ancestors.push(current);\n    }\n    for (var i = 0; i < current.inputs.length; ++i) {\n      var input = current.getInputNode(i);\n      if (input && ancestors.indexOf(input) == -1) {\n        pending.push(input);\n      }\n    }\n  }\n  ancestors.sort(function (a, b) {\n    return a.order - b.order;\n  });\n  return ancestors;\n};\n\n/**\n * Positions every node in a more readable manner\n * @method arrange\n */\nLGraph.prototype.arrange = function (margin, layout) {\n  margin = margin || 100;\n  const nodes = this.computeExecutionOrder(false, true);\n  const columns = [];\n  for (let i = 0; i < nodes.length; ++i) {\n    const node = nodes[i];\n    const col = node._level || 1;\n    if (!columns[col]) {\n      columns[col] = [];\n    }\n    columns[col].push(node);\n  }\n  let x = margin;\n  for (let i = 0; i < columns.length; ++i) {\n    const column = columns[i];\n    if (!column) {\n      continue;\n    }\n    let max_size = 100;\n    let y = margin + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n    for (let j = 0; j < column.length; ++j) {\n      const node = column[j];\n      node.pos[0] = layout == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.VERTICAL_LAYOUT ? y : x;\n      node.pos[1] = layout == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.VERTICAL_LAYOUT ? x : y;\n      const max_size_index = layout == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.VERTICAL_LAYOUT ? 1 : 0;\n      if (node.size[max_size_index] > max_size) {\n        max_size = node.size[max_size_index];\n      }\n      const node_size_index = layout == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.VERTICAL_LAYOUT ? 0 : 1;\n      y += node.size[node_size_index] + margin + _settings_js__WEBPACK_IMPORTED_MODULE_6__.NODE_TITLE_HEIGHT;\n    }\n    x += max_size + margin;\n  }\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * Returns the amount of time the graph has been running in milliseconds\n * @method getTime\n * @return {number} number of milliseconds the graph has been running\n */\nLGraph.prototype.getTime = function () {\n  return this.globaltime;\n};\n\n/**\n * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant\n * @method getFixedTime\n * @return {number} number of milliseconds the graph has been running\n */\n\nLGraph.prototype.getFixedTime = function () {\n  return this.fixedtime;\n};\n\n/**\n * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct\n * if the nodes are using graphical actions\n * @method getElapsedTime\n * @return {number} number of milliseconds it took the last cycle\n */\n\nLGraph.prototype.getElapsedTime = function () {\n  return this.elapsed_time;\n};\n\n/**\n * Sends an event to all the nodes, useful to trigger stuff\n * @method sendEventToAllNodes\n * @param {String} eventname the name of the event (function to be called)\n * @param {Array} params parameters in array format\n */\nLGraph.prototype.sendEventToAllNodes = function (eventname, params, mode) {\n  mode = mode || _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.ALWAYS;\n  var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n  if (!nodes) {\n    return;\n  }\n  for (var j = 0, l = nodes.length; j < l; ++j) {\n    var node = nodes[j];\n    if (node.constructor === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.Subgraph && eventname != \"onExecute\") {\n      if (node.mode == mode) {\n        node.sendEventToAllNodes(eventname, params, mode);\n      }\n      continue;\n    }\n    if (!node[eventname] || node.mode != mode) {\n      continue;\n    }\n    if (params === undefined) {\n      node[eventname]();\n    } else if (params && params.constructor === Array) {\n      node[eventname].apply(node, params);\n    } else {\n      node[eventname](params);\n    }\n  }\n};\nLGraph.prototype.sendActionToCanvas = function (action, params) {\n  if (!this.list_of_graphcanvas) {\n    return;\n  }\n  for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n    var c = this.list_of_graphcanvas[i];\n    if (c[action]) {\n      c[action].apply(c, params);\n    }\n  }\n};\n\n/**\n * Adds a new node instance to this graph\n * @method add\n * @param {LGraphNode} node the instance of the node\n */\n\nLGraph.prototype.add = function (node, skip_compute_order) {\n  if (!node) {\n    return;\n  }\n\n  //groups\n  if (node.constructor === _l_graph_group_js__WEBPACK_IMPORTED_MODULE_3__.LGraphGroup) {\n    this._groups.push(node);\n    this.setDirtyCanvas(true);\n    this.change();\n    node.graph = this;\n    this._version++;\n    return;\n  }\n\n  //nodes\n  if (node.id != -1 && this._nodes_by_id[node.id] != null) {\n    console.warn(\"LiteGraph: there is already a node with this ID, changing it\");\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.use_uuids) {\n      node.id = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n    } else {\n      node.id = ++this.last_node_id;\n    }\n  }\n  if (this._nodes.length >= _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.MAX_NUMBER_OF_NODES) {\n    throw \"LiteGraph: max number of nodes in a graph reached\";\n  }\n\n  //give him an id\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.use_uuids) {\n    if (node.id == null || node.id == -1) node.id = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n  } else {\n    if (node.id == null || node.id == -1) {\n      node.id = ++this.last_node_id;\n    } else if (this.last_node_id < node.id) {\n      this.last_node_id = node.id;\n    }\n  }\n  node.graph = this;\n  this._version++;\n  this._nodes.push(node);\n  this._nodes_by_id[node.id] = node;\n  if (node.onAdded) {\n    node.onAdded(this);\n  }\n  if (this.config.align_to_grid) {\n    node.alignToGrid();\n  }\n  if (!skip_compute_order) {\n    this.updateExecutionOrder();\n  }\n  if (this.onNodeAdded) {\n    this.onNodeAdded(node);\n  }\n  this.setDirtyCanvas(true);\n  this.change();\n  return node; //to chain actions\n};\n\n/**\n * Removes a node from the graph\n * @method remove\n * @param {LGraphNode} node the instance of the node\n */\n\nLGraph.prototype.remove = function (node) {\n  if (node.constructor === _l_graph_group_js__WEBPACK_IMPORTED_MODULE_3__.LGraphGroup) {\n    var index = this._groups.indexOf(node);\n    if (index != -1) {\n      this._groups.splice(index, 1);\n    }\n    node.graph = null;\n    this._version++;\n    this.setDirtyCanvas(true, true);\n    this.change();\n    return;\n  }\n  if (this._nodes_by_id[node.id] == null) {\n    return;\n  } //not found\n\n  if (node.ignore_remove) {\n    return;\n  } //cannot be removed\n\n  this.beforeChange(); //sure? - almost sure is wrong\n\n  //disconnect inputs\n  if (node.inputs) {\n    for (var i = 0; i < node.inputs.length; i++) {\n      var slot = node.inputs[i];\n      if (slot.link != null) {\n        node.disconnectInput(i);\n      }\n    }\n  }\n\n  //disconnect outputs\n  if (node.outputs) {\n    for (var i = 0; i < node.outputs.length; i++) {\n      var slot = node.outputs[i];\n      if (slot.links != null && slot.links.length) {\n        node.disconnectOutput(i);\n      }\n    }\n  }\n\n  //node.id = -1; //why?\n\n  //callback\n  if (node.onRemoved) {\n    node.onRemoved();\n  }\n  node.graph = null;\n  this._version++;\n\n  //remove from canvas render\n  if (this.list_of_graphcanvas) {\n    for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n      var canvas = this.list_of_graphcanvas[i];\n      if (canvas.selected_nodes[node.id]) {\n        delete canvas.selected_nodes[node.id];\n      }\n      if (canvas.node_dragged == node) {\n        canvas.node_dragged = null;\n      }\n    }\n  }\n\n  //remove from containers\n  var pos = this._nodes.indexOf(node);\n  if (pos != -1) {\n    this._nodes.splice(pos, 1);\n  }\n  delete this._nodes_by_id[node.id];\n  if (this.onNodeRemoved) {\n    this.onNodeRemoved(node);\n  }\n\n  //close panels\n  this.sendActionToCanvas(\"checkPanels\");\n  this.setDirtyCanvas(true, true);\n  this.afterChange(); //sure? - almost sure is wrong\n  this.change();\n  this.updateExecutionOrder();\n};\n\n/**\n * Returns a node by its id.\n * @method getNodeById\n * @param {Number} id\n */\n\nLGraph.prototype.getNodeById = function (id) {\n  if (id == null) {\n    return null;\n  }\n  return this._nodes_by_id[id];\n};\n\n/**\n * Returns a list of nodes that matches a class\n * @method findNodesByClass\n * @param {Class} classObject the class itself (not an string)\n * @return {Array} a list with all the nodes of this type\n */\nLGraph.prototype.findNodesByClass = function (classObject, result) {\n  result = result || [];\n  result.length = 0;\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    if (this._nodes[i].constructor === classObject) {\n      result.push(this._nodes[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Returns a list of nodes that matches a type\n * @method findNodesByType\n * @param {String} type the name of the node type\n * @return {Array} a list with all the nodes of this type\n */\nLGraph.prototype.findNodesByType = function (type, result) {\n  var type = type.toLowerCase();\n  result = result || [];\n  result.length = 0;\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    if (this._nodes[i].type.toLowerCase() == type) {\n      result.push(this._nodes[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Returns the first node that matches a name in its title\n * @method findNodeByTitle\n * @param {String} name the name of the node to search\n * @return {Node} the node or null\n */\nLGraph.prototype.findNodeByTitle = function (title) {\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    if (this._nodes[i].title == title) {\n      return this._nodes[i];\n    }\n  }\n  return null;\n};\n\n/**\n * Returns a list of nodes that matches a name\n * @method findNodesByTitle\n * @param {String} name the name of the node to search\n * @return {Array} a list with all the nodes with this name\n */\nLGraph.prototype.findNodesByTitle = function (title) {\n  var result = [];\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    if (this._nodes[i].title == title) {\n      result.push(this._nodes[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Returns the top-most node in this position of the canvas\n * @method getNodeOnPos\n * @param {number} x the x coordinate in canvas space\n * @param {number} y the y coordinate in canvas space\n * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph\n * @return {LGraphNode} the node at this position or null\n */\nLGraph.prototype.getNodeOnPos = function (x, y, nodes_list, margin) {\n  nodes_list = nodes_list || this._nodes;\n  var nRet = null;\n  for (var i = nodes_list.length - 1; i >= 0; i--) {\n    var n = nodes_list[i];\n    if (n.isPointInside(x, y, margin)) {\n      // check for lesser interest nodes (TODO check for overlapping, use the top)\n      /*if (typeof n == \"LGraphGroup\"){\n          nRet = n;\n      }else{*/\n      return n;\n      /*}*/\n    }\n  }\n  return nRet;\n};\n\n/**\n * Returns the top-most group in that position\n * @method getGroupOnPos\n * @param {number} x the x coordinate in canvas space\n * @param {number} y the y coordinate in canvas space\n * @return {LGraphGroup} the group or null\n */\nLGraph.prototype.getGroupOnPos = function (x, y) {\n  for (var i = this._groups.length - 1; i >= 0; i--) {\n    var g = this._groups[i];\n    if (g.isPointInside(x, y, 2, true)) {\n      return g;\n    }\n  }\n  return null;\n};\n\n/**\n * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution\n * this replaces the ones using the old version with the new version\n * @method checkNodeTypes\n */\nLGraph.prototype.checkNodeTypes = function () {\n  var changes = false;\n  for (var i = 0; i < this._nodes.length; i++) {\n    var node = this._nodes[i];\n    var ctor = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.registered_node_types[node.type];\n    if (node.constructor == ctor) {\n      continue;\n    }\n    console.log(\"node being replaced by newer version: \" + node.type);\n    var newnode = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.createNode(node.type);\n    changes = true;\n    this._nodes[i] = newnode;\n    newnode.configure(node.serialize());\n    newnode.graph = this;\n    this._nodes_by_id[newnode.id] = newnode;\n    if (node.inputs) {\n      newnode.inputs = node.inputs.concat();\n    }\n    if (node.outputs) {\n      newnode.outputs = node.outputs.concat();\n    }\n  }\n  this.updateExecutionOrder();\n};\n\n// ********** GLOBALS *****************\n\nLGraph.prototype.onAction = function (action, param, options) {\n  this._input_nodes = this.findNodesByClass(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.GraphInput, this._input_nodes);\n  for (var i = 0; i < this._input_nodes.length; ++i) {\n    var node = this._input_nodes[i];\n    if (node.properties.name != action) {\n      continue;\n    }\n    //wrap node.onAction(action, param);\n    node.actionDo(action, param, options);\n    break;\n  }\n};\nLGraph.prototype.trigger = function (action, param) {\n  if (this.onTrigger) {\n    this.onTrigger(action, param);\n  }\n};\n\n/**\n * Tell this graph it has a global graph input of this type\n * @method addGlobalInput\n * @param {String} name\n * @param {String} type\n * @param {*} value [optional]\n */\nLGraph.prototype.addInput = function (name, type, value) {\n  var input = this.inputs[name];\n  if (input) {\n    //already exist\n    return;\n  }\n  this.beforeChange();\n  this.inputs[name] = {\n    name: name,\n    type: type,\n    value: value\n  };\n  this._version++;\n  this.afterChange();\n  if (this.onInputAdded) {\n    this.onInputAdded(name, type);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n};\n\n/**\n * Assign a data to the global graph input\n * @method setGlobalInputData\n * @param {String} name\n * @param {*} data\n */\nLGraph.prototype.setInputData = function (name, data) {\n  var input = this.inputs[name];\n  if (!input) {\n    return;\n  }\n  input.value = data;\n};\n\n/**\n * Returns the current value of a global graph input\n * @method getInputData\n * @param {String} name\n * @return {*} the data\n */\nLGraph.prototype.getInputData = function (name) {\n  var input = this.inputs[name];\n  if (!input) {\n    return null;\n  }\n  return input.value;\n};\n\n/**\n * Changes the name of a global graph input\n * @method renameInput\n * @param {String} old_name\n * @param {String} new_name\n */\nLGraph.prototype.renameInput = function (old_name, name) {\n  if (name == old_name) {\n    return;\n  }\n  if (!this.inputs[old_name]) {\n    return false;\n  }\n  if (this.inputs[name]) {\n    console.error(\"there is already one input with that name\");\n    return false;\n  }\n  this.inputs[name] = this.inputs[old_name];\n  delete this.inputs[old_name];\n  this._version++;\n  if (this.onInputRenamed) {\n    this.onInputRenamed(old_name, name);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n};\n\n/**\n * Changes the type of a global graph input\n * @method changeInputType\n * @param {String} name\n * @param {String} type\n */\nLGraph.prototype.changeInputType = function (name, type) {\n  if (!this.inputs[name]) {\n    return false;\n  }\n  if (this.inputs[name].type && String(this.inputs[name].type).toLowerCase() == String(type).toLowerCase()) {\n    return;\n  }\n  this.inputs[name].type = type;\n  this._version++;\n  if (this.onInputTypeChanged) {\n    this.onInputTypeChanged(name, type);\n  }\n};\n\n/**\n * Removes a global graph input\n * @method removeInput\n * @param {String} name\n * @param {String} type\n */\nLGraph.prototype.removeInput = function (name) {\n  if (!this.inputs[name]) {\n    return false;\n  }\n  delete this.inputs[name];\n  this._version++;\n  if (this.onInputRemoved) {\n    this.onInputRemoved(name);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n  return true;\n};\n\n/**\n * Creates a global graph output\n * @method addOutput\n * @param {String} name\n * @param {String} type\n * @param {*} value\n */\nLGraph.prototype.addOutput = function (name, type, value) {\n  this.outputs[name] = {\n    name: name,\n    type: type,\n    value: value\n  };\n  this._version++;\n  if (this.onOutputAdded) {\n    this.onOutputAdded(name, type);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n};\n\n/**\n * Assign a data to the global output\n * @method setOutputData\n * @param {String} name\n * @param {String} value\n */\nLGraph.prototype.setOutputData = function (name, value) {\n  var output = this.outputs[name];\n  if (!output) {\n    return;\n  }\n  output.value = value;\n};\n\n/**\n * Returns the current value of a global graph output\n * @method getOutputData\n * @param {String} name\n * @return {*} the data\n */\nLGraph.prototype.getOutputData = function (name) {\n  var output = this.outputs[name];\n  if (!output) {\n    return null;\n  }\n  return output.value;\n};\n\n/**\n * Renames a global graph output\n * @method renameOutput\n * @param {String} old_name\n * @param {String} new_name\n */\nLGraph.prototype.renameOutput = function (old_name, name) {\n  if (!this.outputs[old_name]) {\n    return false;\n  }\n  if (this.outputs[name]) {\n    console.error(\"there is already one output with that name\");\n    return false;\n  }\n  this.outputs[name] = this.outputs[old_name];\n  delete this.outputs[old_name];\n  this._version++;\n  if (this.onOutputRenamed) {\n    this.onOutputRenamed(old_name, name);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n};\n\n/**\n * Changes the type of a global graph output\n * @method changeOutputType\n * @param {String} name\n * @param {String} type\n */\nLGraph.prototype.changeOutputType = function (name, type) {\n  if (!this.outputs[name]) {\n    return false;\n  }\n  if (this.outputs[name].type && String(this.outputs[name].type).toLowerCase() == String(type).toLowerCase()) {\n    return;\n  }\n  this.outputs[name].type = type;\n  this._version++;\n  if (this.onOutputTypeChanged) {\n    this.onOutputTypeChanged(name, type);\n  }\n};\n\n/**\n * Removes a global graph output\n * @method removeOutput\n * @param {String} name\n */\nLGraph.prototype.removeOutput = function (name) {\n  if (!this.outputs[name]) {\n    return false;\n  }\n  delete this.outputs[name];\n  this._version++;\n  if (this.onOutputRemoved) {\n    this.onOutputRemoved(name);\n  }\n  if (this.onInputsOutputsChange) {\n    this.onInputsOutputsChange();\n  }\n  return true;\n};\nLGraph.prototype.triggerInput = function (name, value) {\n  var nodes = this.findNodesByTitle(name);\n  for (var i = 0; i < nodes.length; ++i) {\n    nodes[i].onTrigger(value);\n  }\n};\nLGraph.prototype.setCallback = function (name, func) {\n  var nodes = this.findNodesByTitle(name);\n  for (var i = 0; i < nodes.length; ++i) {\n    nodes[i].setTrigger(func);\n  }\n};\n\n//used for undo, called before any change is made to the graph\nLGraph.prototype.beforeChange = function (info) {\n  if (this.onBeforeChange) {\n    this.onBeforeChange(this, info);\n  }\n  this.sendActionToCanvas(\"onBeforeChange\", this);\n};\n\n//used to resend actions, called after any change is made to the graph\nLGraph.prototype.afterChange = function (info) {\n  if (this.onAfterChange) {\n    this.onAfterChange(this, info);\n  }\n  this.sendActionToCanvas(\"onAfterChange\", this);\n};\nLGraph.prototype.connectionChange = function (node, link_info) {\n  this.updateExecutionOrder();\n  if (this.onConnectionChange) {\n    this.onConnectionChange(node);\n  }\n  this._version++;\n  this.sendActionToCanvas(\"onConnectionChange\");\n};\n\n/**\n * returns if the graph is in live mode\n * @method isLive\n */\n\nLGraph.prototype.isLive = function () {\n  if (!this.list_of_graphcanvas) {\n    return false;\n  }\n  for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n    var c = this.list_of_graphcanvas[i];\n    if (c.live_mode) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * clears the triggered slot animation in all links (stop visual animation)\n * @method clearTriggeredSlots\n */\nLGraph.prototype.clearTriggeredSlots = function () {\n  for (var i in this.links) {\n    var link_info = this.links[i];\n    if (!link_info) {\n      continue;\n    }\n    if (link_info._last_time) {\n      link_info._last_time = 0;\n    }\n  }\n};\n\n/* Called when something visually changed (not the graph!) */\nLGraph.prototype.change = function () {\n  this.sendActionToCanvas(\"setDirty\", [true, true]);\n  if (this.on_change) {\n    this.on_change(this);\n  }\n};\nLGraph.prototype.setDirtyCanvas = function (fg, bg) {\n  this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n};\n\n/**\n * Destroys a link\n * @method removeLink\n * @param {Number} link_id\n */\nLGraph.prototype.removeLink = function (link_id) {\n  var link = this.links[link_id];\n  if (!link) {\n    return;\n  }\n  var node = this.getNodeById(link.target_id);\n  if (node) {\n    node.disconnectInput(link.target_slot);\n  }\n};\n\n//save and recover app state ***************************************\n/**\n * Creates a Object containing all the info about this graph, it can be serialized\n * @method serialize\n * @return {Object} value of the node\n */\nLGraph.prototype.serialize = function () {\n  var nodes_info = [];\n  for (var i = 0, l = this._nodes.length; i < l; ++i) {\n    nodes_info.push(this._nodes[i].serialize());\n  }\n\n  //pack link info into a non-verbose format\n  var links = [];\n  for (var i in this.links) {\n    //links is an OBJECT\n    var link = this.links[i];\n    if (!link.serialize) {\n      //weird bug I havent solved yet\n      console.warn(\"weird LLink bug, link info is not a LLink but a regular object\");\n      var link2 = new _l_link_js__WEBPACK_IMPORTED_MODULE_1__.LLink();\n      for (var j in link) {\n        link2[j] = link[j];\n      }\n      this.links[i] = link2;\n      link = link2;\n    }\n    links.push(link.serialize());\n  }\n  var groups_info = [];\n  for (var i = 0; i < this._groups.length; ++i) {\n    groups_info.push(this._groups[i].serialize());\n  }\n  var data = {\n    last_node_id: this.last_node_id,\n    last_link_id: this.last_link_id,\n    nodes: nodes_info,\n    links: links,\n    groups: groups_info,\n    config: this.config,\n    extra: this.extra\n  };\n  if (this.onSerialize) this.onSerialize(data);\n  return data;\n};\n\n/**\n * Configure a graph from a JSON string\n * @method configure\n * @param {String} str configure a graph from a JSON string\n * @param {Boolean} returns if there was any error parsing\n */\nLGraph.prototype.configure = function (data, keep_old) {\n  if (!data) {\n    return;\n  }\n  if (!keep_old) {\n    this.clear();\n  }\n  var nodes = data.nodes;\n\n  //decode links info (they are very verbose)\n  if (data.links && data.links.constructor === Array) {\n    var links = [];\n    for (var i = 0; i < data.links.length; ++i) {\n      var link_data = data.links[i];\n      if (!link_data)\n        //weird bug\n        {\n          console.warn(\"serialized graph link data contains errors, skipping.\");\n          continue;\n        }\n      var link = new _l_link_js__WEBPACK_IMPORTED_MODULE_1__.LLink();\n      link.configure(link_data);\n      links[link.id] = link;\n    }\n    data.links = links;\n  }\n\n  //copy all stored fields\n  for (var i in data) {\n    if (i == \"nodes\" || i == \"groups\")\n      //links must be accepted\n      continue;\n    this[i] = data[i];\n  }\n  var error = false;\n\n  //create nodes\n  this._nodes = [];\n  if (nodes) {\n    for (var i = 0, l = nodes.length; i < l; ++i) {\n      var n_info = nodes[i]; //stored info\n      var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.createNode(n_info.type, n_info.title);\n      if (!node) {\n        if (_settings_js__WEBPACK_IMPORTED_MODULE_6__.debug) {\n          console.log(\"Node not found or has errors: \" + n_info.type);\n        }\n\n        //in case of error we create a replacement node to avoid losing info\n        node = new _l_graph_node_js__WEBPACK_IMPORTED_MODULE_2__.LGraphNode();\n        node.last_serialization = n_info;\n        node.has_errors = true;\n        error = true;\n        //continue;\n      }\n      node.id = n_info.id; //id it or it will create a new id\n      this.add(node, true); //add before configure, otherwise configure cannot create links\n    }\n\n    //configure nodes afterwards so they can reach each other\n    for (var i = 0, l = nodes.length; i < l; ++i) {\n      var n_info = nodes[i];\n      var node = this.getNodeById(n_info.id);\n      if (node) {\n        node.configure(n_info);\n      }\n    }\n  }\n\n  //groups\n  this._groups.length = 0;\n  if (data.groups) {\n    for (var i = 0; i < data.groups.length; ++i) {\n      var group = new _l_graph_group_js__WEBPACK_IMPORTED_MODULE_3__.LGraphGroup();\n      group.configure(data.groups[i]);\n      this.add(group);\n    }\n  }\n  this.updateExecutionOrder();\n  this.extra = data.extra || {};\n  if (this.onConfigure) this.onConfigure(data);\n  this._version++;\n  this.setDirtyCanvas(true, true);\n  return error;\n};\nLGraph.prototype.load = function (url, callback) {\n  var that = this;\n\n  //from file\n  if (url.constructor === File || url.constructor === Blob) {\n    var reader = new FileReader();\n    reader.addEventListener('load', function (event) {\n      var data = JSON.parse(event.target.result);\n      that.configure(data);\n      if (callback) callback();\n    });\n    reader.readAsText(url);\n    return;\n  }\n\n  //is a string, then an URL\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", url, true);\n  req.send(null);\n  req.onload = function (oEvent) {\n    if (req.status !== 200) {\n      console.error(\"Error loading graph:\", req.status, req.response);\n      return;\n    }\n    var data = JSON.parse(req.response);\n    that.configure(data);\n    if (callback) callback();\n  };\n  req.onerror = function (err) {\n    console.error(\"Error loading graph:\", err);\n  };\n};\nLGraph.prototype.onNodeTrace = function (node, msg, color) {\n  //TODO\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/l_graph_class.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/l_graph_group.js":
/*!********************************************************!*\
  !*** ./members/GraphRender/litegraph/l_graph_group.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphGroup: () => (/* binding */ LGraphGroup)\n/* harmony export */ });\n/* harmony import */ var _node_colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_colors.js */ \"./members/GraphRender/litegraph/node_colors.js\");\n/* harmony import */ var _l_graph_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./l_graph_node.js */ \"./members/GraphRender/litegraph/l_graph_node.js\");\n\n\nfunction LGraphGroup(title) {\n  this._ctor(title);\n}\nLGraphGroup.prototype._ctor = function (title) {\n  this.title = title || \"Group\";\n  this.font_size = 24;\n  this.color = _node_colors_js__WEBPACK_IMPORTED_MODULE_0__.node_colors.pale_blue ? _node_colors_js__WEBPACK_IMPORTED_MODULE_0__.node_colors.pale_blue.groupcolor : \"#AAA\";\n  this._bounding = new Float32Array([10, 10, 140, 80]);\n  this._pos = this._bounding.subarray(0, 2);\n  this._size = this._bounding.subarray(2, 4);\n  this._nodes = [];\n  this.graph = null;\n  Object.defineProperty(this, \"pos\", {\n    set: function (v) {\n      if (!v || v.length < 2) {\n        return;\n      }\n      this._pos[0] = v[0];\n      this._pos[1] = v[1];\n    },\n    get: function () {\n      return this._pos;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"size\", {\n    set: function (v) {\n      if (!v || v.length < 2) {\n        return;\n      }\n      this._size[0] = Math.max(140, v[0]);\n      this._size[1] = Math.max(80, v[1]);\n    },\n    get: function () {\n      return this._size;\n    },\n    enumerable: true\n  });\n};\nLGraphGroup.prototype.configure = function (o) {\n  this.title = o.title;\n  this._bounding.set(o.bounding);\n  this.color = o.color;\n  this.font_size = o.font_size;\n};\nLGraphGroup.prototype.serialize = function () {\n  var b = this._bounding;\n  return {\n    title: this.title,\n    bounding: [Math.round(b[0]), Math.round(b[1]), Math.round(b[2]), Math.round(b[3])],\n    color: this.color,\n    font_size: this.font_size\n  };\n};\nLGraphGroup.prototype.move = function (deltax, deltay, ignore_nodes) {\n  this._pos[0] += deltax;\n  this._pos[1] += deltay;\n  if (ignore_nodes) {\n    return;\n  }\n  for (var i = 0; i < this._nodes.length; ++i) {\n    var node = this._nodes[i];\n    node.pos[0] += deltax;\n    node.pos[1] += deltay;\n  }\n};\nLGraphGroup.prototype.recomputeInsideNodes = function () {\n  this._nodes.length = 0;\n  var nodes = this.graph._nodes;\n  var node_bounding = new Float32Array(4);\n  for (var i = 0; i < nodes.length; ++i) {\n    var node = nodes[i];\n    node.getBounding(node_bounding);\n    if (!overlapBounding(this._bounding, node_bounding)) {\n      continue;\n    } //out of the visible area\n    this._nodes.push(node);\n  }\n};\nLGraphGroup.prototype.isPointInside = _l_graph_node_js__WEBPACK_IMPORTED_MODULE_1__.LGraphNode.prototype.isPointInside;\nLGraphGroup.prototype.setDirtyCanvas = _l_graph_node_js__WEBPACK_IMPORTED_MODULE_1__.LGraphNode.prototype.setDirtyCanvas;\n\n//bounding overlap, format: [ startx, starty, width, height ]\nfunction overlapBounding(a, b) {\n  var A_end_x = a[0] + a[2];\n  var A_end_y = a[1] + a[3];\n  var B_end_x = b[0] + b[2];\n  var B_end_y = b[1] + b[3];\n  if (a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]) {\n    return false;\n  }\n  return true;\n}\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/l_graph_group.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/l_graph_node.js":
/*!*******************************************************!*\
  !*** ./members/GraphRender/litegraph/l_graph_node.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphNode: () => (/* binding */ LGraphNode)\n/* harmony export */ });\n/* harmony import */ var _libs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs.js */ \"./members/GraphRender/litegraph/libs.js\");\n/* harmony import */ var _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./litegraph_class.js */ \"./members/GraphRender/litegraph/litegraph_class.js\");\n/* harmony import */ var _l_link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./l_link.js */ \"./members/GraphRender/litegraph/l_link.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.js */ \"./members/GraphRender/litegraph/settings.js\");\n\n\n\n\n\n/**\n * Base Class for all the node type classes\n * @class LGraphNode\n * @param {String} name a name for the node\n */\n\nconst NODE_WIDTH = 140;\nconst NODE_COLLAPSED_WIDTH = 80;\nconst IN_OUT_PUT = {\n  //enums\n  INPUT: 1,\n  OUTPUT: 2\n};\nfunction LGraphNode(title) {\n  this._ctor(title);\n}\nLGraphNode.prototype._ctor = function (title) {\n  this.title = title || \"Unnamed\";\n  this.size = [NODE_WIDTH, 60];\n  this.graph = null;\n  this._pos = new Float32Array(10, 10);\n  Object.defineProperty(this, \"pos\", {\n    set: function (v) {\n      if (!v || v.length < 2) {\n        return;\n      }\n      this._pos[0] = v[0];\n      this._pos[1] = v[1];\n    },\n    get: function () {\n      return this._pos;\n    },\n    enumerable: true\n  });\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.use_uuids) {\n    this.id = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n  } else {\n    this.id = -1; //not know till not added\n  }\n  this.type = null;\n\n  //inputs available: array of inputs\n  this.inputs = [];\n  this.outputs = [];\n  this.connections = [];\n\n  //local data\n  this.properties = {}; //for the values\n  this.properties_info = []; //for the info\n\n  this.flags = {};\n};\n\n/**\n * configure a node from an object containing the serialized info\n * @method configure\n */\nLGraphNode.prototype.configure = function (info) {\n  if (this.graph) {\n    this.graph._version++;\n  }\n  for (var j in info) {\n    if (j == \"properties\") {\n      //i don't want to clone properties, I want to reuse the old container\n      for (var k in info.properties) {\n        this.properties[k] = info.properties[k];\n        if (this.onPropertyChanged) {\n          this.onPropertyChanged(k, info.properties[k]);\n        }\n      }\n      continue;\n    }\n    if (info[j] == null) {\n      continue;\n    } else if (typeof info[j] == \"object\") {\n      //object\n      if (this[j] && this[j].configure) {\n        this[j].configure(info[j]);\n      } else {\n        this[j] = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.cloneObject)(info[j], this[j]);\n      }\n    } //value\n    else {\n      this[j] = info[j];\n    }\n  }\n  if (!info.title) {\n    this.title = this.constructor.title;\n  }\n  if (this.inputs) {\n    for (var i = 0; i < this.inputs.length; ++i) {\n      var input = this.inputs[i];\n      var link_info = this.graph ? this.graph.links[input.link] : null;\n      if (this.onConnectionsChange) this.onConnectionsChange(IN_OUT_PUT.INPUT, i, true, link_info, input); //link_info has been created now, so its updated\n\n      if (this.onInputAdded) this.onInputAdded(input);\n    }\n  }\n  if (this.outputs) {\n    for (var i = 0; i < this.outputs.length; ++i) {\n      var output = this.outputs[i];\n      if (!output.links) {\n        continue;\n      }\n      for (var j = 0; j < output.links.length; ++j) {\n        var link_info = this.graph ? this.graph.links[output.links[j]] : null;\n        if (this.onConnectionsChange) this.onConnectionsChange(IN_OUT_PUT.OUTPUT, i, true, link_info, output); //link_info has been created now, so its updated\n      }\n      if (this.onOutputAdded) this.onOutputAdded(output);\n    }\n  }\n  if (this.widgets) {\n    for (var i = 0; i < this.widgets.length; ++i) {\n      var w = this.widgets[i];\n      if (!w) continue;\n      if (w.options && w.options.property && this.properties[w.options.property] != undefined) w.value = JSON.parse(JSON.stringify(this.properties[w.options.property]));\n    }\n    if (info.widgets_values) {\n      for (var i = 0; i < info.widgets_values.length; ++i) {\n        if (this.widgets[i]) {\n          this.widgets[i].value = info.widgets_values[i];\n        }\n      }\n    }\n  }\n  if (this.onConfigure) {\n    this.onConfigure(info);\n  }\n};\n\n/**\n * serialize the content\n * @method serialize\n */\n\nLGraphNode.prototype.serialize = function () {\n  //create serialization object\n  var o = {\n    id: this.id,\n    type: this.type,\n    pos: this.pos,\n    size: this.size,\n    flags: (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.cloneObject)(this.flags),\n    order: this.order,\n    mode: this.mode\n  };\n\n  //special case for when there were errors\n  if (this.constructor === LGraphNode && this.last_serialization) {\n    return this.last_serialization;\n  }\n  if (this.inputs) {\n    o.inputs = this.inputs;\n  }\n  if (this.outputs) {\n    //clear outputs last data (because data in connections is never serialized but stored inside the outputs info)\n    for (var i = 0; i < this.outputs.length; i++) {\n      delete this.outputs[i]._data;\n    }\n    o.outputs = this.outputs;\n  }\n  if (this.title && this.title != this.constructor.title) {\n    o.title = this.title;\n  }\n  if (this.properties) {\n    o.properties = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.cloneObject)(this.properties);\n  }\n  if (this.widgets && this.serialize_widgets) {\n    o.widgets_values = [];\n    for (var i = 0; i < this.widgets.length; ++i) {\n      if (this.widgets[i]) o.widgets_values[i] = this.widgets[i].value;else o.widgets_values[i] = null;\n    }\n  }\n  if (!o.type) {\n    o.type = this.constructor.type;\n  }\n  if (this.color) {\n    o.color = this.color;\n  }\n  if (this.bgcolor) {\n    o.bgcolor = this.bgcolor;\n  }\n  if (this.boxcolor) {\n    o.boxcolor = this.boxcolor;\n  }\n  if (this.shape) {\n    o.shape = this.shape;\n  }\n  if (this.onSerialize) {\n    if (this.onSerialize(o)) {\n      console.warn(\"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\");\n    }\n  }\n  return o;\n};\n\n/* Creates a clone of this node */\nLGraphNode.prototype.clone = function () {\n  var node = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode(this.type);\n  if (!node) {\n    return null;\n  }\n\n  //we clone it because serialize returns shared containers\n  var data = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.cloneObject)(this.serialize());\n\n  //remove links\n  if (data.inputs) {\n    for (var i = 0; i < data.inputs.length; ++i) {\n      data.inputs[i].link = null;\n    }\n  }\n  if (data.outputs) {\n    for (var i = 0; i < data.outputs.length; ++i) {\n      if (data.outputs[i].links) {\n        data.outputs[i].links.length = 0;\n      }\n    }\n  }\n  delete data[\"id\"];\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.use_uuids) {\n    data[\"id\"] = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n  }\n\n  //remove links\n  node.configure(data);\n  return node;\n};\n\n/**\n * serialize and stringify\n * @method toString\n */\n\nLGraphNode.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n//LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph\n\n/**\n * get the title string\n * @method getTitle\n */\n\nLGraphNode.prototype.getTitle = function () {\n  return this.title || this.constructor.title;\n};\n\n/**\n * sets the value of a property\n * @method setProperty\n * @param {String} name\n * @param {*} value\n */\nLGraphNode.prototype.setProperty = function (name, value) {\n  if (!this.properties) {\n    this.properties = {};\n  }\n  if (value === this.properties[name]) return;\n  var prev_value = this.properties[name];\n  this.properties[name] = value;\n  if (this.onPropertyChanged) {\n    if (this.onPropertyChanged(name, value, prev_value) === false)\n      //abort change\n      this.properties[name] = prev_value;\n  }\n  if (this.widgets)\n    //widgets could be linked to properties\n    for (var i = 0; i < this.widgets.length; ++i) {\n      var w = this.widgets[i];\n      if (!w) continue;\n      if (w.options.property == name) {\n        w.value = value;\n        break;\n      }\n    }\n};\n\n// Execution *************************\n/**\n * sets the output data\n * @method setOutputData\n * @param {number} slot\n * @param {*} data\n */\nLGraphNode.prototype.setOutputData = function (slot, data) {\n  if (!this.outputs) {\n    return;\n  }\n\n  //this maybe slow and a niche case\n  //if(slot && slot.constructor === String)\n  //\tslot = this.findOutputSlot(slot);\n\n  if (slot == -1 || slot >= this.outputs.length) {\n    return;\n  }\n  var output_info = this.outputs[slot];\n  if (!output_info) {\n    return;\n  }\n\n  //store data in the output itself in case we want to debug\n  output_info._data = data;\n\n  //if there are connections, pass the data to the connections\n  if (this.outputs[slot].links) {\n    for (var i = 0; i < this.outputs[slot].links.length; i++) {\n      var link_id = this.outputs[slot].links[i];\n      var link = this.graph.links[link_id];\n      if (link) link.data = data;\n    }\n  }\n};\n\n/**\n * sets the output data type, useful when you want to be able to overwrite the data type\n * @method setOutputDataType\n * @param {number} slot\n * @param {String} datatype\n */\nLGraphNode.prototype.setOutputDataType = function (slot, type) {\n  if (!this.outputs) {\n    return;\n  }\n  if (slot == -1 || slot >= this.outputs.length) {\n    return;\n  }\n  var output_info = this.outputs[slot];\n  if (!output_info) {\n    return;\n  }\n  //store data in the output itself in case we want to debug\n  output_info.type = type;\n\n  //if there are connections, pass the data to the connections\n  if (this.outputs[slot].links) {\n    for (var i = 0; i < this.outputs[slot].links.length; i++) {\n      var link_id = this.outputs[slot].links[i];\n      this.graph.links[link_id].type = type;\n    }\n  }\n};\n\n/**\n * Retrieves the input data (data traveling through the connection) from one slot\n * @method getInputData\n * @param {number} slot\n * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\n * @return {*} data or if it is not connected returns undefined\n */\nLGraphNode.prototype.getInputData = function (slot, force_update) {\n  if (!this.inputs) {\n    return;\n  } //undefined;\n\n  if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n    return;\n  }\n  var link_id = this.inputs[slot].link;\n  var link = this.graph.links[link_id];\n  if (!link) {\n    //bug: weird case but it happens sometimes\n    return null;\n  }\n  if (!force_update) {\n    return link.data;\n  }\n\n  //special case: used to extract data from the incoming connection before the graph has been executed\n  var node = this.graph.getNodeById(link.origin_id);\n  if (!node) {\n    return link.data;\n  }\n  if (node.updateOutputData) {\n    node.updateOutputData(link.origin_slot);\n  } else if (node.onExecute) {\n    node.onExecute();\n  }\n  return link.data;\n};\n\n/**\n * Retrieves the input data type (in case this supports multiple input types)\n * @method getInputDataType\n * @param {number} slot\n * @return {String} datatype in string format\n */\nLGraphNode.prototype.getInputDataType = function (slot) {\n  if (!this.inputs) {\n    return null;\n  } //undefined;\n\n  if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n    return null;\n  }\n  var link_id = this.inputs[slot].link;\n  var link = this.graph.links[link_id];\n  if (!link) {\n    //bug: weird case but it happens sometimes\n    return null;\n  }\n  var node = this.graph.getNodeById(link.origin_id);\n  if (!node) {\n    return link.type;\n  }\n  var output_info = node.outputs[link.origin_slot];\n  if (output_info) {\n    return output_info.type;\n  }\n  return null;\n};\n\n/**\n * Retrieves the input data from one slot using its name instead of slot number\n * @method getInputDataByName\n * @param {String} slot_name\n * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\n * @return {*} data or if it is not connected returns null\n */\nLGraphNode.prototype.getInputDataByName = function (slot_name, force_update) {\n  var slot = this.findInputSlot(slot_name);\n  if (slot == -1) {\n    return null;\n  }\n  return this.getInputData(slot, force_update);\n};\n\n/**\n * tells you if there is a connection in one input slot\n * @method isInputConnected\n * @param {number} slot\n * @return {boolean}\n */\nLGraphNode.prototype.isInputConnected = function (slot) {\n  if (!this.inputs) {\n    return false;\n  }\n  return slot < this.inputs.length && this.inputs[slot].link != null;\n};\n\n/**\n * tells you info about an input connection (which node, type, etc)\n * @method getInputInfo\n * @param {number} slot\n * @return {Object} object or null { link: id, name: string, type: string or 0 }\n */\nLGraphNode.prototype.getInputInfo = function (slot) {\n  if (!this.inputs) {\n    return null;\n  }\n  if (slot < this.inputs.length) {\n    return this.inputs[slot];\n  }\n  return null;\n};\n\n/**\n * Returns the link info in the connection of an input slot\n * @method getInputLink\n * @param {number} slot\n * @return {LLink} object or null\n */\nLGraphNode.prototype.getInputLink = function (slot) {\n  if (!this.inputs) {\n    return null;\n  }\n  if (slot < this.inputs.length) {\n    var slot_info = this.inputs[slot];\n    return this.graph.links[slot_info.link];\n  }\n  return null;\n};\n\n/**\n * returns the node connected in the input slot\n * @method getInputNode\n * @param {number} slot\n * @return {LGraphNode} node or null\n */\nLGraphNode.prototype.getInputNode = function (slot) {\n  if (!this.inputs) {\n    return null;\n  }\n  if (slot >= this.inputs.length) {\n    return null;\n  }\n  var input = this.inputs[slot];\n  if (!input || input.link === null) {\n    return null;\n  }\n  var link_info = this.graph.links[input.link];\n  if (!link_info) {\n    return null;\n  }\n  return this.graph.getNodeById(link_info.origin_id);\n};\n\n/**\n * returns the value of an input with this name, otherwise checks if there is a property with that name\n * @method getInputOrProperty\n * @param {string} name\n * @return {*} value\n */\nLGraphNode.prototype.getInputOrProperty = function (name) {\n  if (!this.inputs || !this.inputs.length) {\n    return this.properties ? this.properties[name] : null;\n  }\n  for (var i = 0, l = this.inputs.length; i < l; ++i) {\n    var input_info = this.inputs[i];\n    if (name == input_info.name && input_info.link != null) {\n      var link = this.graph.links[input_info.link];\n      if (link) {\n        return link.data;\n      }\n    }\n  }\n  return this.properties[name];\n};\n\n/**\n * tells you the last output data that went in that slot\n * @method getOutputData\n * @param {number} slot\n * @return {Object}  object or null\n */\nLGraphNode.prototype.getOutputData = function (slot) {\n  if (!this.outputs) {\n    return null;\n  }\n  if (slot >= this.outputs.length) {\n    return null;\n  }\n  var info = this.outputs[slot];\n  return info._data;\n};\n\n/**\n * tells you info about an output connection (which node, type, etc)\n * @method getOutputInfo\n * @param {number} slot\n * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }\n */\nLGraphNode.prototype.getOutputInfo = function (slot) {\n  if (!this.outputs) {\n    return null;\n  }\n  if (slot < this.outputs.length) {\n    return this.outputs[slot];\n  }\n  return null;\n};\n\n/**\n * tells you if there is a connection in one output slot\n * @method isOutputConnected\n * @param {number} slot\n * @return {boolean}\n */\nLGraphNode.prototype.isOutputConnected = function (slot) {\n  if (!this.outputs) {\n    return false;\n  }\n  return slot < this.outputs.length && this.outputs[slot].links && this.outputs[slot].links.length;\n};\n\n/**\n * tells you if there is any connection in the output slots\n * @method isAnyOutputConnected\n * @return {boolean}\n */\nLGraphNode.prototype.isAnyOutputConnected = function () {\n  if (!this.outputs) {\n    return false;\n  }\n  for (var i = 0; i < this.outputs.length; ++i) {\n    if (this.outputs[i].links && this.outputs[i].links.length) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * retrieves all the nodes connected to this output slot\n * @method getOutputNodes\n * @param {number} slot\n * @return {array}\n */\nLGraphNode.prototype.getOutputNodes = function (slot) {\n  if (!this.outputs || this.outputs.length == 0) {\n    return null;\n  }\n  if (slot >= this.outputs.length) {\n    return null;\n  }\n  var output = this.outputs[slot];\n  if (!output.links || output.links.length == 0) {\n    return null;\n  }\n  var r = [];\n  for (var i = 0; i < output.links.length; i++) {\n    var link_id = output.links[i];\n    var link = this.graph.links[link_id];\n    if (link) {\n      var target_node = this.graph.getNodeById(link.target_id);\n      if (target_node) {\n        r.push(target_node);\n      }\n    }\n  }\n  return r;\n};\nLGraphNode.prototype.addOnTriggerInput = function () {\n  var trigS = this.findInputSlot(\"onTrigger\");\n  if (trigS == -1) {\n    //!trigS || \n    var input = this.addInput(\"onTrigger\", _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT, {\n      optional: true,\n      nameLocked: true\n    });\n    return this.findInputSlot(\"onTrigger\");\n  }\n  return trigS;\n};\nLGraphNode.prototype.addOnExecutedOutput = function () {\n  var trigS = this.findOutputSlot(\"onExecuted\");\n  if (trigS == -1) {\n    //!trigS || \n    var output = this.addOutput(\"onExecuted\", _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ACTION, {\n      optional: true,\n      nameLocked: true\n    });\n    return this.findOutputSlot(\"onExecuted\");\n  }\n  return trigS;\n};\nLGraphNode.prototype.onAfterExecuteNode = function (param, options) {\n  var trigS = this.findOutputSlot(\"onExecuted\");\n  if (trigS != -1) {\n    //console.debug(this.id+\":\"+this.order+\" triggering slot onAfterExecute\");\n    //console.debug(param);\n    //console.debug(options);\n    this.triggerSlot(trigS, param, null, options);\n  }\n};\nLGraphNode.prototype.changeMode = function (modeTo) {\n  switch (modeTo) {\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ON_EVENT:\n      // this.addOnExecutedOutput();\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ON_TRIGGER:\n      this.addOnTriggerInput();\n      this.addOnExecutedOutput();\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NEVER:\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ALWAYS:\n      break;\n    case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ON_REQUEST:\n      break;\n    default:\n      return false;\n      break;\n  }\n  this.mode = modeTo;\n  return true;\n};\n\n/**\n * Triggers the execution of actions that were deferred when the action was triggered\n * @method executePendingActions\n */\nLGraphNode.prototype.executePendingActions = function () {\n  if (!this._waiting_actions || !this._waiting_actions.length) return;\n  for (var i = 0; i < this._waiting_actions.length; ++i) {\n    var p = this._waiting_actions[i];\n    this.onAction(p[0], p[1], p[2], p[3], p[4]);\n  }\n  this._waiting_actions.length = 0;\n};\n\n/**\n * Triggers the node code execution, place a boolean/counter to mark the node as being executed\n * @method doExecute\n * @param {*} param\n * @param {*} options\n */\nLGraphNode.prototype.doExecute = function (param, options) {\n  options = options || {};\n  if (this.onExecute) {\n    // enable this to give the event an ID\n    if (!options.action_call) options.action_call = this.id + \"_exec_\" + Math.floor(Math.random() * 9999);\n    this.graph.nodes_executing[this.id] = true; //.push(this.id);\n\n    this.onExecute(param, options);\n    this.graph.nodes_executing[this.id] = false; //.pop();\n\n    // save execution/action ref\n    this.exec_version = this.graph.iteration;\n    if (options && options.action_call) {\n      this.action_call = options.action_call; // if (param)\n      this.graph.nodes_executedAction[this.id] = options.action_call;\n    }\n  } else {}\n  this.execute_triggered = 2; // the nFrames it will be used (-- each step), means \"how old\" is the event\n  if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options); // callback\n};\n\n/**\n * Triggers an action, wrapped by logics to control execution flow\n * @method actionDo\n * @param {String} action name\n * @param {*} param\n */\nLGraphNode.prototype.actionDo = function (action, param, options, action_slot) {\n  options = options || {};\n  if (this.onAction) {\n    // enable this to give the event an ID\n    if (!options.action_call) options.action_call = this.id + \"_\" + (action ? action : \"action\") + \"_\" + Math.floor(Math.random() * 9999);\n    this.graph.nodes_actioning[this.id] = action ? action : \"actioning\"; //.push(this.id);\n\n    this.onAction(action, param, options, action_slot);\n    this.graph.nodes_actioning[this.id] = false; //.pop();\n\n    // save execution/action ref\n    if (options && options.action_call) {\n      this.action_call = options.action_call; // if (param)\n      this.graph.nodes_executedAction[this.id] = options.action_call;\n    }\n  }\n  this.action_triggered = 2; // the nFrames it will be used (-- each step), means \"how old\" is the event\n  if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options);\n};\n\n/**\n * Triggers an event in this node, this will trigger any output with the same name\n * @method trigger\n * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the event is send to all\n * @param {*} param\n */\nLGraphNode.prototype.trigger = function (action, param, options) {\n  if (!this.outputs || !this.outputs.length) {\n    return;\n  }\n  if (this.graph) this.graph._last_trigger_time = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  for (var i = 0; i < this.outputs.length; ++i) {\n    var output = this.outputs[i];\n    if (!output || output.type !== _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT || action && output.name != action) continue;\n    this.triggerSlot(i, param, null, options);\n  }\n};\n\n/**\n * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes\n * @method triggerSlot\n * @param {Number} slot the index of the output slot\n * @param {*} param\n * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\n */\nLGraphNode.prototype.triggerSlot = function (slot, param, link_id, options) {\n  options = options || {};\n  if (!this.outputs) {\n    return;\n  }\n  if (slot == null) {\n    console.error(\"slot must be a number\");\n    return;\n  }\n  if (slot.constructor !== Number) console.warn(\"slot must be a number, use node.trigger('name') if you want to use a string\");\n  var output = this.outputs[slot];\n  if (!output) {\n    return;\n  }\n  var links = output.links;\n  if (!links || !links.length) {\n    return;\n  }\n  if (this.graph) {\n    this.graph._last_trigger_time = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n  }\n\n  //for every link attached here\n  for (var k = 0; k < links.length; ++k) {\n    var id = links[k];\n    if (link_id != null && link_id != id) {\n      //to skip links\n      continue;\n    }\n    var link_info = this.graph.links[links[k]];\n    if (!link_info) {\n      //not connected\n      continue;\n    }\n    link_info._last_time = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.getTime)();\n    var node = this.graph.getNodeById(link_info.target_id);\n    if (!node) {\n      //node not found?\n      continue;\n    }\n\n    //used to mark events in graph\n    var target_connection = node.inputs[link_info.target_slot];\n    if (node.mode === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ON_TRIGGER) {\n      // generate unique trigger ID if not present\n      if (!options.action_call) options.action_call = this.id + \"_trigg_\" + Math.floor(Math.random() * 9999);\n      if (node.onExecute) {\n        // -- wrapping node.onExecute(param); --\n        node.doExecute(param, options);\n      }\n    } else if (node.onAction) {\n      // generate unique action ID if not present\n      if (!options.action_call) options.action_call = this.id + \"_act_\" + Math.floor(Math.random() * 9999);\n      //pass the action name\n      var target_connection = node.inputs[link_info.target_slot];\n\n      //instead of executing them now, it will be executed in the next graph loop, to ensure data flow\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.use_deferred_actions && node.onExecute) {\n        if (!node._waiting_actions) node._waiting_actions = [];\n        node._waiting_actions.push([target_connection.name, param, options, link_info.target_slot]);\n      } else {\n        // wrap node.onAction(target_connection.name, param);\n        node.actionDo(target_connection.name, param, options, link_info.target_slot);\n      }\n    }\n  }\n};\n\n/**\n * clears the trigger slot animation\n * @method clearTriggeredSlot\n * @param {Number} slot the index of the output slot\n * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\n */\nLGraphNode.prototype.clearTriggeredSlot = function (slot, link_id) {\n  if (!this.outputs) {\n    return;\n  }\n  var output = this.outputs[slot];\n  if (!output) {\n    return;\n  }\n  var links = output.links;\n  if (!links || !links.length) {\n    return;\n  }\n\n  //for every link attached here\n  for (var k = 0; k < links.length; ++k) {\n    var id = links[k];\n    if (link_id != null && link_id != id) {\n      //to skip links\n      continue;\n    }\n    var link_info = this.graph.links[links[k]];\n    if (!link_info) {\n      //not connected\n      continue;\n    }\n    link_info._last_time = 0;\n  }\n};\n\n/**\n * changes node size and triggers callback\n * @method setSize\n * @param {vec2} size\n */\nLGraphNode.prototype.setSize = function (size) {\n  this.size = size;\n  if (this.onResize) this.onResize(this.size);\n};\n\n/**\n * add a new property to this node\n * @method addProperty\n * @param {string} name\n * @param {*} default_value\n * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)\n */\nLGraphNode.prototype.addProperty = function (name, default_value, type, extra_info) {\n  var o = {\n    name: name,\n    type: type,\n    default_value: default_value\n  };\n  if (extra_info) {\n    for (var i in extra_info) {\n      o[i] = extra_info[i];\n    }\n  }\n  if (!this.properties_info) {\n    this.properties_info = [];\n  }\n  this.properties_info.push(o);\n  if (!this.properties) {\n    this.properties = {};\n  }\n  this.properties[name] = default_value;\n  return o;\n};\n\n//connections\n\n/**\n * add a new output slot to use in this node\n * @method addOutput\n * @param {string} name\n * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)\n */\nLGraphNode.prototype.addOutput = function (name, type, extra_info) {\n  var output = {\n    name: name,\n    type: type,\n    links: null\n  };\n  if (extra_info) {\n    for (var i in extra_info) {\n      output[i] = extra_info[i];\n    }\n  }\n  if (!this.outputs) {\n    this.outputs = [];\n  }\n  this.outputs.push(output);\n  if (this.onOutputAdded) {\n    this.onOutputAdded(output);\n  }\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.auto_load_slot_types) _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registerNodeAndSlotType(this, type, true);\n  this.setSize(this.computeSize());\n  this.setDirtyCanvas(true, true);\n  return output;\n};\n\n/**\n * add a new output slot to use in this node\n * @method addOutputs\n * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n */\nLGraphNode.prototype.addOutputs = function (array) {\n  for (var i = 0; i < array.length; ++i) {\n    var info = array[i];\n    var o = {\n      name: info[0],\n      type: info[1],\n      link: null\n    };\n    if (array[2]) {\n      for (var j in info[2]) {\n        o[j] = info[2][j];\n      }\n    }\n    if (!this.outputs) {\n      this.outputs = [];\n    }\n    this.outputs.push(o);\n    if (this.onOutputAdded) {\n      this.onOutputAdded(o);\n    }\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.auto_load_slot_types) _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registerNodeAndSlotType(this, info[1], true);\n  }\n  this.setSize(this.computeSize());\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * remove an existing output slot\n * @method removeOutput\n * @param {number} slot\n */\nLGraphNode.prototype.removeOutput = function (slot) {\n  this.disconnectOutput(slot);\n  this.outputs.splice(slot, 1);\n  for (var i = slot; i < this.outputs.length; ++i) {\n    if (!this.outputs[i] || !this.outputs[i].links) {\n      continue;\n    }\n    var links = this.outputs[i].links;\n    for (var j = 0; j < links.length; ++j) {\n      var link = this.graph.links[links[j]];\n      if (!link) {\n        continue;\n      }\n      link.origin_slot -= 1;\n    }\n  }\n  this.setSize(this.computeSize());\n  if (this.onOutputRemoved) {\n    this.onOutputRemoved(slot);\n  }\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * add a new input slot to use in this node\n * @method addInput\n * @param {string} name\n * @param {string} type string defining the input type (\"vec3\",\"number\",...), it its a generic one use 0\n * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)\n */\nLGraphNode.prototype.addInput = function (name, type, extra_info) {\n  type = type || 0;\n  var input = {\n    name: name,\n    type: type,\n    link: null\n  };\n  if (extra_info) {\n    for (var i in extra_info) {\n      input[i] = extra_info[i];\n    }\n  }\n  if (!this.inputs) {\n    this.inputs = [];\n  }\n  this.inputs.push(input);\n  this.setSize(this.computeSize());\n  if (this.onInputAdded) {\n    this.onInputAdded(input);\n  }\n  _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registerNodeAndSlotType(this, type);\n  this.setDirtyCanvas(true, true);\n  return input;\n};\n\n/**\n * add several new input slots in this node\n * @method addInputs\n * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n */\nLGraphNode.prototype.addInputs = function (array) {\n  for (var i = 0; i < array.length; ++i) {\n    var info = array[i];\n    var o = {\n      name: info[0],\n      type: info[1],\n      link: null\n    };\n    if (array[2]) {\n      for (var j in info[2]) {\n        o[j] = info[2][j];\n      }\n    }\n    if (!this.inputs) {\n      this.inputs = [];\n    }\n    this.inputs.push(o);\n    if (this.onInputAdded) {\n      this.onInputAdded(o);\n    }\n    _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.registerNodeAndSlotType(this, info[1]);\n  }\n  this.setSize(this.computeSize());\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * remove an existing input slot\n * @method removeInput\n * @param {number} slot\n */\nLGraphNode.prototype.removeInput = function (slot) {\n  this.disconnectInput(slot);\n  var slot_info = this.inputs.splice(slot, 1);\n  for (var i = slot; i < this.inputs.length; ++i) {\n    if (!this.inputs[i]) {\n      continue;\n    }\n    var link = this.graph.links[this.inputs[i].link];\n    if (!link) {\n      continue;\n    }\n    link.target_slot -= 1;\n  }\n  this.setSize(this.computeSize());\n  if (this.onInputRemoved) {\n    this.onInputRemoved(slot, slot_info[0]);\n  }\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * add an special connection to this node (used for special kinds of graphs)\n * @method addConnection\n * @param {string} name\n * @param {string} type string defining the input type (\"vec3\",\"number\",...)\n * @param {[x,y]} pos position of the connection inside the node\n * @param {string} direction if is input or output\n */\nLGraphNode.prototype.addConnection = function (name, type, pos, direction) {\n  var o = {\n    name: name,\n    type: type,\n    pos: pos,\n    direction: direction,\n    links: null\n  };\n  this.connections.push(o);\n  return o;\n};\n\n/**\n * computes the minimum size of a node according to its inputs and output slots\n * @method computeSize\n * @param {vec2} minHeight\n * @return {vec2} the total size\n */\nLGraphNode.prototype.computeSize = function (out) {\n  if (this.constructor.size) {\n    return this.constructor.size.concat();\n  }\n  var rows = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1);\n  var size = out || new Float32Array([0, 0]);\n  rows = Math.max(rows, 1);\n  var font_size = _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TEXT_SIZE; //although it should be graphcanvas.inner_text_font size\n\n  var title_width = compute_text_size(this.title);\n  var input_width = 0;\n  var output_width = 0;\n  if (this.inputs) {\n    for (var i = 0, l = this.inputs.length; i < l; ++i) {\n      var input = this.inputs[i];\n      var text = input.label || input.name || \"\";\n      var text_width = compute_text_size(text);\n      if (input_width < text_width) {\n        input_width = text_width;\n      }\n    }\n  }\n  if (this.outputs) {\n    for (var i = 0, l = this.outputs.length; i < l; ++i) {\n      var output = this.outputs[i];\n      var text = output.label || output.name || \"\";\n      var text_width = compute_text_size(text);\n      if (output_width < text_width) {\n        output_width = text_width;\n      }\n    }\n  }\n  size[0] = Math.max(input_width + output_width + 10, title_width);\n  size[0] = Math.max(size[0], NODE_WIDTH);\n  if (this.widgets && this.widgets.length) {\n    size[0] = Math.max(size[0], NODE_WIDTH * 1.5);\n  }\n  size[1] = (this.constructor.slot_start_y || 0) + rows * _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_SLOT_HEIGHT;\n  var widgets_height = 0;\n  if (this.widgets && this.widgets.length) {\n    for (var i = 0, l = this.widgets.length; i < l; ++i) {\n      if (this.widgets[i].computeSize) widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;else widgets_height += _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_WIDGET_HEIGHT + 4;\n    }\n    widgets_height += 8;\n  }\n\n  //compute height using widgets height\n  if (this.widgets_up) size[1] = Math.max(size[1], widgets_height);else if (this.widgets_start_y != null) size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);else size[1] += widgets_height;\n  function compute_text_size(text) {\n    if (!text) {\n      return 0;\n    }\n    return font_size * text.length * 0.6;\n  }\n  if (this.constructor.min_height && size[1] < this.constructor.min_height) {\n    size[1] = this.constructor.min_height;\n  }\n  size[1] += 6; //margin\n\n  return size;\n};\n\n/**\n * returns all the info available about a property of this node.\n *\n * @method getPropertyInfo\n * @param {String} property name of the property\n * @return {Object} the object with all the available info\n*/\nLGraphNode.prototype.getPropertyInfo = function (property) {\n  var info = null;\n\n  //there are several ways to define info about a property\n  //legacy mode\n  if (this.properties_info) {\n    for (var i = 0; i < this.properties_info.length; ++i) {\n      if (this.properties_info[i].name == property) {\n        info = this.properties_info[i];\n        break;\n      }\n    }\n  }\n  //litescene mode using the constructor\n  if (this.constructor[\"@\" + property]) info = this.constructor[\"@\" + property];\n  if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n  //litescene mode using the constructor\n  if (!info && this.onGetPropertyInfo) {\n    info = this.onGetPropertyInfo(property);\n  }\n  if (!info) info = {};\n  if (!info.type) info.type = typeof this.properties[property];\n  if (info.widget == \"combo\") info.type = \"enum\";\n  return info;\n};\n\n/**\n * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties\n *\n * @method addWidget\n * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\n * @param {String} name the text to show on the widget\n * @param {String} value the default value\n * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)\n * @param {Object} options the object that contains special properties of this widget \n * @return {Object} the created widget object\n */\nLGraphNode.prototype.addWidget = function (type, name, value, callback, options) {\n  if (!this.widgets) {\n    this.widgets = [];\n  }\n  if (!options && callback && callback.constructor === Object) {\n    options = callback;\n    callback = null;\n  }\n  if (options && options.constructor === String)\n    //options can be the property name\n    options = {\n      property: options\n    };\n  if (callback && callback.constructor === String)\n    //callback can be the property name\n    {\n      if (!options) options = {};\n      options.property = callback;\n      callback = null;\n    }\n  if (callback && callback.constructor !== Function) {\n    console.warn(\"addWidget: callback must be a function\");\n    callback = null;\n  }\n  var w = {\n    type: type.toLowerCase(),\n    name: name,\n    value: value,\n    callback: callback,\n    options: options || {}\n  };\n  if (w.options.y !== undefined) {\n    w.y = w.options.y;\n  }\n  if (!callback && !w.options.callback && !w.options.property) {\n    console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\");\n  }\n  if (type == \"combo\" && !w.options.values) {\n    throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\";\n  }\n  this.widgets.push(w);\n  this.setSize(this.computeSize());\n  return w;\n};\nLGraphNode.prototype.addCustomWidget = function (custom_widget) {\n  if (!this.widgets) {\n    this.widgets = [];\n  }\n  this.widgets.push(custom_widget);\n  return custom_widget;\n};\n\n/**\n * returns the bounding of the object, used for rendering purposes\n * @method getBounding\n * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage\n * @param compute_outer {boolean?} [optional] set to true to include the shadow and connection points in the bounding calculation\n * @return {Float32Array[4]} the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]\n */\nLGraphNode.prototype.getBounding = function (out, compute_outer) {\n  out = out || new Float32Array(4);\n  const nodePos = this.pos;\n  const isCollapsed = this.flags.collapsed;\n  const nodeSize = this.size;\n  let left_offset = 0;\n  // 1 offset due to how nodes are rendered\n  let right_offset = 1;\n  let top_offset = 0;\n  let bottom_offset = 0;\n  if (compute_outer) {\n    // 4 offset for collapsed node connection points\n    left_offset = 4;\n    // 6 offset for right shadow and collapsed node connection points\n    right_offset = 6 + left_offset;\n    // 4 offset for collapsed nodes top connection points\n    top_offset = 4;\n    // 5 offset for bottom shadow and collapsed node connection points\n    bottom_offset = 5 + top_offset;\n  }\n  out[0] = nodePos[0] - left_offset;\n  out[1] = nodePos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT - top_offset;\n  out[2] = isCollapsed ? (this._collapsed_width || NODE_COLLAPSED_WIDTH) + right_offset : nodeSize[0] + right_offset;\n  out[3] = isCollapsed ? _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT + bottom_offset : nodeSize[1] + _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT + bottom_offset;\n  if (this.onBounding) {\n    this.onBounding(out);\n  }\n  return out;\n};\n\n/**\n * checks if a point is inside the shape of a node\n * @method isPointInside\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nLGraphNode.prototype.isPointInside = function (x, y, margin, skip_title) {\n  margin = margin || 0;\n  var margin_top = this.graph && this.graph.isLive() ? 0 : _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT;\n  if (skip_title) {\n    margin_top = 0;\n  }\n  if (this.flags && this.flags.collapsed) {\n    if (isInsideRectangle(x, y, this.pos[0] - margin, this.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT - margin, (this._collapsed_width || NODE_COLLAPSED_WIDTH) + 2 * margin, _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT + 2 * margin)) {\n      return true;\n    }\n  } else if (this.pos[0] - 4 - margin < x && this.pos[0] + this.size[0] + 4 + margin > x && this.pos[1] - margin_top - margin < y && this.pos[1] + this.size[1] + margin > y) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * checks if a point is inside a node slot, and returns info about which slot\n * @method getSlotInPosition\n * @param {number} x\n * @param {number} y\n * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }\n */\nLGraphNode.prototype.getSlotInPosition = function (x, y) {\n  //search for inputs\n  var link_pos = new Float32Array(2);\n  if (this.inputs) {\n    for (var i = 0, l = this.inputs.length; i < l; ++i) {\n      var input = this.inputs[i];\n      this.getConnectionPos(true, i, link_pos);\n      if (isInsideRectangle(x, y, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {\n        return {\n          input: input,\n          slot: i,\n          link_pos: link_pos\n        };\n      }\n    }\n  }\n  if (this.outputs) {\n    for (var i = 0, l = this.outputs.length; i < l; ++i) {\n      var output = this.outputs[i];\n      this.getConnectionPos(false, i, link_pos);\n      if (isInsideRectangle(x, y, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {\n        return {\n          output: output,\n          slot: i,\n          link_pos: link_pos\n        };\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * returns the input slot with a given name (used for dynamic slots), -1 if not found\n * @method findInputSlot\n * @param {string} name the name of the slot\n * @param {boolean} returnObj if the obj itself wanted\n * @return {number_or_object} the slot (-1 if not found)\n */\nLGraphNode.prototype.findInputSlot = function (name, returnObj) {\n  if (!this.inputs) {\n    return -1;\n  }\n  for (var i = 0, l = this.inputs.length; i < l; ++i) {\n    if (name == this.inputs[i].name) {\n      return !returnObj ? i : this.inputs[i];\n    }\n  }\n  return -1;\n};\n\n/**\n * returns the output slot with a given name (used for dynamic slots), -1 if not found\n * @method findOutputSlot\n * @param {string} name the name of the slot\n * @param {boolean} returnObj if the obj itself wanted\n * @return {number_or_object} the slot (-1 if not found)\n */\nLGraphNode.prototype.findOutputSlot = function (name, returnObj) {\n  returnObj = returnObj || false;\n  if (!this.outputs) {\n    return -1;\n  }\n  for (var i = 0, l = this.outputs.length; i < l; ++i) {\n    if (name == this.outputs[i].name) {\n      return !returnObj ? i : this.outputs[i];\n    }\n  }\n  return -1;\n};\n\n// TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options\n\n/**\n * returns the first free input slot\n * @method findInputSlotFree\n * @param {object} options\n * @return {number_or_object} the slot (-1 if not found)\n */\nLGraphNode.prototype.findInputSlotFree = function (optsIn) {\n  var optsIn = optsIn || {};\n  var optsDef = {\n    returnObj: false,\n    typesNotAccepted: []\n  };\n  var opts = Object.assign(optsDef, optsIn);\n  if (!this.inputs) {\n    return -1;\n  }\n  for (var i = 0, l = this.inputs.length; i < l; ++i) {\n    if (this.inputs[i].link && this.inputs[i].link != null) {\n      continue;\n    }\n    if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i].type)) {\n      continue;\n    }\n    return !opts.returnObj ? i : this.inputs[i];\n  }\n  return -1;\n};\n\n/**\n * returns the first output slot free\n * @method findOutputSlotFree\n * @param {object} options\n * @return {number_or_object} the slot (-1 if not found)\n */\nLGraphNode.prototype.findOutputSlotFree = function (optsIn) {\n  var optsIn = optsIn || {};\n  var optsDef = {\n    returnObj: false,\n    typesNotAccepted: []\n  };\n  var opts = Object.assign(optsDef, optsIn);\n  if (!this.outputs) {\n    return -1;\n  }\n  for (var i = 0, l = this.outputs.length; i < l; ++i) {\n    if (this.outputs[i].links && this.outputs[i].links != null) {\n      continue;\n    }\n    if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i].type)) {\n      continue;\n    }\n    return !opts.returnObj ? i : this.outputs[i];\n  }\n  return -1;\n};\n\n/**\n * findSlotByType for INPUTS\n */\nLGraphNode.prototype.findInputSlotByType = function (type, returnObj, preferFreeSlot, doNotUseOccupied) {\n  return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);\n};\n\n/**\n * findSlotByType for OUTPUTS\n */\nLGraphNode.prototype.findOutputSlotByType = function (type, returnObj, preferFreeSlot, doNotUseOccupied) {\n  return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);\n};\n\n/**\n * returns the output (or input) slot with a given type, -1 if not found\n * @method findSlotByType\n * @param {boolean} input uise inputs instead of outputs\n * @param {string} type the type of the slot\n * @param {boolean} returnObj if the obj itself wanted\n * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)\n * @return {number_or_object} the slot (-1 if not found)\n */\nLGraphNode.prototype.findSlotByType = function (input, type, returnObj, preferFreeSlot, doNotUseOccupied) {\n  input = input || false;\n  returnObj = returnObj || false;\n  preferFreeSlot = preferFreeSlot || false;\n  doNotUseOccupied = doNotUseOccupied || false;\n  var aSlots = input ? this.inputs : this.outputs;\n  if (!aSlots) {\n    return -1;\n  }\n  // !! empty string type is considered 0, * !!\n  if (type == \"\" || type == \"*\") type = 0;\n  for (var i = 0, l = aSlots.length; i < l; ++i) {\n    var tFound = false;\n    var aSource = (type + \"\").toLowerCase().split(\",\");\n    var aDest = aSlots[i].type == \"0\" || aSlots[i].type == \"*\" ? \"0\" : aSlots[i].type;\n    aDest = (aDest + \"\").toLowerCase().split(\",\");\n    for (var sI = 0; sI < aSource.length; sI++) {\n      for (var dI = 0; dI < aDest.length; dI++) {\n        if (aSource[sI] == \"_event_\") aSource[sI] = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT;\n        if (aDest[sI] == \"_event_\") aDest[sI] = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT;\n        if (aSource[sI] == \"*\") aSource[sI] = 0;\n        if (aDest[sI] == \"*\") aDest[sI] = 0;\n        if (aSource[sI] == aDest[dI]) {\n          if (preferFreeSlot && aSlots[i].links && aSlots[i].links !== null) continue;\n          return !returnObj ? i : aSlots[i];\n        }\n      }\n    }\n  }\n  // if didnt find some, stop checking for free slots\n  if (preferFreeSlot && !doNotUseOccupied) {\n    for (var i = 0, l = aSlots.length; i < l; ++i) {\n      var tFound = false;\n      var aSource = (type + \"\").toLowerCase().split(\",\");\n      var aDest = aSlots[i].type == \"0\" || aSlots[i].type == \"*\" ? \"0\" : aSlots[i].type;\n      aDest = (aDest + \"\").toLowerCase().split(\",\");\n      for (var sI = 0; sI < aSource.length; sI++) {\n        for (var dI = 0; dI < aDest.length; dI++) {\n          if (aSource[sI] == \"*\") aSource[sI] = 0;\n          if (aDest[sI] == \"*\") aDest[sI] = 0;\n          if (aSource[sI] == aDest[dI]) {\n            return !returnObj ? i : aSlots[i];\n          }\n        }\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * connect this node output to the input of another node BY TYPE\n * @method connectByType\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @param {LGraphNode} node the target node\n * @param {string} target_type the input slot type of the target node\n * @return {Object} the link_info is created, otherwise null\n */\nLGraphNode.prototype.connectByType = function (slot, target_node, target_slotType, optsIn) {\n  var optsIn = optsIn || {};\n  var optsDef = {\n    createEventInCase: true,\n    firstFreeIfOutputGeneralInCase: true,\n    generalTypeInCase: true\n  };\n  var opts = Object.assign(optsDef, optsIn);\n  if (target_node && target_node.constructor === Number) {\n    target_node = this.graph.getNodeById(target_node);\n  }\n  var target_slot = target_node.findInputSlotByType(target_slotType, false, true);\n  if (target_slot >= 0 && target_slot !== null) {\n    //console.debug(\"CONNbyTYPE type \"+target_slotType+\" for \"+target_slot)\n    return this.connect(slot, target_node, target_slot);\n  } else {\n    //console.log(\"type \"+target_slotType+\" not found or not free?\")\n    if (opts.createEventInCase && target_slotType == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT) {\n      // WILL CREATE THE onTrigger IN SLOT\n      //console.debug(\"connect WILL CREATE THE onTrigger \"+target_slotType+\" to \"+target_node);\n      return this.connect(slot, target_node, -1);\n    }\n    // connect to the first general output slot if not found a specific type and \n    if (opts.generalTypeInCase) {\n      var target_slot = target_node.findInputSlotByType(0, false, true, true);\n      //console.debug(\"connect TO a general type (*, 0), if not found the specific type \",target_slotType,\" to \",target_node,\"RES_SLOT:\",target_slot);\n      if (target_slot >= 0) {\n        return this.connect(slot, target_node, target_slot);\n      }\n    }\n    // connect to the first free input slot if not found a specific type and this output is general\n    if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == \"*\" || target_slotType == \"\")) {\n      var target_slot = target_node.findInputSlotFree({\n        typesNotAccepted: [_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT]\n      });\n      //console.debug(\"connect TO TheFirstFREE \",target_slotType,\" to \",target_node,\"RES_SLOT:\",target_slot);\n      if (target_slot >= 0) {\n        return this.connect(slot, target_node, target_slot);\n      }\n    }\n    console.debug(\"no way to connect type: \", target_slotType, \" to targetNODE \", target_node);\n    //TODO filter\n\n    return null;\n  }\n};\n\n/**\n * connect this node input to the output of another node BY TYPE\n * @method connectByType\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @param {LGraphNode} node the target node\n * @param {string} target_type the output slot type of the target node\n * @return {Object} the link_info is created, otherwise null\n */\nLGraphNode.prototype.connectByTypeOutput = function (slot, source_node, source_slotType, optsIn) {\n  var optsIn = optsIn || {};\n  var optsDef = {\n    createEventInCase: true,\n    firstFreeIfInputGeneralInCase: true,\n    generalTypeInCase: true\n  };\n  var opts = Object.assign(optsDef, optsIn);\n  if (source_node && source_node.constructor === Number) {\n    source_node = this.graph.getNodeById(source_node);\n  }\n  var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);\n  if (source_slot >= 0 && source_slot !== null) {\n    //console.debug(\"CONNbyTYPE OUT! type \"+source_slotType+\" for \"+source_slot)\n    return source_node.connect(source_slot, this, slot);\n  } else {\n    // connect to the first general output slot if not found a specific type and \n    if (opts.generalTypeInCase) {\n      var source_slot = source_node.findOutputSlotByType(0, false, true, true);\n      if (source_slot >= 0) {\n        return source_node.connect(source_slot, this, slot);\n      }\n    }\n    if (opts.createEventInCase && source_slotType == _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT) {\n      // WILL CREATE THE onExecuted OUT SLOT\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.do_add_triggers_slots) {\n        var source_slot = source_node.addOnExecutedOutput();\n        return source_node.connect(source_slot, this, slot);\n      }\n    }\n    // connect to the first free output slot if not found a specific type and this input is general\n    if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == \"*\" || source_slotType == \"\")) {\n      var source_slot = source_node.findOutputSlotFree({\n        typesNotAccepted: [_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT]\n      });\n      if (source_slot >= 0) {\n        return source_node.connect(source_slot, this, slot);\n      }\n    }\n    console.debug(\"no way to connect byOUT type: \", source_slotType, \" to sourceNODE \", source_node);\n    //TODO filter\n\n    //console.log(\"type OUT! \"+source_slotType+\" not found or not free?\")\n    return null;\n  }\n};\n\n/**\n * connect this node output to the input of another node\n * @method connect\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @param {LGraphNode} node the target node\n * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)\n * @return {Object} the link_info is created, otherwise null\n */\nLGraphNode.prototype.connect = function (slot, target_node, target_slot) {\n  target_slot = target_slot || 0;\n  if (!this.graph) {\n    //could be connected before adding it to a graph\n    console.log(\"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\"); //due to link ids being associated with graphs\n    return null;\n  }\n\n  //seek for the output slot\n  if (slot.constructor === String) {\n    slot = this.findOutputSlot(slot);\n    if (slot == -1) {\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n        console.log(\"Connect: Error, no slot of name \" + slot);\n      }\n      return null;\n    }\n  } else if (!this.outputs || slot >= this.outputs.length) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n      console.log(\"Connect: Error, slot number not found\");\n    }\n    return null;\n  }\n  if (target_node && target_node.constructor === Number) {\n    target_node = this.graph.getNodeById(target_node);\n  }\n  if (!target_node) {\n    throw \"target node is null\";\n  }\n\n  //avoid loopback\n  if (target_node == this) {\n    return null;\n  }\n\n  //you can specify the slot by name\n  if (target_slot.constructor === String) {\n    target_slot = target_node.findInputSlot(target_slot);\n    if (target_slot == -1) {\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n        console.log(\"Connect: Error, no slot of name \" + target_slot);\n      }\n      return null;\n    }\n  } else if (target_slot === _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.do_add_triggers_slots) {\n      //search for first slot with event? :: NO this is done outside\n      //console.log(\"Connect: Creating triggerEvent\");\n      // force mode\n      target_node.changeMode(_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ON_TRIGGER);\n      target_slot = target_node.findInputSlot(\"onTrigger\");\n    } else {\n      return null; // -- break --\n    }\n  } else if (!target_node.inputs || target_slot >= target_node.inputs.length) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n      console.log(\"Connect: Error, slot number not found\");\n    }\n    return null;\n  }\n  var changed = false;\n  var input = target_node.inputs[target_slot];\n  var link_info = null;\n  var output = this.outputs[slot];\n  if (!this.outputs[slot]) {\n    /*console.debug(\"Invalid slot passed: \"+slot);\n    console.debug(this.outputs);*/\n    return null;\n  }\n\n  // allow target node to change slot\n  if (target_node.onBeforeConnectInput) {\n    // This way node can choose another slot (or make a new one?)\n    target_slot = target_node.onBeforeConnectInput(target_slot); //callback\n  }\n\n  //check target_slot and check connection types\n  if (target_slot === false || target_slot === null || !_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.isValidConnection(output.type, input.type)) {\n    this.setDirtyCanvas(false, true);\n    if (changed) this.graph.connectionChange(this, link_info);\n    return null;\n  } else {\n    //console.debug(\"valid connection\",output.type, input.type);\n  }\n\n  //allows nodes to block connection, callback\n  if (target_node.onConnectInput) {\n    if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {\n      return null;\n    }\n  }\n  if (this.onConnectOutput) {\n    // callback\n    if (this.onConnectOutput(slot, input.type, input, target_node, target_slot) === false) {\n      return null;\n    }\n  }\n\n  //if there is something already plugged there, disconnect\n  if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {\n    this.graph.beforeChange();\n    target_node.disconnectInput(target_slot, {\n      doProcessChange: false\n    });\n    changed = true;\n  }\n  if (output.links !== null && output.links.length) {\n    switch (output.type) {\n      case _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.EVENT:\n        if (!_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.allow_multi_output_for_events) {\n          this.graph.beforeChange();\n          this.disconnectOutput(slot, false, {\n            doProcessChange: false\n          }); // Input(target_slot, {doProcessChange: false});\n          changed = true;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  var nextId;\n  if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.use_uuids) nextId = (0,_libs_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();else nextId = ++this.graph.last_link_id;\n\n  //create link class\n  link_info = new _l_link_js__WEBPACK_IMPORTED_MODULE_2__.LLink(nextId, input.type || output.type, this.id, slot, target_node.id, target_slot);\n\n  //add to graph links list\n  this.graph.links[link_info.id] = link_info;\n\n  //connect in output\n  if (output.links == null) {\n    output.links = [];\n  }\n  output.links.push(link_info.id);\n  //connect in input\n  target_node.inputs[target_slot].link = link_info.id;\n  if (this.graph) {\n    this.graph._version++;\n  }\n  if (this.onConnectionsChange) {\n    this.onConnectionsChange(IN_OUT_PUT.OUTPUT, slot, true, link_info, output);\n  } //link_info has been created now, so its updated\n  if (target_node.onConnectionsChange) {\n    target_node.onConnectionsChange(IN_OUT_PUT.INPUT, target_slot, true, link_info, input);\n  }\n  if (this.graph && this.graph.onNodeConnectionChange) {\n    this.graph.onNodeConnectionChange(IN_OUT_PUT.INPUT, target_node, target_slot, this, slot);\n    this.graph.onNodeConnectionChange(IN_OUT_PUT.OUTPUT, this, slot, target_node, target_slot);\n  }\n  this.setDirtyCanvas(false, true);\n  this.graph.afterChange();\n  this.graph.connectionChange(this, link_info);\n  return link_info;\n};\n\n/**\n * disconnect one output to an specific node\n * @method disconnectOutput\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]\n * @return {boolean} if it was disconnected successfully\n */\nLGraphNode.prototype.disconnectOutput = function (slot, target_node) {\n  if (slot.constructor === String) {\n    slot = this.findOutputSlot(slot);\n    if (slot == -1) {\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n        console.log(\"Connect: Error, no slot of name \" + slot);\n      }\n      return false;\n    }\n  } else if (!this.outputs || slot >= this.outputs.length) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n      console.log(\"Connect: Error, slot number not found\");\n    }\n    return false;\n  }\n\n  //get output slot\n  var output = this.outputs[slot];\n  if (!output || !output.links || output.links.length == 0) {\n    return false;\n  }\n\n  //one of the output links in this slot\n  if (target_node) {\n    if (target_node.constructor === Number) {\n      target_node = this.graph.getNodeById(target_node);\n    }\n    if (!target_node) {\n      throw \"Target Node not found\";\n    }\n    for (var i = 0, l = output.links.length; i < l; i++) {\n      var link_id = output.links[i];\n      var link_info = this.graph.links[link_id];\n\n      //is the link we are searching for...\n      if (link_info.target_id == target_node.id) {\n        output.links.splice(i, 1); //remove here\n        var input = target_node.inputs[link_info.target_slot];\n        input.link = null; //remove there\n        delete this.graph.links[link_id]; //remove the link from the links pool\n        if (this.graph) {\n          this.graph._version++;\n        }\n        if (target_node.onConnectionsChange) {\n          target_node.onConnectionsChange(IN_OUT_PUT.INPUT, link_info.target_slot, false, link_info, input);\n        } //link_info hasn't been modified so its ok\n        if (this.onConnectionsChange) {\n          this.onConnectionsChange(IN_OUT_PUT.OUTPUT, slot, false, link_info, output);\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n          this.graph.onNodeConnectionChange(IN_OUT_PUT.OUTPUT, this, slot);\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n          this.graph.onNodeConnectionChange(IN_OUT_PUT.OUTPUT, this, slot);\n          this.graph.onNodeConnectionChange(IN_OUT_PUT.INPUT, target_node, link_info.target_slot);\n        }\n        break;\n      }\n    }\n  } //all the links in this output slot\n  else {\n    for (var i = 0, l = output.links.length; i < l; i++) {\n      var link_id = output.links[i];\n      var link_info = this.graph.links[link_id];\n      if (!link_info) {\n        //bug: it happens sometimes\n        continue;\n      }\n      var target_node = this.graph.getNodeById(link_info.target_id);\n      var input = null;\n      if (this.graph) {\n        this.graph._version++;\n      }\n      if (target_node) {\n        input = target_node.inputs[link_info.target_slot];\n        input.link = null; //remove other side link\n        if (target_node.onConnectionsChange) {\n          target_node.onConnectionsChange(IN_OUT_PUT.INPUT, link_info.target_slot, false, link_info, input);\n        } //link_info hasn't been modified so its ok\n        if (this.graph && this.graph.onNodeConnectionChange) {\n          this.graph.onNodeConnectionChange(IN_OUT_PUT.INPUT, target_node, link_info.target_slot);\n        }\n      }\n      delete this.graph.links[link_id]; //remove the link from the links pool\n      if (this.onConnectionsChange) {\n        this.onConnectionsChange(IN_OUT_PUT.OUTPUT, slot, false, link_info, output);\n      }\n      if (this.graph && this.graph.onNodeConnectionChange) {\n        this.graph.onNodeConnectionChange(IN_OUT_PUT.OUTPUT, this, slot);\n        this.graph.onNodeConnectionChange(IN_OUT_PUT.INPUT, target_node, link_info.target_slot);\n      }\n    }\n    output.links = null;\n  }\n  this.setDirtyCanvas(false, true);\n  this.graph.connectionChange(this);\n  return true;\n};\n\n/**\n * disconnect one input\n * @method disconnectInput\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @return {boolean} if it was disconnected successfully\n */\nLGraphNode.prototype.disconnectInput = function (slot) {\n  //seek for the output slot\n  if (slot.constructor === String) {\n    slot = this.findInputSlot(slot);\n    if (slot == -1) {\n      if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n        console.log(\"Connect: Error, no slot of name \" + slot);\n      }\n      return false;\n    }\n  } else if (!this.inputs || slot >= this.inputs.length) {\n    if (_litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.debug) {\n      console.log(\"Connect: Error, slot number not found\");\n    }\n    return false;\n  }\n  var input = this.inputs[slot];\n  if (!input) {\n    return false;\n  }\n  var link_id = this.inputs[slot].link;\n  if (link_id != null) {\n    this.inputs[slot].link = null;\n\n    //remove other side\n    var link_info = this.graph.links[link_id];\n    if (link_info) {\n      var target_node = this.graph.getNodeById(link_info.origin_id);\n      if (!target_node) {\n        return false;\n      }\n      var output = target_node.outputs[link_info.origin_slot];\n      if (!output || !output.links || output.links.length == 0) {\n        return false;\n      }\n\n      //search in the inputs list for this link\n      for (var i = 0, l = output.links.length; i < l; i++) {\n        if (output.links[i] == link_id) {\n          output.links.splice(i, 1);\n          break;\n        }\n      }\n      delete this.graph.links[link_id]; //remove from the pool\n      if (this.graph) {\n        this.graph._version++;\n      }\n      if (this.onConnectionsChange) {\n        this.onConnectionsChange(IN_OUT_PUT.INPUT, slot, false, link_info, input);\n      }\n      if (target_node.onConnectionsChange) {\n        target_node.onConnectionsChange(IN_OUT_PUT.OUTPUT, i, false, link_info, output);\n      }\n      if (this.graph && this.graph.onNodeConnectionChange) {\n        this.graph.onNodeConnectionChange(IN_OUT_PUT.OUTPUT, target_node, i);\n        this.graph.onNodeConnectionChange(IN_OUT_PUT.INPUT, this, slot);\n      }\n    }\n  } //link != null\n\n  this.setDirtyCanvas(false, true);\n  if (this.graph) this.graph.connectionChange(this);\n  return true;\n};\n\n/**\n * returns the center of a connection point in canvas coords\n * @method getConnectionPos\n * @param {boolean} is_input true if if a input slot, false if it is an output\n * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n * @param {vec2} out [optional] a place to store the output, to free garbage\n * @return {[x,y]} the position\n **/\nLGraphNode.prototype.getConnectionPos = function (is_input, slot_number, out) {\n  out = out || new Float32Array(2);\n  var num_slots = 0;\n  if (is_input && this.inputs) {\n    num_slots = this.inputs.length;\n  }\n  if (!is_input && this.outputs) {\n    num_slots = this.outputs.length;\n  }\n  var offset = _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_SLOT_HEIGHT * 0.5;\n  if (this.flags.collapsed) {\n    var w = this._collapsed_width || NODE_COLLAPSED_WIDTH;\n    if (this.horizontal) {\n      out[0] = this.pos[0] + w * 0.5;\n      if (is_input) {\n        out[1] = this.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT;\n      } else {\n        out[1] = this.pos[1];\n      }\n    } else {\n      if (is_input) {\n        out[0] = this.pos[0];\n      } else {\n        out[0] = this.pos[0] + w;\n      }\n      out[1] = this.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT * 0.5;\n    }\n    return out;\n  }\n\n  //weird feature that never got finished\n  if (is_input && slot_number == -1) {\n    out[0] = this.pos[0] + _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT * 0.5;\n    out[1] = this.pos[1] + _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT * 0.5;\n    return out;\n  }\n\n  //hard-coded pos\n  if (is_input && num_slots > slot_number && this.inputs[slot_number].pos) {\n    out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n    out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n    return out;\n  } else if (!is_input && num_slots > slot_number && this.outputs[slot_number].pos) {\n    out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n    out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n    return out;\n  }\n\n  //horizontal distributed slots\n  if (this.horizontal) {\n    out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n    if (is_input) {\n      out[1] = this.pos[1] - _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TITLE_HEIGHT;\n    } else {\n      out[1] = this.pos[1] + this.size[1];\n    }\n    return out;\n  }\n\n  //default vertical slots\n  if (is_input) {\n    out[0] = this.pos[0] + offset;\n  } else {\n    out[0] = this.pos[0] + this.size[0] + 1 - offset;\n  }\n  out[1] = this.pos[1] + (slot_number + 0.7) * _settings_js__WEBPACK_IMPORTED_MODULE_3__.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);\n  return out;\n};\n\n/* Force align to grid */\nLGraphNode.prototype.alignToGrid = function () {\n  this.pos[0] = _settings_js__WEBPACK_IMPORTED_MODULE_3__.CANVAS_GRID_SIZE * Math.round(this.pos[0] / _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.CANVAS_GRID_SIZE);\n  this.pos[1] = _settings_js__WEBPACK_IMPORTED_MODULE_3__.CANVAS_GRID_SIZE * Math.round(this.pos[1] / _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.CANVAS_GRID_SIZE);\n};\n\n/* Console output */\nLGraphNode.prototype.trace = function (msg) {\n  if (!this.console) {\n    this.console = [];\n  }\n  this.console.push(msg);\n  if (this.console.length > LGraphNode.MAX_CONSOLE) {\n    this.console.shift();\n  }\n  if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n};\n\n/* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\nLGraphNode.prototype.setDirtyCanvas = function (dirty_foreground, dirty_background) {\n  if (!this.graph) {\n    return;\n  }\n  this.graph.sendActionToCanvas(\"setDirty\", [dirty_foreground, dirty_background]);\n};\nLGraphNode.prototype.loadImage = function (url) {\n  var img = new Image();\n  img.src = _litegraph_class_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.node_images_path + url;\n  img.ready = false;\n  var that = this;\n  img.onload = function () {\n    this.ready = true;\n    that.setDirtyCanvas(true);\n  };\n  return img;\n};\n\n//safe LGraphNode action execution (not sure if safe)\n/*\nLGraphNode.prototype.executeAction = function(action)\n{\nif(action == \"\") return false;\n\nif( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\n{\n    this.trace(\"Error: Action contains unsafe characters\");\n    return false;\n}\n\nvar tokens = action.split(\"(\");\nvar func_name = tokens[0];\nif( typeof(this[func_name]) != \"function\")\n{\n    this.trace(\"Error: Action not found on node: \" + func_name);\n    return false;\n}\n\nvar code = action;\n\ntry\n{\n    var _foo = eval;\n    eval = null;\n    (new Function(\"with(this) { \" + code + \"}\")).call(this);\n    eval = _foo;\n}\ncatch (err)\n{\n    this.trace(\"Error executing action {\" + action + \"} :\" + err);\n    return false;\n}\n\nreturn true;\n}\n*/\n\n/* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\nLGraphNode.prototype.captureInput = function (v) {\n  if (!this.graph || !this.graph.list_of_graphcanvas) {\n    return;\n  }\n  var list = this.graph.list_of_graphcanvas;\n  for (var i = 0; i < list.length; ++i) {\n    var c = list[i];\n    //releasing somebody elses capture?!\n    if (!v && c.node_capturing_input != this) {\n      continue;\n    }\n\n    //change\n    c.node_capturing_input = v ? this : null;\n  }\n};\n\n/**\n * Collapse the node to make it smaller on the canvas\n * @method collapse\n **/\nLGraphNode.prototype.collapse = function (force) {\n  this.graph._version++;\n  if (this.constructor.collapsable === false && !force) {\n    return;\n  }\n  if (!this.flags.collapsed) {\n    this.flags.collapsed = true;\n  } else {\n    this.flags.collapsed = false;\n  }\n  this.setDirtyCanvas(true, true);\n};\n\n/**\n * Forces the node to do not move or realign on Z\n * @method pin\n **/\n\nLGraphNode.prototype.pin = function (v) {\n  this.graph._version++;\n  if (v === undefined) {\n    this.flags.pinned = !this.flags.pinned;\n  } else {\n    this.flags.pinned = v;\n  }\n};\nLGraphNode.prototype.localToScreen = function (x, y, graphcanvas) {\n  return [(x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0], (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]];\n};\nfunction isInsideRectangle(x, y, left, top, width, height) {\n  if (left < x && left + width > x && top < y && top + height > y) {\n    return true;\n  }\n  return false;\n}\nfunction distance(a, b) {\n  return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));\n}\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/l_graph_node.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/l_link.js":
/*!*************************************************!*\
  !*** ./members/GraphRender/litegraph/l_link.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLink: () => (/* binding */ LLink)\n/* harmony export */ });\n//this is the class in charge of storing link information\nfunction LLink(id, type, origin_id, origin_slot, target_id, target_slot) {\n  this.id = id;\n  this.type = type;\n  this.origin_id = origin_id;\n  this.origin_slot = origin_slot;\n  this.target_id = target_id;\n  this.target_slot = target_slot;\n  this._data = null;\n  this._pos = new Float32Array(2); //center\n}\nLLink.prototype.configure = function (o) {\n  if (o.constructor === Array) {\n    this.id = o[0];\n    this.origin_id = o[1];\n    this.origin_slot = o[2];\n    this.target_id = o[3];\n    this.target_slot = o[4];\n    this.type = o[5];\n  } else {\n    this.id = o.id;\n    this.type = o.type;\n    this.origin_id = o.origin_id;\n    this.origin_slot = o.origin_slot;\n    this.target_id = o.target_id;\n    this.target_slot = o.target_slot;\n  }\n};\nLLink.prototype.serialize = function () {\n  return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type];\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/l_link.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/libs.js":
/*!***********************************************!*\
  !*** ./members/GraphRender/litegraph/libs.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneObject: () => (/* binding */ cloneObject),\n/* harmony export */   getTime: () => (/* binding */ getTime),\n/* harmony export */   pointerListenerAdd: () => (/* binding */ pointerListenerAdd),\n/* harmony export */   pointerListenerRemove: () => (/* binding */ pointerListenerRemove),\n/* harmony export */   pointerevents_method: () => (/* binding */ pointerevents_method),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4)\n/* harmony export */ });\n//separated just to improve if it doesn't work\nfunction cloneObject(obj, target) {\n  if (obj == null) {\n    return null;\n  }\n  var r = JSON.parse(JSON.stringify(obj));\n  if (!target) {\n    return r;\n  }\n  for (var i in r) {\n    target[i] = r[i];\n  }\n  return target;\n}\n\n/*\n* https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670\n*/\nfunction uuidv4() {\n  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, a => (a ^ Math.random() * 16 >> a / 4).toString(16));\n}\nlet iGetTime;\n//timer that works everywhere\nif (typeof performance != \"undefined\") {\n  iGetTime = performance.now.bind(performance);\n} else if (typeof Date != \"undefined\" && Date.now) {\n  iGetTime = Date.now.bind(Date);\n} else if (typeof process != \"undefined\") {\n  iGetTime = function () {\n    var t = process.hrtime();\n    return t[0] * 0.001 + t[1] * 1e-6;\n  };\n} else {\n  iGetTime = function getTime() {\n    return new Date().getTime();\n  };\n}\nconst getTime = iGetTime;\n\n/* helper for interaction: pointer, touch, mouse Listeners\nused by LGraphCanvas DragAndScale ContextMenu*/\nconst pointerevents_method = \"mouse\"; // \"mouse\"|\"pointer\" use mouse for retrocompatibility issues? (none found @ now)\n// TODO implement pointercancel, gotpointercapture, lostpointercapture, (pointerover, pointerout if necessary)\n\nfunction pointerListenerAdd(oDOM, sEvIn, fCall, capture = false) {\n  if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== \"function\") {\n    //console.log(\"cant pointerListenerAdd \"+oDOM+\", \"+sEvent+\", \"+fCall);\n    return; // -- break --\n  }\n  var sMethod = pointerevents_method;\n  var sEvent = sEvIn;\n\n  // UNDER CONSTRUCTION\n  // convert pointerevents to touch event when not available\n  if (sMethod == \"pointer\" && !window.PointerEvent) {\n    console.warn(\"sMethod=='pointer' && !window.PointerEvent\");\n    console.log(\"Converting pointer[\" + sEvent + \"] : down move up cancel enter TO touchstart touchmove touchend, etc ..\");\n    switch (sEvent) {\n      case \"down\":\n        {\n          sMethod = \"touch\";\n          sEvent = \"start\";\n          break;\n        }\n      case \"move\":\n        {\n          sMethod = \"touch\";\n          //sEvent = \"move\";\n          break;\n        }\n      case \"up\":\n        {\n          sMethod = \"touch\";\n          sEvent = \"end\";\n          break;\n        }\n      case \"cancel\":\n        {\n          sMethod = \"touch\";\n          //sEvent = \"cancel\";\n          break;\n        }\n      case \"enter\":\n        {\n          console.log(\"debug: Should I send a move event?\"); // ???\n          break;\n        }\n      // case \"over\": case \"out\": not used at now\n      default:\n        {\n          console.warn(\"PointerEvent not available in this browser ? The event \" + sEvent + \" would not be called\");\n        }\n    }\n  }\n  switch (sEvent) {\n    //both pointer and move events\n    case \"down\":\n    case \"up\":\n    case \"move\":\n    case \"over\":\n    case \"out\":\n    case \"enter\":\n      {\n        oDOM.addEventListener(sMethod + sEvent, fCall, capture);\n      }\n    // only pointerevents\n    case \"leave\":\n    case \"cancel\":\n    case \"gotpointercapture\":\n    case \"lostpointercapture\":\n      {\n        if (sMethod != \"mouse\") {\n          return oDOM.addEventListener(sMethod + sEvent, fCall, capture);\n        }\n      }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.addEventListener(sEvent, fCall, capture);\n  }\n}\nfunction pointerListenerRemove(oDOM, sEvent, fCall, capture = false) {\n  if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== \"function\") {\n    //console.log(\"cant pointerListenerRemove \"+oDOM+\", \"+sEvent+\", \"+fCall);\n    return; // -- break --\n  }\n  switch (sEvent) {\n    //both pointer and move events\n    case \"down\":\n    case \"up\":\n    case \"move\":\n    case \"over\":\n    case \"out\":\n    case \"enter\":\n      {\n        if (pointerevents_method == \"pointer\" || pointerevents_method == \"mouse\") {\n          oDOM.removeEventListener(pointerevents_method + sEvent, fCall, capture);\n        }\n      }\n    // only pointerevents\n    case \"leave\":\n    case \"cancel\":\n    case \"gotpointercapture\":\n    case \"lostpointercapture\":\n      {\n        if (pointerevents_method == \"pointer\") {\n          return oDOM.removeEventListener(pointerevents_method + sEvent, fCall, capture);\n        }\n      }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.removeEventListener(sEvent, fCall, capture);\n  }\n}\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/libs.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/litegraph_class.js":
/*!**********************************************************!*\
  !*** ./members/GraphRender/litegraph/litegraph_class.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiteGraph: () => (/* binding */ LiteGraph)\n/* harmony export */ });\n/* harmony import */ var _l_graph_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./l_graph_node.js */ \"./members/GraphRender/litegraph/l_graph_node.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"./members/GraphRender/litegraph/settings.js\");\n\n\n\n// *************************************************************\n//   LiteGraph CLASS                                     *******\n// *************************************************************\n\n/**\n * The Global Scope. It contains all the registered node classes.\n *\n * @class LiteGraph\n * @constructor\n */\n\nvar LiteGraph = {\n  DEFAULT_SHADOW_COLOR: \"rgba(0,0,0,0.5)\",\n  DEFAULT_GROUP_FONT: 24,\n  WIDGET_BGCOLOR: \"#222\",\n  WIDGET_OUTLINE_COLOR: \"#666\",\n  WIDGET_TEXT_COLOR: \"#DDD\",\n  WIDGET_SECONDARY_TEXT_COLOR: \"#999\",\n  LINK_COLOR: \"#9A9\",\n  EVENT_LINK_COLOR: \"#A86\",\n  CONNECTING_LINK_COLOR: \"#AFA\",\n  MAX_NUMBER_OF_NODES: 1000,\n  //avoid infinite loops\n  DEFAULT_POSITION: [100, 100],\n  //default node position\n  VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"],\n  //,\"circle\"\n\n  EVENT: -1,\n  //for outputs\n  ACTION: -1,\n  //for inputs\n\n  NODE_MODES: [\"Always\", \"On Event\", \"Never\", \"On Trigger\"],\n  // helper, will add \"On Request\" and more in the future\n  NODE_MODES_COLORS: [\"#666\", \"#422\", \"#333\", \"#224\", \"#626\"],\n  // use with node_box_coloured_by_mode\n  ALWAYS: 0,\n  ON_EVENT: 1,\n  NEVER: 2,\n  ON_TRIGGER: 3,\n  UP: 1,\n  DOWN: 2,\n  LEFT: 3,\n  RIGHT: 4,\n  CENTER: 5,\n  LINK_RENDER_MODES: [\"Straight\", \"Linear\", \"Spline\"],\n  // helper\n  STRAIGHT_LINK: 0,\n  LINEAR_LINK: 1,\n  SPLINE_LINK: 2,\n  NORMAL_TITLE: 0,\n  NO_TITLE: 1,\n  TRANSPARENT_TITLE: 2,\n  AUTOHIDE_TITLE: 3,\n  VERTICAL_LAYOUT: \"vertical\",\n  // arrange nodes vertically\n\n  proxy: null,\n  //used to redirect calls\n  node_images_path: \"\",\n  debug: false,\n  catch_exceptions: true,\n  throw_errors: true,\n  allow_scripts: false,\n  //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits\n  use_deferred_actions: true,\n  //executes actions during the graph execution flow\n  registered_node_types: {},\n  //nodetypes by string\n  node_types_by_file_extension: {},\n  //used for dropping files in the canvas\n  Nodes: {},\n  //node types by classname\n  Globals: {},\n  //used to store vars between graphs\n\n  searchbox_extras: {},\n  //used to add extra features to the search box\n  auto_sort_node_types: false,\n  // [true!] If set to true, will automatically sort node types / categories in the context menus\n\n  node_box_coloured_when_on: false,\n  // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback\n  node_box_coloured_by_mode: false,\n  // [true!] nodebox based on node mode, visual feedback\n\n  dialog_close_on_mouse_leave: true,\n  // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n  dialog_close_on_mouse_leave_delay: 500,\n  shift_click_do_break_link_from: false,\n  // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys\n  click_do_break_link_to: false,\n  // [false!]prefer false, way too easy to break links\n\n  search_hide_on_mouse_leave: true,\n  // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n  search_filter_enabled: false,\n  // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]\n  search_show_all_on_open: true,\n  // [true!] opens the results list when opening the search widget\n\n  auto_load_slot_types: false,\n  // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]\n\n  // set these values if not using auto_load_slot_types\n  registered_slot_in_types: {},\n  // slot types for nodeclass\n  registered_slot_out_types: {},\n  // slot types for nodeclass\n  slot_types_in: [],\n  // slot types IN\n  slot_types_out: [],\n  // slot types OUT\n  slot_types_default_in: [],\n  // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n  slot_types_default_out: [],\n  // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n\n  alt_drag_do_clone_nodes: false,\n  // [true!] very handy, ALT click to clone and drag the new node\n\n  do_add_triggers_slots: false,\n  // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this\n\n  allow_multi_output_for_events: true,\n  // [false!] being events, it is strongly reccomended to use them sequentially, one by one\n\n  middle_click_slot_add_default_node: false,\n  //[true!] allows to create and connect a ndoe clicking with the third button (wheel)\n\n  release_link_on_empty_shows_menu: false,\n  //[true!] dragging a link to empty space will open a menu, add from list, search or defaults\n\n  ctrl_shift_v_paste_connect_unselected_outputs: false,\n  //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes\n\n  // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.\n  // use this if you must have node IDs that are unique across all graphs and subgraphs.\n  use_uuids: false,\n  /**\n   * Register a node class so it can be listed when the user wants to create a new one\n   * @method registerNodeType\n   * @param {String} type name of the node and path\n   * @param {Class} base_class class containing the structure of a node\n   */\n\n  registerNodeType: function (type, base_class) {\n    if (!base_class.prototype) {\n      throw \"Cannot register a simple object, it must be a class with a prototype\";\n    }\n    base_class.type = type;\n    if (LiteGraph.debug) {\n      console.log(\"Node registered: \" + type);\n    }\n    const classname = base_class.name;\n    const pos = type.lastIndexOf(\"/\");\n    base_class.category = type.substring(0, pos);\n    if (!base_class.title) {\n      base_class.title = classname;\n    }\n\n    //extend class\n    for (var i in _l_graph_node_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode.prototype) {\n      if (!base_class.prototype[i]) {\n        base_class.prototype[i] = _l_graph_node_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode.prototype[i];\n      }\n    }\n    const prev = this.registered_node_types[type];\n    if (prev) {\n      console.log(\"replacing node type: \" + type);\n    }\n    if (!Object.prototype.hasOwnProperty.call(base_class.prototype, \"shape\")) {\n      Object.defineProperty(base_class.prototype, \"shape\", {\n        set: function (v) {\n          switch (v) {\n            case \"default\":\n              delete this._shape;\n              break;\n            case \"box\":\n              this._shape = _settings_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.BOX_SHAPE;\n              break;\n            case \"round\":\n              this._shape = _settings_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.ROUND_SHAPE;\n              break;\n            case \"circle\":\n              this._shape = _settings_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE_SHAPE;\n              break;\n            case \"card\":\n              this._shape = _settings_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CARD_SHAPE;\n              break;\n            default:\n              this._shape = v;\n          }\n        },\n        get: function () {\n          return this._shape;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      //used to know which nodes to create when dragging files to the canvas\n      if (base_class.supported_extensions) {\n        for (let i in base_class.supported_extensions) {\n          const ext = base_class.supported_extensions[i];\n          if (ext && ext.constructor === String) {\n            this.node_types_by_file_extension[ext.toLowerCase()] = base_class;\n          }\n        }\n      }\n    }\n    this.registered_node_types[type] = base_class;\n    if (base_class.constructor.name) {\n      this.Nodes[classname] = base_class;\n    }\n    if (LiteGraph.onNodeTypeRegistered) {\n      LiteGraph.onNodeTypeRegistered(type, base_class);\n    }\n    if (prev && LiteGraph.onNodeTypeReplaced) {\n      LiteGraph.onNodeTypeReplaced(type, base_class, prev);\n    }\n\n    //warnings\n    if (base_class.prototype.onPropertyChange) {\n      console.warn(\"LiteGraph node class \" + type + \" has onPropertyChange method, it must be called onPropertyChanged with d at the end\");\n    }\n\n    // TODO one would want to know input and ouput :: this would allow through registerNodeAndSlotType to get all the slots types\n    if (this.auto_load_slot_types) {\n      new base_class(base_class.title || \"tmpnode\");\n    }\n  },\n  /**\n   * removes a node type from the system\n   * @method unregisterNodeType\n   * @param {String|Object} type name of the node or the node constructor itself\n   */\n  unregisterNodeType: function (type) {\n    const base_class = type.constructor === String ? this.registered_node_types[type] : type;\n    if (!base_class) {\n      throw \"node type not found: \" + type;\n    }\n    delete this.registered_node_types[base_class.type];\n    if (base_class.constructor.name) {\n      delete this.Nodes[base_class.constructor.name];\n    }\n  },\n  /**\n  * Save a slot type and his node\n  * @method registerSlotType\n  * @param {String|Object} type name of the node or the node constructor itself\n  * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..\n  */\n  registerNodeAndSlotType: function (type, slot_type, out) {\n    out = out || false;\n    const base_class = type.constructor === String && this.registered_node_types[type] !== \"anonymous\" ? this.registered_node_types[type] : type;\n    const class_type = base_class.constructor.type;\n    let allTypes = [];\n    if (typeof slot_type === \"string\") {\n      allTypes = slot_type.split(\",\");\n    } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n      allTypes = [\"_event_\"];\n    } else {\n      allTypes = [\"*\"];\n    }\n    for (let i = 0; i < allTypes.length; ++i) {\n      let slotType = allTypes[i];\n      if (slotType === \"\") {\n        slotType = \"*\";\n      }\n      const registerTo = out ? \"registered_slot_out_types\" : \"registered_slot_in_types\";\n      if (this[registerTo][slotType] === undefined) {\n        this[registerTo][slotType] = {\n          nodes: []\n        };\n      }\n      if (!this[registerTo][slotType].nodes.includes(class_type)) {\n        this[registerTo][slotType].nodes.push(class_type);\n      }\n\n      // check if is a new type\n      if (!out) {\n        if (!this.slot_types_in.includes(slotType.toLowerCase())) {\n          this.slot_types_in.push(slotType.toLowerCase());\n          this.slot_types_in.sort();\n        }\n      } else {\n        if (!this.slot_types_out.includes(slotType.toLowerCase())) {\n          this.slot_types_out.push(slotType.toLowerCase());\n          this.slot_types_out.sort();\n        }\n      }\n    }\n  },\n  /**\n   * Create a new nodetype by passing an object with some properties\n   * like onCreate, inputs:Array, outputs:Array, properties, onExecute\n   * @method buildNodeClassFromObject\n   * @param {String} name node name with namespace (p.e.: 'math/sum')\n   * @param {Object} object methods expected onCreate, inputs, outputs, properties, onExecute\n   */\n  buildNodeClassFromObject: function (name, object) {\n    var ctor_code = \"\";\n    if (object.inputs) for (var i = 0; i < object.inputs.length; ++i) {\n      var _name = object.inputs[i][0];\n      var _type = object.inputs[i][1];\n      if (_type && _type.constructor === String) _type = '\"' + _type + '\"';\n      ctor_code += \"this.addInput('\" + _name + \"',\" + _type + \");\\n\";\n    }\n    if (object.outputs) for (var i = 0; i < object.outputs.length; ++i) {\n      var _name = object.outputs[i][0];\n      var _type = object.outputs[i][1];\n      if (_type && _type.constructor === String) _type = '\"' + _type + '\"';\n      ctor_code += \"this.addOutput('\" + _name + \"',\" + _type + \");\\n\";\n    }\n    if (object.properties) for (var i in object.properties) {\n      var prop = object.properties[i];\n      if (prop && prop.constructor === String) prop = '\"' + prop + '\"';\n      ctor_code += \"this.addProperty('\" + i + \"',\" + prop + \");\\n\";\n    }\n    ctor_code += \"if(this.onCreate)this.onCreate()\";\n    var classobj = Function(ctor_code);\n    for (var i in object) if (i != \"inputs\" && i != \"outputs\" && i != \"properties\") classobj.prototype[i] = object[i];\n    classobj.title = object.title || name.split(\"/\").pop();\n    classobj.desc = object.desc || \"Generated from object\";\n    this.registerNodeType(name, classobj);\n    return classobj;\n  },\n  /**\n   * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.\n   * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.\n   * @method wrapFunctionAsNode\n   * @param {String} name node name with namespace (p.e.: 'math/sum')\n   * @param {Function} func\n   * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type\n   * @param {String} return_type [optional] string with the return type, otherwise it will be generic\n   * @param {Object} properties [optional] properties to be configurable\n   */\n  wrapFunctionAsNode: function (name, func, param_types, return_type, properties) {\n    var params = Array(func.length);\n    var code = \"\";\n    if (param_types !== null)\n      //null means no inputs\n      {\n        var names = LiteGraph.getParameterNames(func);\n        for (var i = 0; i < names.length; ++i) {\n          var type = 0;\n          if (param_types) {\n            //type = param_types[i] != null ? \"'\" + param_types[i] + \"'\" : \"0\";\n            if (param_types[i] != null && param_types[i].constructor === String) type = \"'\" + param_types[i] + \"'\";else if (param_types[i] != null) type = param_types[i];\n          }\n          code += \"this.addInput('\" + names[i] + \"',\" + type + \");\\n\";\n        }\n      }\n    if (return_type !== null)\n      //null means no output\n      code += \"this.addOutput('out',\" + (return_type != null ? return_type.constructor === String ? \"'\" + return_type + \"'\" : return_type : 0) + \");\\n\";\n    if (properties) {\n      code += \"this.properties = \" + JSON.stringify(properties) + \";\\n\";\n    }\n    var classobj = Function(code);\n    classobj.title = name.split(\"/\").pop();\n    classobj.desc = \"Generated from \" + func.name;\n    classobj.prototype.onExecute = function onExecute() {\n      for (var i = 0; i < params.length; ++i) {\n        params[i] = this.getInputData(i);\n      }\n      var r = func.apply(this, params);\n      this.setOutputData(0, r);\n    };\n    this.registerNodeType(name, classobj);\n    return classobj;\n  },\n  /**\n   * Removes all previously registered node's types\n   */\n  clearRegisteredTypes: function () {\n    this.registered_node_types = {};\n    this.node_types_by_file_extension = {};\n    this.Nodes = {};\n    this.searchbox_extras = {};\n  },\n  /**\n   * Adds this method to all nodetypes, existing and to be created\n   * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n   * @method addNodeMethod\n   * @param {Function} func\n   */\n  addNodeMethod: function (name, func) {\n    _l_graph_node_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode.prototype[name] = func;\n    for (var i in this.registered_node_types) {\n      var type = this.registered_node_types[i];\n      if (type.prototype[name]) {\n        type.prototype[\"_\" + name] = type.prototype[name];\n      } //keep old in case of replacing\n      type.prototype[name] = func;\n    }\n  },\n  /**\n   * Create a node of a given type with a name. The node is not attached to any graph yet.\n   * @method createNode\n   * @param {String} type full name of the node class. p.e. \"math/sin\"\n   * @param {String} name a name to distinguish from other nodes\n   * @param {Object} options to set options\n   */\n\n  createNode: function (type, title, options) {\n    var base_class = this.registered_node_types[type];\n    if (!base_class) {\n      if (LiteGraph.debug) {\n        console.log('GraphNode type \"' + type + '\" not registered.');\n      }\n      return null;\n    }\n    var prototype = base_class.prototype || base_class;\n    title = title || base_class.title || type;\n    var node = null;\n    if (LiteGraph.catch_exceptions) {\n      try {\n        node = new base_class(title);\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    } else {\n      node = new base_class(title);\n    }\n    node.type = type;\n    if (!node.title && title) {\n      node.title = title;\n    }\n    if (!node.properties) {\n      node.properties = {};\n    }\n    if (!node.properties_info) {\n      node.properties_info = [];\n    }\n    if (!node.flags) {\n      node.flags = {};\n    }\n    if (!node.size) {\n      node.size = node.computeSize();\n      //call onresize?\n    }\n    if (!node.pos) {\n      node.pos = LiteGraph.DEFAULT_POSITION.concat();\n    }\n    if (!node.mode) {\n      node.mode = LiteGraph.ALWAYS;\n    }\n\n    //extra options\n    if (options) {\n      for (var i in options) {\n        node[i] = options[i];\n      }\n    }\n\n    // callback\n    if (node.onNodeCreated) {\n      node.onNodeCreated();\n    }\n    return node;\n  },\n  /**\n   * Returns a registered node type with a given name\n   * @method getNodeType\n   * @param {String} type full name of the node class. p.e. \"math/sin\"\n   * @return {Class} the node class\n   */\n  getNodeType: function (type) {\n    return this.registered_node_types[type];\n  },\n  /**\n   * Returns a list of node types matching one category\n   * @method getNodeType\n   * @param {String} category category name\n   * @return {Array} array with all the node classes\n   */\n\n  getNodeTypesInCategory: function (category, filter) {\n    var r = [];\n    for (var i in this.registered_node_types) {\n      var type = this.registered_node_types[i];\n      if (type.filter != filter) {\n        continue;\n      }\n      if (category == \"\") {\n        if (type.category == null) {\n          r.push(type);\n        }\n      } else if (type.category == category) {\n        r.push(type);\n      }\n    }\n    if (this.auto_sort_node_types) {\n      r.sort(function (a, b) {\n        return a.title.localeCompare(b.title);\n      });\n    }\n    return r;\n  },\n  /**\n   * Returns a list with all the node type categories\n   * @method getNodeTypesCategories\n   * @param {String} filter only nodes with ctor.filter equal can be shown\n   * @return {Array} array with all the names of the categories\n   */\n  getNodeTypesCategories: function (filter) {\n    var categories = {\n      \"\": 1\n    };\n    for (var i in this.registered_node_types) {\n      var type = this.registered_node_types[i];\n      if (type.category && !type.skip_list) {\n        if (type.filter != filter) continue;\n        categories[type.category] = 1;\n      }\n    }\n    var result = [];\n    for (var i in categories) {\n      result.push(i);\n    }\n    return this.auto_sort_node_types ? result.sort() : result;\n  },\n  //debug purposes: reloads all the js scripts that matches a wildcard\n  reloadNodes: function (folder_wildcard) {\n    var tmp = document.getElementsByTagName(\"script\");\n    //weird, this array changes by its own, so we use a copy\n    var script_files = [];\n    for (var i = 0; i < tmp.length; i++) {\n      script_files.push(tmp[i]);\n    }\n    var docHeadObj = document.getElementsByTagName(\"head\")[0];\n    folder_wildcard = document.location.href + folder_wildcard;\n    for (var i = 0; i < script_files.length; i++) {\n      var src = script_files[i].src;\n      if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard) {\n        continue;\n      }\n      try {\n        if (LiteGraph.debug) {\n          console.log(\"Reloading: \" + src);\n        }\n        var dynamicScript = document.createElement(\"script\");\n        dynamicScript.type = \"text/javascript\";\n        dynamicScript.src = src;\n        docHeadObj.appendChild(dynamicScript);\n        docHeadObj.removeChild(script_files[i]);\n      } catch (err) {\n        if (LiteGraph.throw_errors) {\n          throw err;\n        }\n        if (LiteGraph.debug) {\n          console.log(\"Error while reloading \" + src);\n        }\n      }\n    }\n    if (LiteGraph.debug) {\n      console.log(\"Nodes reloaded\");\n    }\n  },\n  /**\n   * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n   * @method isValidConnection\n   * @param {String} type_a\n   * @param {String} type_b\n   * @return {Boolean} true if they can be connected\n   */\n  isValidConnection: function (type_a, type_b) {\n    if (type_a == \"\" || type_a === \"*\") type_a = 0;\n    if (type_b == \"\" || type_b === \"*\") type_b = 0;\n    if (!type_a //generic output\n    || !type_b // generic input\n    || type_a == type_b //same type (is valid for triggers)\n    || type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION) {\n      return true;\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    type_a = String(type_a);\n    type_b = String(type_b);\n    type_a = type_a.toLowerCase();\n    type_b = type_b.toLowerCase();\n\n    // For nodes supporting multiple connection types\n    if (type_a.indexOf(\",\") == -1 && type_b.indexOf(\",\") == -1) {\n      return type_a == type_b;\n    }\n\n    // Check all permutations to see if one is valid\n    var supported_types_a = type_a.split(\",\");\n    var supported_types_b = type_b.split(\",\");\n    for (var i = 0; i < supported_types_a.length; ++i) {\n      for (var j = 0; j < supported_types_b.length; ++j) {\n        if (this.isValidConnection(supported_types_a[i], supported_types_b[j])) {\n          //if (supported_types_a[i] == supported_types_b[j]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/litegraph_class.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/node_colors.js":
/*!******************************************************!*\
  !*** ./members/GraphRender/litegraph/node_colors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   node_colors: () => (/* binding */ node_colors)\n/* harmony export */ });\nconst node_colors = {\n  red: {\n    color: \"#322\",\n    bgcolor: \"#533\",\n    groupcolor: \"#A88\"\n  },\n  brown: {\n    color: \"#332922\",\n    bgcolor: \"#593930\",\n    groupcolor: \"#b06634\"\n  },\n  green: {\n    color: \"#232\",\n    bgcolor: \"#353\",\n    groupcolor: \"#8A8\"\n  },\n  blue: {\n    color: \"#223\",\n    bgcolor: \"#335\",\n    groupcolor: \"#88A\"\n  },\n  pale_blue: {\n    color: \"#2a363b\",\n    bgcolor: \"#3f5159\",\n    groupcolor: \"#3f789e\"\n  },\n  cyan: {\n    color: \"#233\",\n    bgcolor: \"#355\",\n    groupcolor: \"#8AA\"\n  },\n  purple: {\n    color: \"#323\",\n    bgcolor: \"#535\",\n    groupcolor: \"#a1309b\"\n  },\n  yellow: {\n    color: \"#432\",\n    bgcolor: \"#653\",\n    groupcolor: \"#b58b2a\"\n  },\n  black: {\n    color: \"#222\",\n    bgcolor: \"#000\",\n    groupcolor: \"#444\"\n  }\n};\n\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/node_colors.js?");

/***/ }),

/***/ "./members/GraphRender/litegraph/settings.js":
/*!***************************************************!*\
  !*** ./members/GraphRender/litegraph/settings.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CANVAS_GRID_SIZE: () => (/* binding */ CANVAS_GRID_SIZE),\n/* harmony export */   NODE_SLOT_HEIGHT: () => (/* binding */ NODE_SLOT_HEIGHT),\n/* harmony export */   NODE_TEXT_SIZE: () => (/* binding */ NODE_TEXT_SIZE),\n/* harmony export */   NODE_TITLE_HEIGHT: () => (/* binding */ NODE_TITLE_HEIGHT),\n/* harmony export */   NODE_WIDGET_HEIGHT: () => (/* binding */ NODE_WIDGET_HEIGHT),\n/* harmony export */   SHAPES: () => (/* binding */ SHAPES),\n/* harmony export */   debug: () => (/* binding */ debug)\n/* harmony export */ });\nconst debug = false;\nconst CANVAS_GRID_SIZE = 10;\nconst NODE_TITLE_HEIGHT = 30;\nconst NODE_SLOT_HEIGHT = 20;\nconst NODE_WIDGET_HEIGHT = 20;\nconst NODE_TEXT_SIZE = 14;\nconst SHAPES = {\n  //shapes are used for nodes but also for slots\n  BOX_SHAPE: 1,\n  ROUND_SHAPE: 2,\n  CIRCLE_SHAPE: 3,\n  CARD_SHAPE: 4,\n  ARROW_SHAPE: 5,\n  GRID_SHAPE: 6 // intended for slot arrays\n};\n\n//# sourceURL=webpack://App/./members/GraphRender/litegraph/settings.js?");

/***/ }),

/***/ "./members/ui/events/showUI_event.js":
/*!*******************************************!*\
  !*** ./members/ui/events/showUI_event.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n\nconst type = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  system: \"UserInterface\",\n  entity: \"UI\",\n  action: \"Show\"\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./members/ui/events/showUI_event.js?");

/***/ }),

/***/ "./members/ui/index.js":
/*!*****************************!*\
  !*** ./members/ui/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIMember: () => (/* binding */ UIMember)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n/* harmony import */ var _ellementul_ui_game_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ellementul/ui-game-grid */ \"./node_modules/@ellementul/ui-game-grid/index.js\");\n/* harmony import */ var _events_showUI_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/showUI_event.js */ \"./members/ui/events/showUI_event.js\");\n\n\n\nclass UIMember extends _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Member {\n  constructor() {\n    super();\n    this.grid = new _ellementul_ui_game_grid__WEBPACK_IMPORTED_MODULE_1__.Grid();\n    this.onEvent(_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.events.buildEvent, () => this.createUI()); // Subscribing on event\n\n    this.role = \"UI\";\n  }\n  createUI() {\n    this.grid.createBox({\n      name: \"HelloBlock\",\n      top: 3,\n      left: 3,\n      right: 3,\n      bottom: 3,\n      centred: true\n    });\n  }\n}\nconst exportEvents = {// Export of your events\n};\n\n\n//# sourceURL=webpack://App/./members/ui/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID\n});\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://App/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/core.js":
/*!********************************************************!*\
  !*** ./node_modules/@ellementul/message-types/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nvar typeID = \"UIDOFTYPEOFTYPESJS\";\r\nvar crTypeID = \"UIDOFCONSTRUCTOROFTYPEOFTYPESJS\";\r\n\r\nvar isTest = true;\r\n\r\nvar Types = {\r\n\tnewType: function (name, CrType, outJSON){\r\n\t\tif(typeof name != \"string\")\r\n\t\t\tthrow new Error(\"name isn't String!\")\r\n\r\n\t\tif(typeof CrType != \"function\")\r\n\t\t\tthrow new Error(\"CrType isn't Function!\")\r\n\r\n\t\tif(typeof outJSON != \"function\")\r\n\t\t\tthrow new Error(\"outJSON isn't Function!\")\r\n\r\n\t\tif(this[name]){\r\n\t\t\tconsole.warn(\"Type \" + name + \"already created!\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar newType = {\r\n\t\t\tname: name,\r\n\t\t\tDef: newCreator(CrType),\r\n\t\t\toutJSON: crOutJSON(outJSON),\r\n\t\t};\r\n\r\n\t\tnewType[crTypeID] = crTypeID;\r\n\r\n\t\tthis[name] = newType;\r\n\r\n\t\treturn this[name];\r\n\r\n\t},\r\n\toutJSON: function (json) {\r\n\t\tif(typeof json == \"string\")\r\n\t\t\tjson = JSON.parse(json)\r\n\r\n\t\tif(this.isCrType(Types[json.name]))\r\n\t\t\treturn Types[json.name].outJSON(json)\r\n\t\telse\r\n\t\t\tthrow \"The got object isn't json type!\"\r\n\t},\r\n\tisType: isType,\r\n\tisCrType: isCrType,\r\n\tget isTest(){return isTest},\r\n\tset isTest(val){isTest = !!val},\r\n\targError: function argError(wrong_arg, mess){\r\n\t\tif(mess === undefined) mess = '';\r\n\t\tvar ER = new TypeError('Argument type is wrong! Arguments(' + forArg(wrong_arg) + ');' + mess);\r\n\t\tER.wrong_arg = wrong_arg;\r\n\r\n\t\tif (Error.captureStackTrace) {\r\n\t\t\tError.captureStackTrace(ER, argError);\r\n\t\t}\r\n\r\n\t\treturn ER;\r\n\r\n\t\tfunction forArg(args){\r\n\t\t\tvar str_args = '';\r\n\t\t\tfor(var i = 0; i < args.length; i++){\r\n\t\t\t\tstr_args += typeof(args[i]) + ': ' + args[i] + '; ';\r\n\t\t\t}\r\n\t\t\treturn str_args;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction newCreator(CrType){\t\r\n\treturn function(){\r\n\r\n\t\tvar type = CrType.apply(CrType, arguments);\r\n\t\tmixType(type);\r\n\t\t\r\n\t\treturn type;\r\n\t};\r\n}\r\n\r\n\r\n\r\nfunction crOutJSON(outJSON){\r\n\treturn function(json){\r\n\r\n\t\tif(typeof json == \"string\")\r\n\t\t\tjson = JSON.parse(json)\r\n\t\t\r\n\t\tvar type = outJSON(json);\r\n\t\tmixType(type);\r\n\r\n\t\treturn type\r\n\t}\r\n}\r\n\r\nfunction mixType(type){\r\n\ttype[typeID] = typeID;\r\n\ttype.toJSON = crToJSON(type.preJSON);\r\n\ttype.test = wrapTest(type.test);\r\n}\r\n\r\nfunction wrapTest(test){\r\n\treturn function(val){\r\n\t\tif(isTest)\r\n\t\t\treturn test(val);\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nfunction crToJSON(preJSON){\r\n\treturn function(tabs){\r\n\t\tvar preJson = Object.assign({}, preJSON());\r\n\t\tdelete preJson.toJSON;\r\n\t\treturn JSON.stringify(preJson, \"\", tabs);\r\n\t}\r\n}\r\n\r\nfunction isType(type) {\r\n\treturn typeof type == \"object\" && type[typeID] == typeID \r\n\t\t\t&& typeof type.rand == \"function\" \r\n\t\t\t&& typeof type.test == \"function\"\r\n\t\t\t&& typeof type.preJSON == \"function\"\r\n\t\t\t&& typeof type.toJSON == \"function\";\r\n}\r\n\r\nfunction isCrType(crType){\r\n\treturn typeof crType == \"object\" && crType[crTypeID] == crTypeID\r\n\t\t\t&& typeof crType.Def == \"function\" \r\n\t\t\t&& typeof crType.outJSON == \"function\";\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Types);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/core.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ellementul/message-types/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@ellementul/message-types/core.js\");\n/* harmony import */ var _types_template_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/template/type.js */ \"./node_modules/@ellementul/message-types/types/template/type.js\");\n/* harmony import */ var _types_const_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/const/type.js */ \"./node_modules/@ellementul/message-types/types/const/type.js\");\n/* harmony import */ var _types_bool_type_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types/bool/type.js */ \"./node_modules/@ellementul/message-types/types/bool/type.js\");\n/* harmony import */ var _types_number_type_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/number/type.js */ \"./node_modules/@ellementul/message-types/types/number/type.js\");\n/* harmony import */ var _types_index_type_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types/index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n/* harmony import */ var _types_key_type_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types/key/type.js */ \"./node_modules/@ellementul/message-types/types/key/type.js\");\n/* harmony import */ var _types_object_type_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types/object/type.js */ \"./node_modules/@ellementul/message-types/types/object/type.js\");\n/* harmony import */ var _types_array_type_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types/array/type.js */ \"./node_modules/@ellementul/message-types/types/array/type.js\");\n/* harmony import */ var _types_any_type_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types/any/type.js */ \"./node_modules/@ellementul/message-types/types/any/type.js\");\n/* harmony import */ var _types_string_type_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types/string/type.js */ \"./node_modules/@ellementul/message-types/types/string/type.js\");\n/* harmony import */ var _types_switch_type_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types/switch/type.js */ \"./node_modules/@ellementul/message-types/types/switch/type.js\");\n/* harmony import */ var _types_uuid_type_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./types/uuid/type.js */ \"./node_modules/@ellementul/message-types/types/uuid/type.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n(0,_types_template_type_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_const_type_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_bool_type_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_number_type_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_index_type_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_key_type_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_object_type_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_array_type_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_any_type_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_string_type_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_switch_type_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n;(0,_types_uuid_type_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/any/type.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/any/type.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n\r\n\r\n\r\n\r\n\r\nconst typeName = \"Any\";\r\n\r\nvar argError = null;\r\n\r\nvar Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\r\n\tif(!Core.Index)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\r\n\tif(!Core.Const)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(types){\r\n\r\n\tif(!Array.isArray(types))\r\n\t\ttypes = Array.from(arguments);\r\n\r\n\tif(!Types.isType(types[0]))\r\n\t\tthrow argError(arguments, 'Wait args Array[Type(surelly), Type||null||undefined, ... Type||null||undefined]');\r\n\r\n\tif(types.length > 1)\r\n\t\tvar typeIndex = Types.Index.Def(types.length)\r\n\telse{\r\n\t\tvar typeIndex = Types.Index.Def(2)\r\n\t\ttypes[1] = Types.Const.Def();\r\n\t}\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn types[typeIndex.rand()].rand();\r\n\t}\r\n\r\n\tfunction test(value){\r\n\t\tvar result = types.every(typeItem => typeItem.test(value));\r\n\t\tif(result)\r\n\t\t\treturn { value: value, type: preJSON()};\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = types.map(typeItem => typeItem.preJSON());\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct.map(itemOutJSON))\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\r\n\r\nfunction itemOutJSON(preType){\r\n\tif(!Types.isCrType(Types[preType.name]))\r\n\t\tthrow new Error(\"Parsing Error! Type with name\" + nameType + \"is unknowed!\");\r\n\treturn Types[preType.name].outJSON(preType);\r\n}\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/any/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/array/type.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/array/type.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n\r\n\r\nconst typeName = \"Array\";\r\n\r\n\r\n\r\nvar argError = null;\r\n\r\nvar Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Index)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(itemType, maxLength, is_empty){\r\n\r\n\tvar maxLengthType = Types.Index.Def(1024*1024);\t\r\n\r\n\tif(!Types.isType(itemType)\r\n\t\t|| maxLengthType.test(maxLength))\r\n\t\tthrow argError(arguments, 'Wait args (Type, maxLength<1024*1024 [, isEmptyArray])');\r\n\r\n\tvar lengthType = Types.Index.Def(maxLength + 1);\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\tvar length = lengthType.rand();\r\n\t\tvar arr = [];\r\n\r\n\t\tif(!is_empty)\r\n\t\t\tarr.push(itemType.rand());\r\n\r\n\t\twhile(arr.length < length)\r\n\t\t\tarr.push(itemType.rand());\r\n\r\n\t\treturn arr;\r\n\t}\r\n\r\n\tfunction test(arr){\r\n\t\tif(!Array.isArray(arr))\r\n\t\t\treturn { value: arr, type: preJSON()};\r\n\r\n\t\tif((arr.length > maxLength) || (!is_empty && arr.length == 0))\r\n\t\t\treturn { length: arr.length, type: preJSON()};\r\n\r\n\t\tvar err_arr = arr.map(itemType.test).filter(item => item);\r\n\r\n\t\tif(err_arr.length)\r\n\t\t\treturn { wrong_values: err_arr, type: preJSON()};\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = {type: itemType.preJSON(), maxLength: maxLength, is_empty: is_empty};\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tvar struct = preType.struct;\r\n\tvar nameType = struct.type.name;\r\n\r\n\tif(!Types.isCrType(Types[nameType]))\r\n\t\tthrow new Error(\"Parsing Error! Type with name\" + nameType + \"is unknowed!\");\r\n\r\n\tvar type = Types[nameType].outJSON(struct.type);\r\n\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(type, struct.maxLength, struct.is_empty);\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/array/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/bool/type.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/bool/type.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"Bool\";\r\n\r\nfunction ExtendTypes(Core){\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(){\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn Math.random() > 0.5;\r\n\t}\r\n\r\n\tfunction test(value){\r\n\t\tif(value !== false && value !== true)\r\n\t\t\treturn { value: value, type: preJSON()};\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType()\r\n\telse\r\n\t\tthrow new Error(\"This isn't boolean type!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/bool/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/const/type.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/const/type.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"Const\";\r\n\r\nvar argError = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\targError = Core.argError;\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(constVal){\r\n\r\n\tif(typeof constVal !== \"string\"\r\n\t\t&& typeof constVal !== \"number\"\r\n\t\t&& typeof constVal !== \"boolean\"\r\n\t\t&& typeof constVal !== \"function\"\r\n\t\t&& constVal)\r\n\t\tthrow argError(arguments, 'Wait argument is string || number || boolean || null || undefined || function');\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn constVal;\r\n\t}\r\n\r\n\tfunction test(value){\r\n\t\tif(value !== constVal)\r\n\t\t\treturn { value: value, type: preJSON()};\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = constVal;\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct)\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/const/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/index/type.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/index/type.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"Index\";\r\nvar argError\r\n\r\nfunction ExtendTypes(Core){\r\n\targError = Core.argError;\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(max){\r\n\r\n\tif(typeof max !== 'number' || !isFinite(max)\r\n\t\t||(max <= 0)\r\n\t\t||(max % 1 !== 0))\r\n\t\tthrow argError(arguments, 'Wait arguments: max(int>0)');\r\n\t\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn Math.floor(max * Math.abs(Math.random() - 0.01));\r\n\t}\r\n\r\n\tfunction test(n){\r\n\t\tif(typeof n !== 'number' || !isFinite(n))\r\n\t\t\treturn { value: n, type: preJSON()};\r\n\t\t\r\n\r\n\t\tif(n >= max || n < 0 || n % 1 !== 0)\r\n\t\t\treturn { value: n, type: preJSON()};\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = {\r\n\t\t\tmax: max\r\n\t\t};\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tvar arg = preType.struct;\r\n\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(arg.max);\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/index/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/key/type.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/key/type.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n\r\n\r\nconst typeName = \"Key\";\r\n\r\nvar argError = null;\r\n\r\n\r\n\r\nvar Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Index)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(){\r\n\r\n\tvar chars = crChars();\r\n\tvar sizeType = Types.Index.Def(256);\r\n\tvar indexType = Types.Index.Def(chars.length);\r\n\tvar regEx =  /^[a-zA-Z0-9_]*$/;\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\tvar size = sizeType.rand();\r\n\r\n\t\tvar str = '';\r\n\t\twhile(size){\r\n\t\t\tvar randIndex = indexType.rand()\r\n\t\t\tvar charNum = chars[randIndex];\r\n\t\t\tstr += String.fromCharCode(charNum);\r\n\t\t\tsize--;\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n\r\n\tfunction test(str){\r\n\t\tif(typeof(str) !== 'string'\r\n\t\t||str.length > 256\r\n\t\t||!regEx.test(str)){\r\n\t\t\treturn { value: str, type: preJSON()};\r\n\t\t}\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct)\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n\r\nfunction crChars(){\r\n\tvar arr_chars = rangeInArr((\"a\").charCodeAt(0), (\"z\").charCodeAt(0));\r\n\r\n\tarr_chars = arr_chars.concat(rangeInArr((\"A\").charCodeAt(0), (\"Z\").charCodeAt(0)));\r\n\r\n\tarr_chars = arr_chars.concat(rangeInArr((\"0\").charCodeAt(0), (\"9\").charCodeAt(0)));\r\n\r\n\tarr_chars.push((\"_\").charCodeAt(0));\r\n\r\n\treturn arr_chars;\r\n}\r\n\r\n\r\nfunction rangeInArr(beg, end){\r\n\tif(beg > end){\r\n\t\tvar tmp = beg;\r\n\t\tbeg = end;\r\n\t\tend = tmp;\r\n\t}\r\n\r\n\tvar arr = [];\r\n\tfor(var i = beg; i <= end; i++){\r\n\t\tarr.push(i);\r\n\t}\r\n\r\n\treturn arr;\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/key/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/number/type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/number/type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"Number\";\r\nvar argError\r\n\r\nfunction ExtendTypes(Core){\r\n\targError = Core.argError;\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(max, min, precis){\r\n\r\n\tif(typeof min !== 'number' || !isFinite(min)\r\n\t\t||typeof max !== 'number' || !isFinite(max)\r\n\t\t||typeof precis !== 'number' || !isFinite(precis)\r\n\t\t||(max <= min)\r\n\t\t||(precis < 0)\r\n\t\t||(precis > 9)\r\n\t\t||(precis % 1 !== 0))\r\n\t\tthrow argError(arguments, 'Wait arguments: max(number), > min(number), precis(0<=number<9)');\r\n\t\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn +(((max - min)*Math.random() +  min).toFixed(precis));\r\n\t}\r\n\r\n\tfunction test(n){\r\n\t\tif(typeof n !== 'number' || !isFinite(n))\r\n\t\t\treturn new Error(JSON.stringify({ value: n, type: preJSON()}, \"\", 2));\r\n\t\t\r\n\r\n\t\tif((n > max)\r\n\t\t||(n < min)\r\n\t\t|| (n.toFixed(precis) != n && n !== 0) )\r\n\t\t\treturn new Error(JSON.stringify({ value: n, type: preJSON()}, \"\", 2));\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = {\r\n\t\t\tmin: min,\r\n\t\t\tmax: max,\r\n\t\t\tprecis: precis\r\n\t\t};\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tvar arg = preType.struct;\r\n\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(arg.max, arg.min, arg.precis);\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/number/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/object/type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/object/type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n  \r\n\r\nconst typeName = \"Object\";\r\n\r\nvar argError = null;\r\n\r\nvar Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Const)\r\n\t\tCrIndexType(Const);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(sourceObj, non_strict_key){\r\n\tconst non_strict_keys = non_strict_key //|| true\r\n\r\n\tif(!sourceObj || typeof sourceObj !== \"object\")\r\n\t\tthrow argError(arguments, \"Argument isn't Object!\" );\r\n\t\r\n\r\n\tvar typeObj = reCostructObj(sourceObj);\r\n\r\n\tvar type = {\r\n\t\tname: typeName,\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn genObj(typeObj);\r\n\t}\r\n\r\n\tfunction test(testingObj, objsStack){\r\n\t\treturn testObj(typeObj, testingObj, objsStack, non_strict_keys);\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {name: typeName};\r\n\t\ttype.struct = objPreJson(typeObj);\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(objOutJson(preType.struct));\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\r\n\r\nfunction reCostructObj(sourceObj, objsStack){\r\n\r\n\tif(!objsStack)\r\n\t\tobjsStack = [];\r\n\t\r\n\tvar funcObj = {};\r\n\tobjsStack.push(sourceObj);\r\n\r\n\tfor(var key in sourceObj){\r\n\r\n\t\tif(Types.isType(sourceObj[key])){\r\n\t\t\tfuncObj[key] = sourceObj[key];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif(!sourceObj || (typeof sourceObj[key] !== \"object\" && !Array.isArray(sourceObj[key]))){\r\n\t\t\tfuncObj[key] = Types.Const.Def(sourceObj[key]);\r\n\t\t}\r\n\t\telse if(objsStack.indexOf(sourceObj[key]) !== -1)\r\n\t\t\tdelete funcObj[key];\r\n\t\telse\r\n\t\t\tfuncObj[key] = reCostructObj(sourceObj[key], objsStack);\r\n\t}\r\n\r\n\tobjsStack.pop();\r\n\r\n\treturn funcObj;\r\n}\r\n\r\nfunction testObj(typeObj, testingObj, objsStack, non_strict_keys){\r\n\tif(!objsStack)\r\n\t\tobjsStack = [];\r\n\r\n\tobjsStack.push(testingObj);\r\n\r\n\tvar result = false;\r\n\r\n\tfor(let key in typeObj){\r\n\r\n\t\tif(Types.isType(typeObj[key]))\r\n\t\t\tresult = typeObj[key].test(testingObj[key]);\r\n\t\telse\r\n\t\t\tresult = testObj(typeObj[key], testingObj[key], objsStack, non_strict_keys)\r\n\r\n\t\tif(result)\r\n\t\t\treturn result;\r\n\t\t\r\n\t}\r\n\r\n\tfor(let key in testingObj){\r\n\t\tif(objsStack.indexOf(testingObj[key]) !== -1)\r\n\t\t\tcontinue;\r\n\r\n\t\tif(!Types.isType(typeObj[key]) && !non_strict_keys)\r\n\t\t\treturn { messege: \"Here cannot value!\", key: key, value: testingObj[key], type: {name: typeName, struct: objPreJson(typeObj[key])}};\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction genObj(typeObj){\r\n\tvar resultObj = {};\r\n\r\n\tfor(var key in typeObj){\r\n\t\tif(Types.isType(typeObj[key]))\r\n\t\t\tresultObj[key] = typeObj[key].rand();\r\n\t\telse \r\n\t\t\tresultObj[key] = genObj(typeObj[key]);\r\n\t}\r\n\r\n\treturn resultObj;\r\n}\r\n\r\nfunction objPreJson(typeObj){\r\n\tvar struct = {};\r\n\r\n\tfor(var key in typeObj){\r\n\t\tif(Types.isType(typeObj[key]))\r\n\t\t\tstruct[key] = typeObj[key].preJSON();\r\n\t\telse{\r\n\t\t\tstruct[key] = objPreJson(typeObj[key]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn struct;\r\n}\r\n\r\nfunction objOutJson(jsonObj){\r\n\tvar obj = {};\r\n\r\n\tfor(var key in jsonObj){\r\n\t\tvar propJsonObj = jsonObj[key];\r\n\r\n\t\tif(typeof propJsonObj != \"object\")\r\n\t\t\t\tthrow new Error(\"Invalid scheme JSON, wrong value: \" + propJsonObj + \" with key: \" + key);\r\n\r\n\t\tif(propJsonObj.name && Types[propJsonObj.name] && Types.isCrType(Types[propJsonObj.name])){\r\n\t\t\tobj[key] = Types[propJsonObj.name].outJSON(propJsonObj);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tobj[key] = objOutJson(propJsonObj);\r\n\t\t}\r\n\t}\r\n\r\n\treturn obj;\r\n}\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/object/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/string/type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/string/type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"String\";\r\n\r\nlet argError = null;\r\n\r\nlet Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Index)\r\n\t\tCrIndexType(Core);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(symbolClass, maxLength){\r\n\r\n\tlet maxLengthType = Types.Index.Def(1024 * 1024);\r\n\r\n\tif(typeof symbolClass !== \"string\" || maxLengthType.test(maxLength - 1))\r\n\t\tthrow argError(arguments, 'Wait args ( SymbolClass(String), maxLength(1024*1024>=Index>0) )');\r\n\t\r\n\tif(symbolClass[0] == \"^\")\r\n\t\tsymbolClass = \"\\\\\" + symbolClass;\r\n\r\n\tlet rangeSimbol = parseRange(symbolClass);\r\n\tlet indexRangeType = Types.Index.Def(rangeSimbol.length);\r\n\r\n\tlet checkedRegExp = new RegExp('^[' + symbolClass + ']+$');\r\n\tlet lengthType = Types.Index.Def(maxLength);\r\n\r\n\r\n\tlet type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\tlet length = lengthType.rand();\r\n\r\n\t\tif(length < 1)\r\n\t\t\tlength++;\r\n\r\n\t\tvar str = '';\r\n\r\n\t\twhile(length--){\r\n\t\t\tvar der = rangeSimbol[indexRangeType.rand()];\r\n\t\t\tstr +=String.fromCharCode(der);\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n\r\n\tfunction test(str){\r\n\t\tif((typeof(str) !== 'string')\r\n\t\t\t|| lengthType.test(str.length - 1)\r\n\t\t\t|| !checkedRegExp.test(str)\r\n\t\t)\r\n\t\t\treturn { value: str, type: preJSON()};\r\n\t\t\r\n\r\n\t\treturn  false;\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = {\r\n\t\t\tsymbolClass, \r\n\t\t\tmaxLength,\r\n\t\t};\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct.symbolClass, preType.struct.maxLength);\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\nfunction replaceSpecChar(c){\r\n\tswitch(c){\r\n\t\tcase 'w': return 'a-zA-Z0-9_';\r\n\t\tcase 'd': return '0-9';\r\n\t\tcase 's': return '\\\\t\\\\n\\\\v\\\\f\\\\r ';\r\n\r\n\t\tdefault: return c;\r\n\t}\r\n}\r\n\r\nfunction rangeInArr(beg, end){\r\n\tif(beg > end){\r\n\t\tvar tmp = beg;\r\n\t\tbeg = end;\r\n\t\tend = tmp;\r\n\t}\r\n\r\n\tvar arr = [];\r\n\tfor(var i = beg; i <= end; i++){\r\n\t\tarr.push(i);\r\n\t}\r\n\r\n\treturn arr;\r\n}\r\n\r\nfunction parseRange(parse_str){\r\n\tif(/\\\\./.test(parse_str)){\r\n\t\t\tparse_str = parse_str.replace(/\\\\(.)/g, function(str, char){ return replaceSpecChar(char);});\r\n\t}\r\n\r\n\tlet result = [];\r\n\r\n\tlet beg_char = parse_str[0];\r\n\tfor(let i = 1; i <= parse_str.length; i++){\r\n\r\n\t\tif(parse_str[i-1] !== '\\\\'\r\n\t\t\t&&parse_str[i] === '-'\r\n\t\t\t&&parse_str[i+1]){\r\n\t\t\ti++;\r\n\t\t\tlet end_char = parse_str[i];\r\n\r\n\t\t\tlet arr_chars = rangeInArr(beg_char.charCodeAt(0), end_char.charCodeAt(0));\r\n\t\t\tresult = result.concat(arr_chars);\r\n\r\n\t\t\ti++;\r\n\t\t}else{\r\n\t\t\tresult.push(beg_char.charCodeAt(0));\r\n\t\t}\r\n\r\n\t\tbeg_char = parse_str[i];\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/string/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/switch/type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/switch/type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n/* harmony import */ var _key_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../key/type.js */ \"./node_modules/@ellementul/message-types/types/key/type.js\");\n\r\n\r\nconst typeName = \"Switch\";\r\n\r\nlet argError = null;\r\n\r\nlet Types = null;\r\n\r\n\r\n\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Index)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\tif(!Core.Key)\r\n\t\t(0,_key_type_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Core);\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(keyProps, typeObjs){\r\n\r\n\tlet keyType = Types.Key.Def();\r\n\r\n\tif(!Array.isArray(keyProps))\r\n\t\tkeyProps = [keyProps];\r\n\r\n\tif(keyProps.some(keyType.test))\r\n\t\tthrow argError(arguments, 'Wait the first argument Key || Array(Key)');\r\n\r\n\tif(!Array.isArray(typeObjs))\r\n\t\tthrow argError(arguments, 'Wait second argument Array!');\r\n\r\n\tlet keyArr = [];\r\n\r\n\tlet err = msg => argError(arguments, 'Wait second argument Array( Object{ [Key]: Key, prop: Type, ... }), ...); ' + msg);\r\n\r\n\tlet typeObjArr = typeObjs.map((sructObj, objIndex) => {\r\n\t\tif(typeof sructObj != \"object\")\r\n\t\t\tthrow err(\"Item \" + objIndex + \" in Array isn't Object\");\r\n\r\n\t\tlet obj = {};\r\n\r\n\t\tkeyArr[objIndex] = {};\r\n\t\tkeyProps.forEach(keyProp =>{\r\n\t\t\tif(keyType.test(sructObj[keyProp]))\r\n\t\t\t\tthrow err(\"Item \" + objIndex + \".\" + keyProp + \" isn't Key\");\r\n\t\t\telse\r\n\t\t\t\tkeyArr[objIndex][keyProp] = sructObj[keyProp];\r\n\t\t});\r\n\t\t\r\n\t\tfor (let key in sructObj){\r\n\t\t\tif(keyProps.indexOf(key) == -1){\r\n\r\n\t\t\t\tif(Types.isType(sructObj[key]))\r\n\t\t\t\t\tobj[key] = sructObj[key];\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow err(\"Item \" + objIndex + \".\" + key + \" isn't Type\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t});\r\n\r\n\tlet indexType = Types.Index.Def(keyArr.length);\r\n\t\t\r\n\r\n\tlet type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\tlet index = indexType.rand();\r\n\r\n\t\tlet obj = {};\r\n\r\n\t\tlet keyObj = keyArr[index];\r\n\t\tfor(let keyProp in keyObj)\r\n\t\t\t\tobj[keyProp] = keyObj[keyProp];\r\n\t\t\r\n\t\tlet sructObj = typeObjArr[index];\r\n\t\tfor (let key in sructObj){\r\n\t\t\tobj[key] = sructObj[key].rand();\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t}\r\n\r\n\tfunction test(obj){\r\n\t\t\r\n\t\tif(typeof obj != \"object\" || obj === null)\r\n\t\t\treturn { value: obj, type: preJSON()};\r\n\r\n\t\tif(keyProps.some(keyProp => keyType.test(obj[keyProp])))\r\n\t\t\treturn { value: obj, type: preJSON()};\r\n\r\n\t\tlet err = { value: obj, type: preJSON()};\r\n\t\tlet is_right = false;\r\n\r\n\t\tkeyArr.forEach((keyObj, index) =>{\r\n\t\t\tif(is_right)\r\n\t\t\t\treturn;\r\n\t\t\t\r\n\t\t\tlet is_right_keys = true;\r\n\t\t\tfor(let keyProp in keyObj)\r\n\t\t\t\tis_right_keys = is_right_keys && (keyObj[keyProp] == obj[keyProp]);\r\n\r\n\t\t\tif(is_right_keys){\r\n\r\n\t\t\t\tlet is_right_values = true;\r\n\t\t\t\tfor(let key in typeObjArr[index]){\r\n\t\t\t\t\tif(typeObjArr[index][key].test(obj[key])){\r\n\t\t\t\t\t\terr = { errKey: key, value: obj[key], type: typeObjArr[index][key].preJSON(), switchKeys: keyObj};\r\n\t\t\t\t\t\tis_right_values = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(is_right_values)\r\n\t\t\t\t\tis_right = true;\r\n\t\t\t} \r\n\r\n\t\t});\r\n\r\n\t\tif(!is_right)\r\n\t\t\treturn err;\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\r\n\t\tlet tempObjArr = typeObjs.map(sructObj => {\r\n\t\t\tlet obj = {};\r\n\t\t\tfor (let key in sructObj){\r\n\t\t\t\tif(Types.isType(sructObj[key]))\r\n\t\t\t\t\tobj[key] = sructObj[key].preJSON();\r\n\t\t\t\telse\r\n\t\t\t\t\tobj[key] = sructObj[key];\r\n\t\t\t}\r\n\r\n\t\t\treturn obj;\r\n\t\t});\r\n\r\n\t\ttype.struct = { keyProps, tempObjArr };\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName){\r\n\r\n\t\tlet ObjsArr = preType.struct.tempObjArr.map(jsonObj => {\r\n\t\t\tlet obj = {};\r\n\r\n\t\t\tfor(var key in jsonObj){\r\n\t\t\t\tvar propJsonObj = jsonObj[key];\r\n\r\n\t\t\t\tif(propJsonObj.name && Types[propJsonObj.name] && Types.isCrType(Types[propJsonObj.name])){\r\n\t\t\t\t\tobj[key] = Types[propJsonObj.name].outJSON(propJsonObj);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tobj[key] = propJsonObj;\r\n\t\t\t}\r\n\r\n\t\t\treturn obj;\r\n\t\t});\r\n\t\t\r\n\t\treturn ConstructorType(preType.struct.keyProps, ObjsArr);\r\n\t}\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/switch/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/template/type.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/template/type.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\nconst typeName = \"Core\";\r\n\r\nlet argError = null;\r\n\r\nlet Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(hello){\r\n\r\n\tif(typeof hello !== \"string\")\r\n\t\tthrow argError(arguments, 'Wait args (String)');\r\n\r\n\tlet type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn hello;\r\n\t}\r\n\r\n\tfunction test(value){\r\n\t\tif(value !== hello)\r\n\t\t\treturn { value: value, type: preJSON()};\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\ttype.struct = hello;\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct)\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/template/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/message-types/types/uuid/type.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ellementul/message-types/types/uuid/type.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _index_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index/type.js */ \"./node_modules/@ellementul/message-types/types/index/type.js\");\n\r\n\r\n\r\nconst typeName = \"UUID\";\r\n\r\nvar argError = null;\r\n\r\n\r\n\r\nvar Types = null;\r\n\r\nfunction ExtendTypes(Core){\r\n\tTypes = Core;\r\n\targError = Core.argError;\r\n\tif(!Core.Index)\r\n\t\t(0,_index_type_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Core);\r\n\r\n\tCore.newType(typeName, ConstructorType, outJSON);\r\n}\r\n\r\nExtendTypes.typeName = typeName;\r\n\r\nfunction ConstructorType(){\r\n\r\n\tvar type = {\r\n\t\trand: rand,\r\n\t\ttest: test,\r\n\t\tpreJSON: preJSON\r\n\t}\r\n\r\n\tfunction rand(){\r\n\t\treturn uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\r\n\t}\r\n\r\n\tfunction test(str){\r\n\t\tif(!uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"](str)){\r\n\t\t\treturn { value: str, type: preJSON()};\r\n\t\t}\r\n\t}\r\n\r\n\tfunction preJSON(){\r\n\t\tvar type = {};\r\n\t\ttype.name = typeName;\r\n\t\treturn type;\r\n\t}\r\n\r\n\treturn type;\r\n\r\n}\r\n\r\nfunction outJSON(preType){\r\n\tif(typeof preType == \"object\" && preType.name == typeName)\r\n\t\treturn ConstructorType(preType.struct)\r\n\telse\r\n\t\tthrow new Error(\"This isn't type \" + typeName + \"!\");\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendTypes);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/message-types/types/uuid/type.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/POS.js":
/*!****************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/POS.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POS: () => (/* binding */ POS)\n/* harmony export */ });\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ \"./node_modules/@ellementul/pos-member/point.js\");\n\n\nclass POS {\n  constructor () {\n    this.points = new Map\n    this.roots = new Set\n    this.leaves = new Set\n  }\n\n  get (uuid) {\n    if(!this.points.has(uuid))\n      return null\n\n    const point = this.points.get(uuid)\n    return {\n      uuid,\n      userdata: point.userdata,\n      linesBelow: Array.from(point.linesBelow),\n      linesAbove: Array.from(point.linesAbove),\n      roots: Array.from(point.roots),\n      leaves: Array.from(point.leaves)\n    }\n  }\n\n  addPoint({ userdata = {}, linesBelow = [], linesAbove = [] } = {}) {\n    const getPointByUUID = uuid => this.points.get(uuid) \n    const point = new _point_js__WEBPACK_IMPORTED_MODULE_0__.Point(getPointByUUID, userdata)\n\n    this.points.set(point.uuid, point)\n    this.roots.add(point.uuid)\n    this.leaves.add(point.uuid)\n\n    for (const below of linesBelow)\n      this.addLine({ below, above: point.uuid })\n\n    for (const above of linesAbove)\n      this.addLine({ below: point.uuid, above })\n\n    return point.uuid\n  }\n\n  deletePoint(uuid) {\n    const point = this.points.get(uuid)\n\n    for (const below of point.linesBelow)\n      this.deleteLine({ below, above: uuid })\n\n    for (const above of point.linesAbove)\n      this.deleteLine({ below: uuid, above })\n\n    this.points.delete(uuid)\n  }\n\n  addLine({ below, above }) {\n    this.checkLine({ below, above })\n\n    const pointBelow = this.points.get(below)\n    const pointAbove = this.points.get(above)\n\n    if(pointBelow.isAboveThen(pointAbove))\n      throw new Error(`I cannot create this line: ` + JSON.stringify({ below, above }) + `it will make loop!`)\n\n    pointAbove.addBelowLine(pointBelow)\n    pointBelow.addAboveLine(pointAbove)\n\n    this.roots.delete(pointAbove.uuid)\n    this.leaves.delete(pointBelow.uuid)\n  }\n\n  deleteLine ({ below, above }) {\n    this.checkLine({ below, above })\n\n    const pointBelow = this.points.get(below)\n    const pointAbove = this.points.get(above)\n\n    pointAbove.deleteBelowLine(pointBelow)\n    pointBelow.deleteAboveLine(pointAbove)\n\n    if(pointAbove.isRoot)\n      this.roots.add(pointAbove.uuid)\n\n    if(pointBelow.isLeaf)\n      this.leaves.add(pointBelow.uuid)\n  }\n\n  checkLine({ below, above }) {\n    if(below === above)\n      throw new Error(\"Point below can't be the same point that point above!\")\n\n    if(!this.points.has(below))\n      throw new Error(`Point below with ${below} uuid isn't in POS!`)\n\n    if(!this.points.has(above))\n      throw new Error(`Point above with ${above} uuid isn't in POS!`)\n\n    return\n  }\n}\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/POS.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/events/changed.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/events/changed.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n\n\nconst uuidsListType = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Array.Def(_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def(), 1024, true)\n\nconst pointType = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  uuid: _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def(),\n  userdata: _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({}, true),\n  linesAbove: uuidsListType,\n  linesBelow: uuidsListType,\n  roots: uuidsListType,\n  leaves: uuidsListType\n})\n\nconst type = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  system: \"POS\",\n  entity: \"Changed Points\",\n  state: _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Array.Def(pointType, 1024, true),\n  removed: uuidsListType\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/events/changed.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/events/create.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/events/create.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n\n\nconst uuidsListType = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Array.Def(_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def(), 1024, true)\n\nconst pointType = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  userdata: _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({}, true),\n  linesAbove: uuidsListType,\n  linesBelow: uuidsListType\n})\n\nconst type = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  system: \"POS\",\n  action: \"Create\",\n  entity: \"Point\",\n  state: pointType\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/events/create.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/events/delete.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/events/delete.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n\n\nconst type = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  system: \"POS\",\n  action: \"Delete\",\n  entity: \"UUID\",\n  state: _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def()\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/events/delete.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POSMember: () => (/* binding */ POSMember),\n/* harmony export */   events: () => (/* binding */ exportEvents)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n/* harmony import */ var _POS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./POS.js */ \"./node_modules/@ellementul/pos-member/POS.js\");\n/* harmony import */ var _events_create_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/create.js */ \"./node_modules/@ellementul/pos-member/events/create.js\");\n/* harmony import */ var _events_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/changed.js */ \"./node_modules/@ellementul/pos-member/events/changed.js\");\n/* harmony import */ var _events_delete_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/delete.js */ \"./node_modules/@ellementul/pos-member/events/delete.js\");\n\n\n\n\n\n\n\n\nclass POSMember extends _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Member {\n  constructor() {\n    super()\n\n    this.pos = new _POS_js__WEBPACK_IMPORTED_MODULE_1__.POS\n\n    this.onEvent(_events_create_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], ({ state }) => this.create(state))\n    this.onEvent(_events_delete_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], ({ state }) => this.delete(state))\n    this.role = \"POS\"\n  }\n\n  create({ userdata, linesBelow, linesAbove }) {\n    try {\n      const uuid =  this.pos.addPoint({ userdata, linesBelow, linesAbove })\n      this.changed([uuid])\n    } catch (err) {\n      console.log(err)\n    }\n  }\n\n  delete(uuid) {\n    this.pos.deletePoint(uuid)\n    this.changed([], [uuid])\n  }\n\n  changed (uuids, removedUuids = []) {\n    this.send(_events_changed_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n      state: uuids.map(uuid =>  this.pos.get(uuid)),\n      removed: removedUuids\n    })\n  }\n}\n\nconst exportEvents = {\n  create: _events_create_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  changed: _events_changed_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] \n}\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/pos-member/point.js":
/*!******************************************************!*\
  !*** ./node_modules/@ellementul/pos-member/point.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/united-events-environment */ \"./node_modules/@ellementul/united-events-environment/index.js\");\n\n\nconst randomUUID = _ellementul_united_events_environment__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def().rand\n\nclass Point {\n\n  constructor(getPointByUUID, userdata) {\n    this.getPointByUUID = getPointByUUID\n    this.userdata = userdata,\n    this.uuid = randomUUID()\n    this.linesBelow = new Set(),\n    this.linesAbove = new Set()\n  }\n\n  get isRoot() {\n    return this.linesBelow.size === 0\n  }\n\n  get isLeaf() {\n    return this.linesAbove.size === 0\n  }\n\n  get roots() {\n    const points = new Set\n\n    this.eachPointsTo(uuid => {\n      if(this.getPointByUUID(uuid).isRoot)\n        points.add(uuid)\n    }, \"linesBelow\")\n\n    return points\n  }\n\n  get leaves() {\n    const points = new Set\n\n    this.eachPointsTo(uuid => {\n      if(this.getPointByUUID(uuid).isLeaf)\n        points.add(uuid)\n    }, \"linesAbove\")\n\n    return points\n  }\n\n  addBelowLine(pointBelow) {\n    this.linesBelow.add(pointBelow.uuid)\n  }\n\n  addAboveLine(pointAbove) {\n    this.linesAbove.add(pointAbove.uuid)\n  }\n\n  deleteBelowLine(pointBelow) {\n    this.linesBelow.delete(pointBelow.uuid)  \n  }\n\n  deleteAboveLine(pointAbove) {\n    this.linesAbove.delete(pointAbove.uuid)\n  }\n\n  eachPointsTo(callback, to) {\n    let uuidsToCheck = new Set(this[to])\n    let checkedUuids = new Set\n\n    while (uuidsToCheck.size > 0) {\n\n      const [currentPoint] = uuidsToCheck\n      uuidsToCheck.delete(currentPoint)\n\n      for (const newPointToCheck of this.getPointByUUID(currentPoint)[to]) {\n        if(!checkedUuids.has(newPointToCheck))\n          uuidsToCheck.add(newPointToCheck)\n      }\n      \n      checkedUuids.add(currentPoint)\n      callback(currentPoint)\n    }\n  }\n\n  isBelowThen(point) {\n    let isPoint = false\n\n    this.eachPointsTo(uuid => isPoint ||= (uuid === point.uuid), \"linesAbove\")\n\n    return isPoint\n  }\n\n  isAboveThen(point) {\n    let isPoint = false\n\n    this.eachPointsTo(uuid => isPoint ||= (uuid === point.uuid), \"linesBelow\")\n\n    return isPoint\n  }\n}\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/pos-member/point.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractTransport: () => (/* reexport safe */ _src_Transport_index_js__WEBPACK_IMPORTED_MODULE_2__.AbstractTransport),\n/* harmony export */   EventFactory: () => (/* reexport safe */ _src_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.EventFactory),\n/* harmony export */   Member: () => (/* reexport safe */ _src_Member_index_js__WEBPACK_IMPORTED_MODULE_8__.Member),\n/* harmony export */   Provider: () => (/* reexport safe */ _src_Provider_index_js__WEBPACK_IMPORTED_MODULE_1__.Provider),\n/* harmony export */   TestTransport: () => (/* reexport safe */ _src_Transport_test_class_js__WEBPACK_IMPORTED_MODULE_3__.TestTransport),\n/* harmony export */   Types: () => (/* reexport safe */ _src_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types),\n/* harmony export */   events: () => (/* binding */ events)\n/* harmony export */ });\n/* harmony import */ var _src_Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n/* harmony import */ var _src_Provider_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Provider/index.js */ \"./node_modules/@ellementul/uee-core/src/Provider/index.js\");\n/* harmony import */ var _src_Transport_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/Transport/index.js */ \"./node_modules/@ellementul/uee-core/src/Transport/index.js\");\n/* harmony import */ var _src_Transport_test_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Transport/test-class.js */ \"./node_modules/@ellementul/uee-core/src/Transport/test-class.js\");\n/* harmony import */ var _src_Member_events_change_state_event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/Member/events/change_state_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/change_state_event.js\");\n/* harmony import */ var _src_Member_events_connected_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Member/events/connected_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/connected_event.js\");\n/* harmony import */ var _src_Member_events_error_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/Member/events/error_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/error_event.js\");\n/* harmony import */ var _src_Member_events_log_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Member/events/log_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/log_event.js\");\n/* harmony import */ var _src_Member_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/Member/index.js */ \"./node_modules/@ellementul/uee-core/src/Member/index.js\");\n\r\n\r\n\r\n\r\n\r\n;\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst events = {\r\n  changeEvent: _src_Member_events_change_state_event_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\r\n  change: _src_Member_events_change_state_event_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\r\n  connectEvent: _src_Member_events_connected_event_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\r\n  connect: _src_Member_events_connected_event_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\r\n  errorEvent: _src_Member_events_error_event_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\r\n  error: _src_Member_events_error_event_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\r\n  logEvent: _src_Member_events_log_event_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\r\n  log: _src_Member_events_log_event_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\r\n}\r\n\r\n_src_Member_index_js__WEBPACK_IMPORTED_MODULE_8__.Member.events = events\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Event/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Event/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventFactory: () => (/* binding */ EventFactory),\n/* harmony export */   Types: () => (/* reexport safe */ _ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/message-types */ \"./node_modules/@ellementul/message-types/index.js\");\n/* harmony import */ var _ellementul_uuid_by_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ellementul/uuid-by-string */ \"./node_modules/@ellementul/uuid-by-string/index.js\");\n\r\n\r\n\r\nfunction EventFactory(type) {\r\n  if(!_ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isType(type))\r\n    throw new TypeError(\"The type isn't type!\")\r\n\r\n  const callbacks = new Map\r\n  const limits = new Map\r\n\r\n  return {\r\n    get type() {\r\n      return type\r\n    },\r\n    create: () => {\r\n      return type.rand()\r\n    },\r\n    toJSON: () => {\r\n      return { type: type.toJSON() }\r\n    },\r\n    sign: () => {\r\n      return (0,_ellementul_uuid_by_string__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(type.toJSON(), 5)\r\n    },\r\n    isValid: (payload) => {\r\n      return !type.test(payload)\r\n    },\r\n    isValidError: (payload) => {\r\n      return type.test(payload)\r\n    },\r\n    on: (id, callback, limit = -1) => {\r\n      if(typeof callback === \"function\") {\r\n        callbacks.set(id, callback)\r\n\r\n        if(limit >= 0)\r\n          limits.set(id, limit)\r\n      }\r\n      else {\r\n        throw new TypeError(\"The recieve callback isn't function!\")\r\n      }\r\n    },\r\n    off: (id) => {\r\n      callbacks.delete(id)\r\n      limits.delete(id)\r\n    },\r\n    call: payload => {\r\n      for (let [id, callback] of callbacks) {\r\n        if(limits.has(id)) {\r\n          if(limits.get(id) <= 0) {\r\n            callbacks.delete(id)\r\n            limits.delete(id)\r\n            continue\r\n          }\r\n          else {\r\n            limits.set(id, limits.get(id) - 1)\r\n          }\r\n        }\r\n\r\n        callback(payload)\r\n      }\r\n    },\r\n    clone: function() {\r\n      return EventFactory(this.type)\r\n    }\r\n  }\r\n}\r\n\r\nEventFactory.fromJSON = function (json) {\r\n  if(typeof json == \"string\")\r\n\t\t\tjson = JSON.parse(json)\r\n  \r\n  const type = _ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__[\"default\"].outJSON(json.type)\r\n  return EventFactory(type)\r\n}\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Event/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Member/events/change_state_event.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Member/events/change_state_event.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n\r\n\r\nconst type = _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\r\n  system: \"Cooperation\",\r\n  entity: \"Member\",\r\n  state: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def(),\r\n  role: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def(),\r\n  uuid: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def()\r\n}, true)\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Member/events/change_state_event.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Member/events/connected_event.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Member/events/connected_event.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n\r\n\r\nconst type = _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\r\n  system: \"Cooperation\",\r\n  entity: \"Member\",\r\n  state: \"Connected\",\r\n  role: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def(),\r\n  uuid: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def()\r\n})\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Member/events/connected_event.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Member/events/error_event.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Member/events/error_event.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n\r\n\r\nconst type = _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\r\n  system: \"Logging\",\r\n  entity: \"Error\",\r\n  state: \r\n  {\r\n    name: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def(),\r\n  }\r\n}, true)\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Member/events/error_event.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Member/events/log_event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Member/events/log_event.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n\r\n\r\nconst type = _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\r\n  system: \"Logging\",\r\n  entity: _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def()\r\n}, true)\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_Event_index_js__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Member/events/log_event.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Member/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Member/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Member: () => (/* binding */ Member)\n/* harmony export */ });\n/* harmony import */ var mergician__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mergician */ \"./node_modules/mergician/dist/mergician.mjs\");\n/* harmony import */ var _Event_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/index.js */ \"./node_modules/@ellementul/uee-core/src/Event/index.js\");\n/* harmony import */ var _events_connected_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/connected_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/connected_event.js\");\n/* harmony import */ var _events_error_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/error_event.js */ \"./node_modules/@ellementul/uee-core/src/Member/events/error_event.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass Member {\r\n  constructor() {\r\n    this._uuid = _Event_index_js__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def().rand()\r\n\r\n    this._provider = null\r\n    this._pre_init_events = []\r\n    this._pre_init_messages = []\r\n\r\n    this.listeningEvents = new Set\r\n\r\n    this.onEvent = this.onEventInConstructor\r\n    this.offEvent = this.offEventInConstructor\r\n  }\r\n\r\n  get uuid() {\r\n    return this._uuid\r\n  }\r\n\r\n  wrapCallback(callback) {\r\n    return payload => {\r\n      try {\r\n        callback(payload)\r\n      } catch (error) {\r\n        if(error instanceof Error)\r\n          this.send(_events_error_event_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\r\n            state: {\r\n              name: error.name,\r\n              message: error.message,\r\n              stack: error.stack\r\n            }\r\n          })\r\n        else\r\n          throw error\r\n      }\r\n    }\r\n  }\r\n\r\n  onEventInConstructor(event, callback, limit = -1) {\r\n    const signEvent = event.sign()\r\n\r\n    if(this.listeningEvents.has(signEvent))\r\n      throw new Error(\"Duplicated define callback for event! You can delete old callback via offEvent method and define new callback again\")\r\n\r\n    if(signEvent !== _events_error_event_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sign())\r\n      callback = this.wrapCallback(callback)\r\n\r\n    if(this._provider)\r\n      this._provider.onEvent(event, callback, this.uuid, limit)\r\n    else\r\n      this._pre_init_events.push([event, callback, this.uuid, limit])\r\n\r\n    this.listeningEvents.add(signEvent)\r\n  }\r\n\r\n  onEventInRuntime(event, callback, limit = 1) {\r\n    const signEvent = event.sign()\r\n\r\n    if(this.listeningEvents.has(signEvent))\r\n      throw new Error\r\n\r\n    if(signEvent !== _events_error_event_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sign())\r\n      callback = this.wrapCallback(callback)\r\n\r\n    this._provider.onEvent(event, callback, this.uuid, limit)\r\n    this.listeningEvents.add(signEvent)\r\n  }\r\n\r\n  offEventInConstructor() {\r\n    throw new Error(\"Only after setting provider!\")\r\n  }\r\n\r\n  offEventInRuntime(event) {\r\n    this.listeningEvents.delete(event.sign())\r\n    this._provider.offEvent(event, this.uuid)\r\n  }\r\n\r\n  sendEvent(payload) {\r\n    if(this._provider)\r\n      this._provider.sendEvent(payload)\r\n    else\r\n      this._pre_init_messages.push(payload)\r\n  }\r\n\r\n  send(event, payload) {\r\n    const signEvent = event.sign()\r\n\r\n    if(this.listeningEvents.has(signEvent))\r\n      console.warn(\"You send event what this member listens, it may be cycle in calls of one event!\")\r\n\r\n    const template = event.create()\r\n    let full_message\r\n\r\n    const merge = (0,mergician__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\r\n      filter: ({ srcVal, targetVal }) => {\r\n        if(Array.isArray(srcVal) && Array.isArray(targetVal))\r\n          return srcVal\r\n      }\r\n    }) \r\n\r\n    if(payload instanceof Object)\r\n      full_message = merge(template, payload)\r\n    else if(!payload)\r\n      full_message = template\r\n    else\r\n      throw new Error(\"This function waits for second argument is object to merge with template. Please, use sendEvent method for other cases.\")\r\n\r\n    const validError = event.isValidError(full_message)\r\n    if(validError)\r\n      throw new TypeError(`\r\n        Invalid payload!\r\n        Data: ${JSON.stringify({\r\n          validError,\r\n          template,\r\n          payload\r\n        }, null, 2)}\r\n      `)\r\n\r\n    this.sendEvent(full_message)\r\n  }\r\n\r\n  setProvider(provider) {\r\n    this._provider = provider\r\n\r\n    this._pre_init_events.forEach(params => {\r\n      this._provider.onEvent(...params)\r\n    })\r\n    this._pre_init_events = []\r\n\r\n    this._pre_init_messages.forEach(payload => {\r\n      this._provider.sendEvent(payload)\r\n    })\r\n    this._pre_init_messages = []\r\n\r\n    this.onEvent = this.onEventInRuntime\r\n    this.offEvent = this.offEventInRuntime\r\n\r\n    this.send(_events_connected_event_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\r\n      role: this.getRole(),\r\n      uuid: this._uuid\r\n    })\r\n  }\r\n\r\n  getRole() {\r\n    return this.role || \"MemberWithoutRole\"\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Member/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Provider/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Provider/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/message-types */ \"./node_modules/@ellementul/message-types/index.js\");\n\r\n\r\nconst getUuid = _ellementul_message_types__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UUID.Def().rand\r\n\r\nclass Provider {\r\n  constructor () {\r\n    this.uuid = getUuid()\r\n\r\n    this._listenerEvents = new Map\r\n    this._logging = null\r\n  }\r\n\r\n  setTransport (transport) {\r\n    transport.onRecieve( event => {\r\n      if(event.from === this.uuid)\r\n        return\r\n        \r\n      this.recieveEvent(event.data) \r\n    })\r\n\r\n    this.sendTransport = event => {\r\n      transport.send({\r\n        data: event,\r\n        from: this.uuid\r\n      })\r\n    }\r\n  }\r\n\r\n  onEvent(event, callback, id, limit = -1) {\r\n    id = id || callback\r\n    const signature = event.sign()\r\n    \r\n    if(!this._listenerEvents.has(signature))\r\n      this._listenerEvents.set(signature, event.clone())\r\n\r\n    this._listenerEvents.get(signature).on(id, callback, limit)\r\n  }\r\n\r\n  offEvent(event, id) {\r\n    const signature = event.sign()\r\n    \r\n    if(!this._listenerEvents.has(signature))\r\n      return\r\n\r\n    this._listenerEvents.get(signature).off(id)\r\n  }\r\n\r\n  sendEvent(payload) {\r\n    const isLocal = payload.access == \"Local\"\r\n\r\n    if(!isLocal && this.sendTransport)\r\n      this.sendTransport(payload)\r\n\r\n    this.recieveEvent(payload)\r\n  }\r\n\r\n  recieveEvent (payload) {\r\n    this.log(payload)\r\n\r\n    this._listenerEvents.forEach((event, sign) => {\r\n      if(event.isValid(payload))\r\n        event.call(payload)\r\n    })\r\n  }\r\n\r\n  setLogging(logging) {\r\n    if(typeof logging === \"function\")\r\n      this._logging = logging\r\n    else\r\n      throw new TypeError(\"The recieve logging callback isn't function!\")\r\n  }\r\n\r\n  log (payload) {\r\n    if(this._logging) {\r\n      let events = new Map\r\n\r\n      this._listenerEvents.forEach((event, sign) => {\r\n        if(event.isValid(payload))\r\n          events.set(sign, event.toJSON())\r\n      })\r\n\r\n      this._logging({ message: payload, triggeredEvents: events })\r\n    }\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Provider/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Transport/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Transport/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractTransport: () => (/* binding */ AbstractTransport)\n/* harmony export */ });\nclass AbstractTransport {\r\n  send () { throw new Error('This abstract method should be overwrite!')  } \r\n  onRecieve  () { throw new Error('This abstract method should be overwrite!')  } \r\n}\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Transport/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uee-core/src/Transport/test-class.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ellementul/uee-core/src/Transport/test-class.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TestTransport: () => (/* binding */ TestTransport)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@ellementul/uee-core/src/Transport/index.js\");\n\r\n\r\nclass TestTransport extends _index_js__WEBPACK_IMPORTED_MODULE_0__.AbstractTransport {\r\n\r\n  constructor (done, expectingEvents, log) {\r\n    super()\r\n\r\n    this.finish = () => { done() }\r\n    this.eventCallbacks = []\r\n\r\n    if(expectingEvents.length < 1)\r\n      throw \"Minimum is one expecting event!\"\r\n\r\n    this.expectingEvents = new Set(expectingEvents.map( event => JSON.stringify(event) ))\r\n    \r\n    this.log = log ? msg => log(`Test Transport: \\n   ${msg} \\n`) : () => {}\r\n  }\r\n\r\n  send (event) {\r\n    this.checkEvent(event)\r\n    process.nextTick(\r\n      () => this.eventCallbacks.forEach(eventCallback => eventCallback(event))\r\n    )\r\n  }\r\n\r\n  onRecieve (eventCallback) {\r\n    this.log('Connected event callback...')\r\n    this.eventCallbacks.push(event => eventCallback(event))\r\n  }\r\n\r\n  checkEvent (event) {\r\n    if(this.expectingEvents.has(JSON.stringify(event.data)))\r\n      this.expectingEvents.delete(JSON.stringify(event.data))\r\n    else\r\n      throw `Invalid event: ${JSON.stringify(event.data)}`\r\n\r\n    if(this.expectingEvents.size == 0)\r\n      this.finish()\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uee-core/src/Transport/test-class.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/Environment/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/Environment/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnitedEventsEnv: () => (/* binding */ UnitedEventsEnv)\n/* harmony export */ });\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n\nconst { errorEvent } = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.events\n\nclass UnitedEventsEnv {\n  constructor(room) {\n    if(typeof room !== \"object\") throw new TypeError(\"Constructor waits for object of class Room!\")\n\n    this.room = room\n\n    this.baseUrl = null\n  }\n\n  build(transport, env = []) {\n    const baseUrl = transport ? transport.url : this.baseUrl\n    this.baseUrl = baseUrl\n\n    this.getConfig({ baseUrl, env })\n    .then(config => {\n      this.room.build(config)\n\n      if(transport)\n        this.room.provider.setTransport(transport)\n    })\n    .catch(() => { throw new Error(`I cannot load config from ${baseUrl}`) })\n    \n  }\n\n  run() {\n    const baseUrl = this.baseUrl\n    this.getConfig({ baseUrl })\n    .then(config => {\n      this.room.open(config)\n    })\n    .catch(() => { throw new Error(`I cannot load config from ${baseUrl}`) })\n  }\n\n  async getConfig({ baseUrl = './' } = {}) {\n\n    const response = await fetch(baseUrl + 'uee.config.json')\n    const config = await response.json()\n    \n    return {\n      ...config,\n      env:  { baseUrl }\n    }\n  }\n\n  setupLogging({ \n    logging = null,\n    isShowErrors = true\n  } = {}) {\n    if(logging && isShowErrors) {\n      this.room.provider.setLogging(payload => {\n        this.showErrors(payload)\n        logging(payload)\n      })\n    }\n    else if(logging) {\n      this.room.provider.setLogging(logging)\n    }\n    else if(isShowErrors) {\n      this.room.provider.setLogging(payload => this.showErrors(payload))\n    }\n  }\n  showErrors(payload) {\n    if(errorEvent.isValid(payload.message))\n      console.error(payload)\n  }\n}\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/Environment/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/MockMember/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/MockMember/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockMember: () => (/* binding */ MockMember)\n/* harmony export */ });\nfunction MockMember(Member, spyingEvents) {\n  return class FakeMember extends Member {\n    constructor() {\n      super(...arguments)\n\n      spyingEvents.forEach(event => {\n        this.onEvent(event[0], event[1])\n      })\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/MockMember/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/Room/events/build-room.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/Room/events/build-room.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n\n\nconst type = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  access: \"Local\",\n  system: \"Cooperation\",\n  entity: \"Room\",\n  state: \"Builded\",\n  config: _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({}, true)\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/Room/events/build-room.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/Room/events/open-room.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/Room/events/open-room.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n\n\nconst type = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({\n  access: \"Public\",\n  system: \"Cooperation\",\n  entity: \"Room\",\n  uuid: _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def(),\n  state: \"Open\",\n  config: _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.Object.Def({}, true)\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.EventFactory)(type));\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/Room/events/open-room.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/Room/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/Room/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   events: () => (/* binding */ events)\n/* harmony export */ });\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n/* harmony import */ var _events_build_room_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/build-room.js */ \"./node_modules/@ellementul/united-events-environment/Room/events/build-room.js\");\n/* harmony import */ var _events_open_room_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/open-room.js */ \"./node_modules/@ellementul/united-events-environment/Room/events/open-room.js\");\n\n\n\n\nconst INIT = Symbol()\nconst BUILDED = Symbol()\nconst OPENED = Symbol()\n\nclass Room {\n  constructor({ provider } = {}) {\n    this.uuid = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.UUID.Def().rand()\n    this.provider = provider || new _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Provider\n\n    this.members = new Map\n    this.state = INIT\n  }\n\n  addMember(MemberConstructor) {\n    if(this.state !== INIT)\n      throw new Error(\"The room is builded already! You cannot add new members now.\")\n\n    const member = new MemberConstructor\n    this.members.set(member.uuid, member)\n  }\n\n  build(config) {\n    if(this.state === BUILDED)\n      throw new Error(\"The room is builded already!\")\n    else\n      this.state = BUILDED\n\n    for (const [_, member] of this.members) {\n      member.setProvider(this.provider)\n    }\n    this.provider.sendEvent({\n      ..._events_build_room_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(),\n      config\n  })\n  }\n\n  open(config) {\n    if(this.state !== BUILDED)\n      throw new Error(\"The room isn't builded yet! Run 'build' method on room.\")\n\n    if(this.state === OPENED)\n      console.warn(\"Repeat opening room!\")\n\n    this.provider.sendEvent({ \n      ..._events_open_room_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(),\n      uuid: this.uuid,\n      config\n    })\n  }\n}\nconst events = { buildEvent: _events_build_room_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], openEvent: _events_open_room_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] }\nRoom.events = events\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/Room/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/StateMember/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/StateMember/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StateMember: () => (/* binding */ StateMember),\n/* harmony export */   events: () => (/* reexport safe */ _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.events)\n/* harmony export */ });\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n\n\nconst { changeEvent } = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.events\nconst stateType = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Types.Key.Def()\n\nclass StateMember extends _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.Member {\n  constructor(states) {\n    super()\n\n    this.states = new Set\n\n    for (const state of states) {\n      const validError = stateType.test(state)\n      if(validError)\n        throw new TypeError(`Invalid type state! TypeError: ${JSON.stringify(validError, null, 2)}`)\n      \n      this.states.add(state)\n    }\n\n    if(this.states.size < 1)\n      throw new TypeError('You must have at least one beginning state for StateMember!')\n\n    this.state = states[0]\n  }\n\n  validState(state) {\n    return this.states.has(state)\n  }\n\n  invalidState(state) {\n    throw new TypeError(`Got invalid state: ${state}! List valid states: ${[...this.states]}`)\n  }\n\n  isState(state) {\n    if(!this.validState(state))\n      this.invalidState(state)\n      \n    return this.state === state\n  }\n\n  setState(state) {\n    if(!this.validState(state))\n      this.invalidState(state)\n      \n    \n    this.state = state\n    this.send(changeEvent, { state })\n  }\n\n  onEventForState(event, callback, state, limit) {\n    if(!this.validState(state))\n      this.invalidState(state)\n\n    const warpCallback = payload => {\n      if(this.state === state) callback(payload)\n    }\n  \n    this.onEvent(event, warpCallback, limit)\n  }\n\n}\n\nStateMember.events = _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_0__.events\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/StateMember/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/united-events-environment/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ellementul/united-events-environment/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventFactory: () => (/* reexport safe */ _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__.EventFactory),\n/* harmony export */   Member: () => (/* reexport safe */ _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__.Member),\n/* harmony export */   MockMember: () => (/* reexport safe */ _MockMember_index_js__WEBPACK_IMPORTED_MODULE_0__.MockMember),\n/* harmony export */   Provider: () => (/* reexport safe */ _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__.Provider),\n/* harmony export */   Room: () => (/* reexport safe */ _Room_index_js__WEBPACK_IMPORTED_MODULE_2__.Room),\n/* harmony export */   StateMember: () => (/* reexport safe */ _StateMember_index_js__WEBPACK_IMPORTED_MODULE_1__.StateMember),\n/* harmony export */   Types: () => (/* reexport safe */ _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__.Types),\n/* harmony export */   UnitedEventsEnv: () => (/* reexport safe */ _Environment_index_js__WEBPACK_IMPORTED_MODULE_3__.UnitedEventsEnv),\n/* harmony export */   events: () => (/* binding */ events)\n/* harmony export */ });\n/* harmony import */ var _MockMember_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MockMember/index.js */ \"./node_modules/@ellementul/united-events-environment/MockMember/index.js\");\n/* harmony import */ var _StateMember_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateMember/index.js */ \"./node_modules/@ellementul/united-events-environment/StateMember/index.js\");\n/* harmony import */ var _Room_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Room/index.js */ \"./node_modules/@ellementul/united-events-environment/Room/index.js\");\n/* harmony import */ var _Environment_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Environment/index.js */ \"./node_modules/@ellementul/united-events-environment/Environment/index.js\");\n/* harmony import */ var _ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ellementul/uee-core */ \"./node_modules/@ellementul/uee-core/index.js\");\n\n\n\n\n\n;\n\n\nconst events = {\n  ..._ellementul_uee_core__WEBPACK_IMPORTED_MODULE_4__.events,\n  ..._Room_index_js__WEBPACK_IMPORTED_MODULE_2__.events\n}\n\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/united-events-environment/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uuid-by-string/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ellementul/uuid-by-string/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/index.js */ \"./node_modules/@ellementul/uuid-by-string/src/index.js\");\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uuid-by-string/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uuid-by-string/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ellementul/uuid-by-string/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ \"./node_modules/@ellementul/uuid-by-string/src/lib.js\");\n\r\n\r\n/** Uin8Array with zero items */\r\nvar EMPTY_UINT8_ARRAY = new Uint8Array(0);\r\n\r\nfunction generateUuid(target) {\r\n  if (typeof target !== 'string') {\r\n    throw TypeError('Value must be string');\r\n  }\r\n\r\n  // Getting hash\r\n  var hash = (0,_lib_js__WEBPACK_IMPORTED_MODULE_0__.sha1Hash)(target)\r\n  return (0,_lib_js__WEBPACK_IMPORTED_MODULE_0__.hashToUuid)(hash)\r\n}\r\n\r\n/**\r\n * Export module\r\n */\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateUuid);\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uuid-by-string/src/index.js?");

/***/ }),

/***/ "./node_modules/@ellementul/uuid-by-string/src/lib.js":
/*!************************************************************!*\
  !*** ./node_modules/@ellementul/uuid-by-string/src/lib.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashToUuid: () => (/* binding */ hashToUuid),\n/* harmony export */   sha1Hash: () => (/* binding */ sha1Hash)\n/* harmony export */ });\n/* harmony import */ var jssha__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jssha */ \"./node_modules/jssha/dist/sha.mjs\");\n\r\n\r\n/** List of hex digit for fast accessing by index */\r\nvar HEX_DIGITS = '0123456789abcdef'.split('');\r\n\r\nvar uint8ToHex = function (ubyte) {\r\n  var first = ubyte >> 4;\r\n  var second = ubyte - (first << 4);\r\n\r\n  return HEX_DIGITS[first] + HEX_DIGITS[second];\r\n};\r\n\r\nvar uint8ArrayToHex = function (buf) {\r\n  var out = '';\r\n\r\n  for (var i = 0; i < buf.length; i++) {\r\n    out += uint8ToHex(buf[i]);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nvar sha1Hash = function (text) {\r\n  const shaObj = new jssha__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"SHA-1\", \"TEXT\", { encoding: \"UTF8\" })\r\n  shaObj.update(text)\r\n  return shaObj.getHash(\"UINT8ARRAY\")\r\n}\r\n\r\nvar hashToUuid = function (hashBuffer) {\r\n  return (\r\n    // The low field of the timestamp\r\n    uint8ArrayToHex(hashBuffer.slice(0, 4)) +\r\n    '-' +\r\n    // The middle field of the timestamp\r\n    uint8ArrayToHex(hashBuffer.slice(4, 6)) +\r\n    '-' +\r\n    // The high field of the timestamp multiplexed with the version number\r\n    uint8ToHex((hashBuffer[6] & 0x0f) | parseInt(5 * 10, 16)) +\r\n    uint8ToHex(hashBuffer[7]) +\r\n    '-' +\r\n    // The high field of the clock sequence multiplexed with the variant\r\n    uint8ToHex((hashBuffer[8] & 0x3f) | 0x80) +\r\n    // The low field of the clock sequence\r\n    uint8ToHex(hashBuffer[9]) +\r\n    '-' +\r\n    //  The spatially unique node identifier\r\n    uint8ArrayToHex(hashBuffer.slice(10, 16))\r\n  );\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://App/./node_modules/@ellementul/uuid-by-string/src/lib.js?");

/***/ }),

/***/ "./node_modules/jssha/dist/sha.mjs":
/*!*****************************************!*\
  !*** ./node_modules/jssha/dist/sha.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ht)\n/* harmony export */ });\n/**\n * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,\n * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.\n *\n * Copyright 2008-2023 Brian Turek, 1998-2009 Paul Johnston & Contributors\n * Distributed under the BSD License\n * See http://caligatio.github.com/jsSHA/ for more information\n */\nconst t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",n=\"ARRAYBUFFER not supported by this environment\",e=\"UINT8ARRAY not supported by this environment\";function r(t,n,e,r){let i,s,o;const h=n||[0],u=(e=e||0)>>>3,w=-1===r?3:0;for(i=0;i<t.length;i+=1)o=i+u,s=o>>>2,h.length<=s&&h.push(0),h[s]|=t[i]<<8*(w+r*(o%4));return{value:h,binLen:8*t.length+e}}function i(i,s,o){switch(s){case\"UTF8\":case\"UTF16BE\":case\"UTF16LE\":break;default:throw new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\")}switch(i){case\"HEX\":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;if(0!=t.length%2)throw new Error(\"String of HEX type must be in byte increments\");const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(i=0;i<t.length;i+=2){if(s=parseInt(t.substr(i,2),16),isNaN(s))throw new Error(\"String of HEX type contains invalid characters\");for(h=(i>>>1)+w,o=h>>>2;u.length<=o;)u.push(0);u[o]|=s<<8*(c+r*(h%4))}return{value:u,binLen:4*t.length+e}}(t,n,e,o)};case\"TEXT\":return function(t,n,e){return function(t,n,e,r,i){let s,o,h,u,w,c,f,a,l=0;const A=e||[0],E=(r=r||0)>>>3;if(\"UTF8\"===n)for(f=-1===i?3:0,h=0;h<t.length;h+=1)for(s=t.charCodeAt(h),o=[],128>s?o.push(s):2048>s?(o.push(192|s>>>6),o.push(128|63&s)):55296>s||57344<=s?o.push(224|s>>>12,128|s>>>6&63,128|63&s):(h+=1,s=65536+((1023&s)<<10|1023&t.charCodeAt(h)),o.push(240|s>>>18,128|s>>>12&63,128|s>>>6&63,128|63&s)),u=0;u<o.length;u+=1){for(c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=o[u]<<8*(f+i*(c%4)),l+=1}else for(f=-1===i?2:0,a=\"UTF16LE\"===n&&1!==i||\"UTF16LE\"!==n&&1===i,h=0;h<t.length;h+=1){for(s=t.charCodeAt(h),!0===a&&(u=255&s,s=u<<8|s>>>8),c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=s<<8*(f+i*(c%4)),l+=2}return{value:A,binLen:8*l+r}}(t,s,n,e,o)};case\"B64\":return function(n,e,r){return function(n,e,r,i){let s,o,h,u,w,c,f,a=0;const l=e||[0],A=(r=r||0)>>>3,E=-1===i?3:0,H=n.indexOf(\"=\");if(-1===n.search(/^[a-zA-Z0-9=+/]+$/))throw new Error(\"Invalid character in base-64 string\");if(n=n.replace(/=/g,\"\"),-1!==H&&H<n.length)throw new Error(\"Invalid '=' found in base-64 string\");for(o=0;o<n.length;o+=4){for(w=n.substr(o,4),u=0,h=0;h<w.length;h+=1)s=t.indexOf(w.charAt(h)),u|=s<<18-6*h;for(h=0;h<w.length-1;h+=1){for(f=a+A,c=f>>>2;l.length<=c;)l.push(0);l[c]|=(u>>>16-8*h&255)<<8*(E+i*(f%4)),a+=1}}return{value:l,binLen:8*a+r}}(n,e,r,o)};case\"BYTES\":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(s=0;s<t.length;s+=1)i=t.charCodeAt(s),h=s+w,o=h>>>2,u.length<=o&&u.push(0),u[o]|=i<<8*(c+r*(h%4));return{value:u,binLen:8*t.length+e}}(t,n,e,o)};case\"ARRAYBUFFER\":try{new ArrayBuffer(0)}catch(t){throw new Error(n)}return function(t,n,e){return function(t,n,e,i){return r(new Uint8Array(t),n,e,i)}(t,n,e,o)};case\"UINT8ARRAY\":try{new Uint8Array(0)}catch(t){throw new Error(e)}return function(t,n,e){return r(t,n,e,o)};default:throw new Error(\"format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY\")}}function s(r,i,s,o){switch(r){case\"HEX\":return function(t){return function(t,n,e,r){const i=\"0123456789abcdef\";let s,o,h=\"\";const u=n/8,w=-1===e?3:0;for(s=0;s<u;s+=1)o=t[s>>>2]>>>8*(w+e*(s%4)),h+=i.charAt(o>>>4&15)+i.charAt(15&o);return r.outputUpper?h.toUpperCase():h}(t,i,s,o)};case\"B64\":return function(n){return function(n,e,r,i){let s,o,h,u,w,c=\"\";const f=e/8,a=-1===r?3:0;for(s=0;s<f;s+=3)for(u=s+1<f?n[s+1>>>2]:0,w=s+2<f?n[s+2>>>2]:0,h=(n[s>>>2]>>>8*(a+r*(s%4))&255)<<16|(u>>>8*(a+r*((s+1)%4))&255)<<8|w>>>8*(a+r*((s+2)%4))&255,o=0;o<4;o+=1)c+=8*s+6*o<=e?t.charAt(h>>>6*(3-o)&63):i.b64Pad;return c}(n,i,s,o)};case\"BYTES\":return function(t){return function(t,n,e){let r,i,s=\"\";const o=n/8,h=-1===e?3:0;for(r=0;r<o;r+=1)i=t[r>>>2]>>>8*(h+e*(r%4))&255,s+=String.fromCharCode(i);return s}(t,i,s)};case\"ARRAYBUFFER\":try{new ArrayBuffer(0)}catch(t){throw new Error(n)}return function(t){return function(t,n,e){let r;const i=n/8,s=new ArrayBuffer(i),o=new Uint8Array(s),h=-1===e?3:0;for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(h+e*(r%4))&255;return s}(t,i,s)};case\"UINT8ARRAY\":try{new Uint8Array(0)}catch(t){throw new Error(e)}return function(t){return function(t,n,e){let r;const i=n/8,s=-1===e?3:0,o=new Uint8Array(i);for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(s+e*(r%4))&255;return o}(t,i,s)};default:throw new Error(\"format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY\")}}const o=4294967296,h=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],u=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],w=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],c=\"Chosen SHA variant is not supported\",f=\"Cannot set numRounds with MAC\";function a(t,n){let e,r;const i=t.binLen>>>3,s=n.binLen>>>3,o=i<<3,h=4-i<<3;if(i%4!=0){for(e=0;e<s;e+=4)r=i+e>>>2,t.value[r]|=n.value[e>>>2]<<o,t.value.push(0),t.value[r+1]|=n.value[e>>>2]>>>h;return(t.value.length<<2)-4>=s+i&&t.value.pop(),{value:t.value,binLen:t.binLen+n.binLen}}return{value:t.value.concat(n.value),binLen:t.binLen+n.binLen}}function l(t){const n={outputUpper:!1,b64Pad:\"=\",outputLen:-1},e=t||{},r=\"Output length must be a multiple of 8\";if(n.outputUpper=e.outputUpper||!1,e.b64Pad&&(n.b64Pad=e.b64Pad),e.outputLen){if(e.outputLen%8!=0)throw new Error(r);n.outputLen=e.outputLen}else if(e.shakeLen){if(e.shakeLen%8!=0)throw new Error(r);n.outputLen=e.shakeLen}if(\"boolean\"!=typeof n.outputUpper)throw new Error(\"Invalid outputUpper formatting option\");if(\"string\"!=typeof n.b64Pad)throw new Error(\"Invalid b64Pad formatting option\");return n}function A(t,n,e,r){const s=t+\" must include a value and format\";if(!n){if(!r)throw new Error(s);return r}if(void 0===n.value||!n.format)throw new Error(s);return i(n.format,n.encoding||\"UTF8\",e)(n.value)}class E{constructor(t,n,e){const r=e||{};if(this.t=n,this.i=r.encoding||\"UTF8\",this.numRounds=r.numRounds||1,isNaN(this.numRounds)||this.numRounds!==parseInt(this.numRounds,10)||1>this.numRounds)throw new Error(\"numRounds must a integer >= 1\");this.o=t,this.h=[],this.u=0,this.l=!1,this.A=0,this.H=!1,this.S=[],this.p=[]}update(t){let n,e=0;const r=this.m>>>5,i=this.C(t,this.h,this.u),s=i.binLen,o=i.value,h=s>>>5;for(n=0;n<h;n+=r)e+this.m<=s&&(this.U=this.v(o.slice(n,n+r),this.U),e+=this.m);return this.A+=e,this.h=o.slice(e>>>5),this.u=s%this.m,this.l=!0,this}getHash(t,n){let e,r,i=this.R;const o=l(n);if(this.K){if(-1===o.outputLen)throw new Error(\"Output length must be specified in options\");i=o.outputLen}const h=s(t,i,this.T,o);if(this.H&&this.g)return h(this.g(o));for(r=this.F(this.h.slice(),this.u,this.A,this.L(this.U),i),e=1;e<this.numRounds;e+=1)this.K&&i%32!=0&&(r[r.length-1]&=16777215>>>24-i%32),r=this.F(r,i,0,this.B(this.o),i);return h(r)}setHMACKey(t,n,e){if(!this.M)throw new Error(\"Variant does not support HMAC\");if(this.l)throw new Error(\"Cannot set MAC key after calling update\");const r=i(n,(e||{}).encoding||\"UTF8\",this.T);this.k(r(t))}k(t){const n=this.m>>>3,e=n/4-1;let r;if(1!==this.numRounds)throw new Error(f);if(this.H)throw new Error(\"MAC key already set\");for(n<t.binLen/8&&(t.value=this.F(t.value,t.binLen,0,this.B(this.o),this.R));t.value.length<=e;)t.value.push(0);for(r=0;r<=e;r+=1)this.S[r]=909522486^t.value[r],this.p[r]=1549556828^t.value[r];this.U=this.v(this.S,this.U),this.A=this.m,this.H=!0}getHMAC(t,n){const e=l(n);return s(t,this.R,this.T,e)(this.Y())}Y(){let t;if(!this.H)throw new Error(\"Cannot call getHMAC without first setting MAC key\");const n=this.F(this.h.slice(),this.u,this.A,this.L(this.U),this.R);return t=this.v(this.p,this.B(this.o)),t=this.F(n,this.R,this.m,t,this.R),t}}function H(t,n){return t<<n|t>>>32-n}function S(t,n){return t>>>n|t<<32-n}function b(t,n){return t>>>n}function p(t,n,e){return t^n^e}function d(t,n,e){return t&n^~t&e}function m(t,n,e){return t&n^t&e^n&e}function C(t){return S(t,2)^S(t,13)^S(t,22)}function y(t,n){const e=(65535&t)+(65535&n);return(65535&(t>>>16)+(n>>>16)+(e>>>16))<<16|65535&e}function U(t,n,e,r){const i=(65535&t)+(65535&n)+(65535&e)+(65535&r);return(65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16))<<16|65535&i}function v(t,n,e,r,i){const s=(65535&t)+(65535&n)+(65535&e)+(65535&r)+(65535&i);return(65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16)+(s>>>16))<<16|65535&s}function R(t){return S(t,7)^S(t,18)^b(t,3)}function K(t){return S(t,6)^S(t,11)^S(t,25)}function T(t){return[1732584193,4023233417,2562383102,271733878,3285377520]}function g(t,n){let e,r,i,s,o,h,u;const w=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=0;u<80;u+=1)w[u]=u<16?t[u]:H(w[u-3]^w[u-8]^w[u-14]^w[u-16],1),h=u<20?v(H(e,5),d(r,i,s),o,1518500249,w[u]):u<40?v(H(e,5),p(r,i,s),o,1859775393,w[u]):u<60?v(H(e,5),m(r,i,s),o,2400959708,w[u]):v(H(e,5),p(r,i,s),o,3395469782,w[u]),o=s,s=i,i=H(r,30),r=e,e=h;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n}function F(t,n,e,r){let i;const s=15+(n+65>>>9<<4),h=n+e;for(;t.length<=s;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[s]=4294967295&h,t[s-1]=h/o|0,i=0;i<t.length;i+=16)r=g(t.slice(i,i+16),r);return r}let L=class extends E{constructor(t,n,e){if(\"SHA-1\"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.M=!0,this.g=this.Y,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=g,this.L=function(t){return t.slice()},this.B=T,this.F=F,this.U=[1732584193,4023233417,2562383102,271733878,3285377520],this.m=512,this.R=160,this.K=!1,r.hmacKey&&this.k(A(\"hmacKey\",r.hmacKey,this.T))}};function B(t){let n;return n=\"SHA-224\"==t?u.slice():w.slice(),n}function M(t,n){let e,r,i,s,o,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=n[5],w=n[6],c=n[7],l=0;l<64;l+=1)A[l]=l<16?t[l]:U(S(E=A[l-2],17)^S(E,19)^b(E,10),A[l-7],R(A[l-15]),A[l-16]),f=v(c,K(o),d(o,u,w),h[l],A[l]),a=y(C(e),m(e,r,i)),c=w,w=u,u=o,o=y(s,f),s=i,i=r,r=e,e=y(f,a);var E;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n[5]=y(u,n[5]),n[6]=y(w,n[6]),n[7]=y(c,n[7]),n}let k=class extends E{constructor(t,n,e){if(\"SHA-224\"!==t&&\"SHA-256\"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=M,this.L=function(t){return t.slice()},this.B=B,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=15+(n+65>>>9<<4),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=16)r=M(t.slice(s,s+16),r);return h=\"SHA-224\"===i?[r[0],r[1],r[2],r[3],r[4],r[5],r[6]]:r,h}(n,e,r,i,t)},this.U=B(t),this.m=512,this.R=\"SHA-224\"===t?224:256,this.K=!1,r.hmacKey&&this.k(A(\"hmacKey\",r.hmacKey,this.T))}};class Y{constructor(t,n){this.N=t,this.I=n}}function N(t,n){let e;return n>32?(e=64-n,new Y(t.I<<n|t.N>>>e,t.N<<n|t.I>>>e)):0!==n?(e=32-n,new Y(t.N<<n|t.I>>>e,t.I<<n|t.N>>>e)):t}function I(t,n){let e;return n<32?(e=32-n,new Y(t.N>>>n|t.I<<e,t.I>>>n|t.N<<e)):(e=64-n,new Y(t.I>>>n|t.N<<e,t.N>>>n|t.I<<e))}function X(t,n){return new Y(t.N>>>n,t.I>>>n|t.N<<32-n)}function z(t,n,e){return new Y(t.N&n.N^t.N&e.N^n.N&e.N,t.I&n.I^t.I&e.I^n.I&e.I)}function x(t){const n=I(t,28),e=I(t,34),r=I(t,39);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function _(t,n){let e,r;e=(65535&t.I)+(65535&n.I),r=(t.I>>>16)+(n.I>>>16)+(e>>>16);const i=(65535&r)<<16|65535&e;e=(65535&t.N)+(65535&n.N)+(r>>>16),r=(t.N>>>16)+(n.N>>>16)+(e>>>16);return new Y((65535&r)<<16|65535&e,i)}function O(t,n,e,r){let i,s;i=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I),s=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i>>>16);const o=(65535&s)<<16|65535&i;i=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(s>>>16),s=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i>>>16);return new Y((65535&s)<<16|65535&i,o)}function P(t,n,e,r,i){let s,o;s=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I)+(65535&i.I),o=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i.I>>>16)+(s>>>16);const h=(65535&o)<<16|65535&s;s=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(65535&i.N)+(o>>>16),o=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i.N>>>16)+(s>>>16);return new Y((65535&o)<<16|65535&s,h)}function V(t,n){return new Y(t.N^n.N,t.I^n.I)}function Z(t){const n=I(t,19),e=I(t,61),r=X(t,6);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function j(t){const n=I(t,1),e=I(t,8),r=X(t,7);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function q(t){const n=I(t,14),e=I(t,18),r=I(t,41);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}const D=[new Y(h[0],3609767458),new Y(h[1],602891725),new Y(h[2],3964484399),new Y(h[3],2173295548),new Y(h[4],4081628472),new Y(h[5],3053834265),new Y(h[6],2937671579),new Y(h[7],3664609560),new Y(h[8],2734883394),new Y(h[9],1164996542),new Y(h[10],1323610764),new Y(h[11],3590304994),new Y(h[12],4068182383),new Y(h[13],991336113),new Y(h[14],633803317),new Y(h[15],3479774868),new Y(h[16],2666613458),new Y(h[17],944711139),new Y(h[18],2341262773),new Y(h[19],2007800933),new Y(h[20],1495990901),new Y(h[21],1856431235),new Y(h[22],3175218132),new Y(h[23],2198950837),new Y(h[24],3999719339),new Y(h[25],766784016),new Y(h[26],2566594879),new Y(h[27],3203337956),new Y(h[28],1034457026),new Y(h[29],2466948901),new Y(h[30],3758326383),new Y(h[31],168717936),new Y(h[32],1188179964),new Y(h[33],1546045734),new Y(h[34],1522805485),new Y(h[35],2643833823),new Y(h[36],2343527390),new Y(h[37],1014477480),new Y(h[38],1206759142),new Y(h[39],344077627),new Y(h[40],1290863460),new Y(h[41],3158454273),new Y(h[42],3505952657),new Y(h[43],106217008),new Y(h[44],3606008344),new Y(h[45],1432725776),new Y(h[46],1467031594),new Y(h[47],851169720),new Y(h[48],3100823752),new Y(h[49],1363258195),new Y(h[50],3750685593),new Y(h[51],3785050280),new Y(h[52],3318307427),new Y(h[53],3812723403),new Y(h[54],2003034995),new Y(h[55],3602036899),new Y(h[56],1575990012),new Y(h[57],1125592928),new Y(h[58],2716904306),new Y(h[59],442776044),new Y(h[60],593698344),new Y(h[61],3733110249),new Y(h[62],2999351573),new Y(h[63],3815920427),new Y(3391569614,3928383900),new Y(3515267271,566280711),new Y(3940187606,3454069534),new Y(4118630271,4000239992),new Y(116418474,1914138554),new Y(174292421,2731055270),new Y(289380356,3203993006),new Y(460393269,320620315),new Y(685471733,587496836),new Y(852142971,1086792851),new Y(1017036298,365543100),new Y(1126000580,2618297676),new Y(1288033470,3409855158),new Y(1501505948,4234509866),new Y(1607167915,987167468),new Y(1816402316,1246189591)];function G(t){return\"SHA-384\"===t?[new Y(3418070365,u[0]),new Y(1654270250,u[1]),new Y(2438529370,u[2]),new Y(355462360,u[3]),new Y(1731405415,u[4]),new Y(41048885895,u[5]),new Y(3675008525,u[6]),new Y(1203062813,u[7])]:[new Y(w[0],4089235720),new Y(w[1],2227873595),new Y(w[2],4271175723),new Y(w[3],1595750129),new Y(w[4],2917565137),new Y(w[5],725511199),new Y(w[6],4215389547),new Y(w[7],327033209)]}function J(t,n){let e,r,i,s,o,h,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],h=n[5],u=n[6],w=n[7],a=0;a<80;a+=1)a<16?(l=2*a,A[a]=new Y(t[l],t[l+1])):A[a]=O(Z(A[a-2]),A[a-7],j(A[a-15]),A[a-16]),c=P(w,q(o),(H=h,S=u,new Y((E=o).N&H.N^~E.N&S.N,E.I&H.I^~E.I&S.I)),D[a],A[a]),f=_(x(e),z(e,r,i)),w=u,u=h,h=o,o=_(s,c),s=i,i=r,r=e,e=_(c,f);var E,H,S;return n[0]=_(e,n[0]),n[1]=_(r,n[1]),n[2]=_(i,n[2]),n[3]=_(s,n[3]),n[4]=_(o,n[4]),n[5]=_(h,n[5]),n[6]=_(u,n[6]),n[7]=_(w,n[7]),n}let Q=class extends E{constructor(t,n,e){if(\"SHA-384\"!==t&&\"SHA-512\"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=J,this.L=function(t){return t.slice()},this.B=G,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=31+(n+129>>>10<<5),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=32)r=J(t.slice(s,s+32),r);return h=\"SHA-384\"===i?[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I]:[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I,r[6].N,r[6].I,r[7].N,r[7].I],h}(n,e,r,i,t)},this.U=G(t),this.m=1024,this.R=\"SHA-384\"===t?384:512,this.K=!1,r.hmacKey&&this.k(A(\"hmacKey\",r.hmacKey,this.T))}};const W=[new Y(0,1),new Y(0,32898),new Y(2147483648,32906),new Y(2147483648,2147516416),new Y(0,32907),new Y(0,2147483649),new Y(2147483648,2147516545),new Y(2147483648,32777),new Y(0,138),new Y(0,136),new Y(0,2147516425),new Y(0,2147483658),new Y(0,2147516555),new Y(2147483648,139),new Y(2147483648,32905),new Y(2147483648,32771),new Y(2147483648,32770),new Y(2147483648,128),new Y(0,32778),new Y(2147483648,2147483658),new Y(2147483648,2147516545),new Y(2147483648,32896),new Y(0,2147483649),new Y(2147483648,2147516424)],$=[[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]];function tt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=[new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0)];return e}function nt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=t[n].slice();return e}function et(t,n){let e,r,i,s;const o=[],h=[];if(null!==t)for(r=0;r<t.length;r+=2)n[(r>>>1)%5][(r>>>1)/5|0]=V(n[(r>>>1)%5][(r>>>1)/5|0],new Y(t[r+1],t[r]));for(e=0;e<24;e+=1){for(s=tt(),r=0;r<5;r+=1)o[r]=(u=n[r][0],w=n[r][1],c=n[r][2],f=n[r][3],a=n[r][4],new Y(u.N^w.N^c.N^f.N^a.N,u.I^w.I^c.I^f.I^a.I));for(r=0;r<5;r+=1)h[r]=V(o[(r+4)%5],N(o[(r+1)%5],1));for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(n[r][i],h[r]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)s[i][(2*r+3*i)%5]=N(n[r][i],$[r][i]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(s[r][i],new Y(~s[(r+1)%5][i].N&s[(r+2)%5][i].N,~s[(r+1)%5][i].I&s[(r+2)%5][i].I));n[0][0]=V(n[0][0],W[e])}var u,w,c,f,a;return n}function rt(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r+1>>2]|=e<<8*(r+1),r+=1);return r=0!==r?r:1,i[0]|=r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}function it(t){return a(rt(t.binLen),t)}function st(t,n){let e,r=rt(n);r=a(r,t);const i=n>>>2,s=(i-r.value.length%i)%i;for(e=0;e<s;e++)r.value.push(0);return r.value}let ot=class extends E{constructor(t,n,e){let r=6,s=0;super(t,n,e);const o=e||{};if(1!==this.numRounds){if(o.kmacKey||o.hmacKey)throw new Error(f);if(\"CSHAKE128\"===this.o||\"CSHAKE256\"===this.o)throw new Error(\"Cannot set numRounds for CSHAKE variants\")}switch(this.T=1,this.C=i(this.t,this.i,this.T),this.v=et,this.L=nt,this.B=tt,this.U=tt(),this.K=!1,t){case\"SHA3-224\":this.m=s=1152,this.R=224,this.M=!0,this.g=this.Y;break;case\"SHA3-256\":this.m=s=1088,this.R=256,this.M=!0,this.g=this.Y;break;case\"SHA3-384\":this.m=s=832,this.R=384,this.M=!0,this.g=this.Y;break;case\"SHA3-512\":this.m=s=576,this.R=512,this.M=!0,this.g=this.Y;break;case\"SHAKE128\":r=31,this.m=s=1344,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case\"SHAKE256\":r=31,this.m=s=1088,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case\"KMAC128\":r=4,this.m=s=1344,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case\"KMAC256\":r=4,this.m=s=1088,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case\"CSHAKE128\":this.m=s=1344,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case\"CSHAKE256\":this.m=s=1088,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;default:throw new Error(c)}this.F=function(t,n,e,i,o){return function(t,n,e,r,i,s,o){let h,u,w=0;const c=[],f=i>>>5,a=n>>>5;for(h=0;h<a&&n>=i;h+=f)r=et(t.slice(h,h+f),r),n-=i;for(t=t.slice(h),n%=i;t.length<f;)t.push(0);for(h=n>>>3,t[h>>2]^=s<<h%4*8,t[f-1]^=2147483648,r=et(t,r);32*c.length<o&&(u=r[w%5][w/5|0],c.push(u.I),!(32*c.length>=o));)c.push(u.N),w+=1,0==64*w%i&&(et(null,r),w=0);return c}(t,n,0,i,s,r,o)},o.hmacKey&&this.k(A(\"hmacKey\",o.hmacKey,this.T))}O(t,n){const e=function(t){const n=t||{};return{funcName:A(\"funcName\",n.funcName,1,{value:[],binLen:0}),customization:A(\"Customization\",n.customization,1,{value:[],binLen:0})}}(t||{});n&&(e.funcName=n);const r=a(it(e.funcName),it(e.customization));if(0!==e.customization.binLen||0!==e.funcName.binLen){const t=st(r,this.m>>>3);for(let n=0;n<t.length;n+=this.m>>>5)this.U=this.v(t.slice(n,n+(this.m>>>5)),this.U),this.A+=this.m;return 4}return 31}X(t){const n=function(t){const n=t||{};return{kmacKey:A(\"kmacKey\",n.kmacKey,1),funcName:{value:[1128353099],binLen:32},customization:A(\"Customization\",n.customization,1,{value:[],binLen:0})}}(t||{});this.O(t,n.funcName);const e=st(it(n.kmacKey),this.m>>>3);for(let t=0;t<e.length;t+=this.m>>>5)this.U=this.v(e.slice(t,t+(this.m>>>5)),this.U),this.A+=this.m;this.H=!0}_(t){const n=a({value:this.h.slice(),binLen:this.u},function(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r>>2]|=e<<8*r,r+=1);return r=0!==r?r:1,i[r>>2]|=r<<8*r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}(t.outputLen));return this.F(n.value,n.binLen,this.A,this.L(this.U),t.outputLen)}};class ht{constructor(t,n,e){if(\"SHA-1\"==t)this.P=new L(t,n,e);else if(\"SHA-224\"==t||\"SHA-256\"==t)this.P=new k(t,n,e);else if(\"SHA-384\"==t||\"SHA-512\"==t)this.P=new Q(t,n,e);else{if(\"SHA3-224\"!=t&&\"SHA3-256\"!=t&&\"SHA3-384\"!=t&&\"SHA3-512\"!=t&&\"SHAKE128\"!=t&&\"SHAKE256\"!=t&&\"CSHAKE128\"!=t&&\"CSHAKE256\"!=t&&\"KMAC128\"!=t&&\"KMAC256\"!=t)throw new Error(c);this.P=new ot(t,n,e)}}update(t){return this.P.update(t),this}getHash(t,n){return this.P.getHash(t,n)}setHMACKey(t,n,e){this.P.setHMACKey(t,n,e)}getHMAC(t,n){return this.P.getHMAC(t,n)}}\n//# sourceMappingURL=sha.mjs.map\n\n\n//# sourceURL=webpack://App/./node_modules/jssha/dist/sha.mjs?");

/***/ }),

/***/ "./node_modules/mergician/dist/mergician.mjs":
/*!***************************************************!*\
  !*** ./node_modules/mergician/dist/mergician.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * mergician\n * v1.1.0\n * https://jhildenbiddle.github.io/mergician/\n * (c) 2022-2023 John Hildenbiddle\n * MIT license\n */\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// src/util.cjs\nvar require_util = __commonJS({\n  \"src/util.cjs\"(exports, module) {\n    function countOccurrences(...arrays) {\n      const countObj = {};\n      arrays.forEach((array) => {\n        array.forEach((v) => {\n          countObj[v] = v in countObj ? ++countObj[v] : 1;\n        });\n      });\n      return countObj;\n    }\n    function getInMultiple(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] > 1);\n    }\n    function getInAll(...arrays) {\n      return arrays.reduce(\n        (acc, curr) => acc.filter(Set.prototype.has, new Set(curr))\n      );\n    }\n    function getNotInMultiple(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] === 1);\n    }\n    function getNotInAll(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] < arrays.length);\n    }\n    function getObjectKeys(obj, includeProto = false) {\n      if (includeProto) {\n        const keys = [];\n        for (const key in obj) {\n          keys.push(key);\n        }\n        return keys;\n      } else {\n        return Object.keys(obj);\n      }\n    }\n    function isObject(value) {\n      return typeof value === \"object\" && value !== null && !Array.isArray(value);\n    }\n    function isPropDescriptor(obj) {\n      if (!isObject(obj)) {\n        return false;\n      }\n      const hasFlagKey = [\"writable\", \"enumerable\", \"configurable\"].some((key) => key in obj);\n      const hasMethod = [\"get\", \"set\"].some((key) => typeof obj[key] === \"function\");\n      const hasMethodKeys = [\"get\", \"set\"].every((key) => key in obj);\n      let isDescriptor = \"value\" in obj && hasFlagKey || hasMethod && (hasMethodKeys || hasFlagKey);\n      if (isDescriptor) {\n        const validKeys = [\n          \"configurable\",\n          \"get\",\n          \"set\",\n          \"enumerable\",\n          \"value\",\n          \"writable\"\n        ];\n        isDescriptor = Object.keys(obj).some((key) => !(key in validKeys));\n      }\n      return isDescriptor;\n    }\n    module.exports = {\n      countOccurrences,\n      getInMultiple,\n      getInAll,\n      getNotInMultiple,\n      getNotInAll,\n      getObjectKeys,\n      isObject,\n      isPropDescriptor\n    };\n  }\n});\n\n// src/index.cjs\nvar require_src = __commonJS({\n  \"src/index.cjs\"(exports, module) {\n    var {\n      getInMultiple,\n      getInAll,\n      getNotInMultiple,\n      getNotInAll,\n      getObjectKeys,\n      isObject,\n      isPropDescriptor\n    } = require_util();\n    var defaults = {\n      // Keys\n      onlyKeys: [],\n      skipKeys: [],\n      onlyCommonKeys: false,\n      onlyUniversalKeys: false,\n      skipCommonKeys: false,\n      skipUniversalKeys: false,\n      // Values\n      invokeGetters: false,\n      skipSetters: false,\n      // Arrays\n      appendArrays: false,\n      prependArrays: false,\n      dedupArrays: false,\n      sortArrays: false,\n      // Prototype\n      hoistProto: false,\n      // Callbacks\n      filter: Function.prototype,\n      beforeEach: Function.prototype,\n      afterEach: Function.prototype,\n      onCircular: Function.prototype\n    };\n    /**\n     * Deep recursive object merging with options to inspect, modify, and filter\n     * keys/values, merge arrays (append/prepend), and remove duplicate values from\n     * merged arrays. Returns new object without modifying sources (immutable).\n     *\n     * @preserve\n     *\n     * @example\n     * // Without options (use default option values)\n     * mergician(obj1, obj2, obj3, ...);\n     *\n     * @example\n     * // With options (defaults shown)\n     * mergician({\n     *   // Keys\n     *   onlyKeys: [],\n     *   skipKeys: [],\n     *   onlyCommonKeys: false,\n     *   onlyUniversalKeys: false,\n     *   skipCommonKeys: false,\n     *   skipUniversalKeys: false,\n     *   // Values\n     *   invokeGetters: false,\n     *   skipSetters: false,\n     *   // Arrays\n     *   appendArrays: false,\n     *   prependArrays: false,\n     *   dedupArrays: false,\n     *   sortArrays: false,\n     *   // Prototype\n     *   hoistProto: false,\n     *   // Callbacks\n     *   filter({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n     *   beforeEach({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n     *   afterEach({ depth, key, mergeVal, srcObj, targetObj }) {},\n     *   onCircular({ depth, key, srcObj, srcVal, targetObj, targetVal }) {}\n     * })(obj1, obj2, obj3, ...)\n     *\n     * @param {...object} optionsOrObjects - Options or objects to merge\n     * @param {array} [options.onlyKeys] - Exclusive array of keys to be merged\n     * (others are skipped)\n     * @param {array} [options.skipKeys] - Array of keys to skip (others are merged)\n     * @param {boolean} [options.onlyCommonKeys = false] - Merge only keys found in\n     * multiple objects (ignore single occurrence keys)\n     * @param {boolean} [options.onlyUniversalKeys = false] - Merge only keys found\n     * in all objects\n     * @param {boolean} [options.skipCommonKeys = false] - Skip keys found in\n     * multiple objects (merge only single occurrence keys)\n     * @param {boolean} [options.skipUniversalKeys = false] - Skip keys found in all\n     * objects (merge only common keys)\n     * @param {boolean} [options.invokeGetters = false] - Invoke \"getter\" methods\n     * and merge returned values\n     * @param {boolean} [options.skipSetters = false] - Skip \"setter\" methods during\n     * merge\n     * @param {boolean} [options.appendArrays = false] - Merge array values at the\n     * end of existing arrays\n     * @param {boolean} [options.prependArrays = false] - Merge array values at the\n     * beginning of existing arrays\n     * @param {boolean} [options.dedupArrays = false] - Remove duplicate array\n     * values in new merged object\n     * @param {boolean|function} [options.sortArrays = false] - Sort array values in\n     * new merged object\n     * @param {boolean} [options.hoistProto = false] - Clone prototype properties as\n     * direct properties of merged/cloned object\n     * @param {function} [options.filter] - Callback used to conditionally merge or\n     * skip a property. Return a \"truthy\" value to merge or a \"falsy\" value to skip.\n     * Return no value to proceed according to other option values.\n     * @param {function} [options.beforeEach] - Callback used for\n     * inspecting/modifying properties before merge. Return value is used as value\n     * to merge.\n     * @param {function} [options.afterEach] - Callback used for\n     * inspecting/modifying properties after merge. Return value is used as merged\n     * value.\n     * @param {function} [options.onCircular] - Callback used for handling circular\n     * object references during merge\n     * @returns {function|object} Merge function with options applied or new merged\n     * object\n     * @param {...object} [objects] - Objects to merge\n     * @returns {object} New merged object\n     */\n    function mergician(...optionsOrObjects) {\n      const options = arguments.length === 1 ? arguments[0] : {};\n      const settings = { ...defaults, ...options };\n      const dedupArrayMap = /* @__PURE__ */ new Map();\n      const sortArrayMap = /* @__PURE__ */ new Map();\n      const sortArrayFn = typeof settings.sortArrays === \"function\" ? settings.sortArrays : void 0;\n      const circularRefs = /* @__PURE__ */ new WeakMap();\n      let mergeDepth = 0;\n      function _getObjectKeys(obj) {\n        return getObjectKeys(obj, settings.hoistProto);\n      }\n      function _mergician(...objects) {\n        let mergeKeyList;\n        if (objects.length > 1) {\n          if (settings.onlyCommonKeys) {\n            mergeKeyList = getInMultiple(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.onlyUniversalKeys) {\n            mergeKeyList = getInAll(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.skipCommonKeys) {\n            mergeKeyList = getNotInMultiple(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.skipUniversalKeys) {\n            mergeKeyList = getNotInAll(...objects.map((obj) => _getObjectKeys(obj)));\n          }\n        }\n        if (!mergeKeyList && settings.onlyKeys.length) {\n          mergeKeyList = settings.onlyKeys;\n        }\n        if (mergeKeyList && mergeKeyList !== settings.onlyKeys && settings.onlyKeys.length) {\n          mergeKeyList = mergeKeyList.filter((key) => settings.onlyKeys.includes(key));\n        }\n        const newObj = objects.reduce((targetObj, srcObj) => {\n          circularRefs.set(srcObj, targetObj);\n          let keys = mergeKeyList || _getObjectKeys(srcObj);\n          if (settings.skipKeys.length) {\n            keys = keys.filter((key) => settings.skipKeys.indexOf(key) === -1);\n          }\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const targetVal = targetObj[key];\n            let isReturnVal = false;\n            let mergeVal;\n            if (key in srcObj === false) {\n              continue;\n            }\n            try {\n              mergeVal = srcObj[key];\n            } catch (err) {\n              console.error(err);\n              continue;\n            }\n            const srcDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n            const isSetterOnly = srcDescriptor && typeof srcDescriptor.set === \"function\" && typeof srcDescriptor.get !== \"function\";\n            if (isSetterOnly) {\n              if (!settings.skipSetters) {\n                srcDescriptor.configurable = true;\n                Object.defineProperty(targetObj, key, srcDescriptor);\n              }\n              continue;\n            }\n            if (settings.filter !== defaults.filter) {\n              const returnVal = settings.filter({\n                depth: mergeDepth,\n                key,\n                srcObj,\n                srcVal: mergeVal,\n                targetObj,\n                targetVal\n              });\n              if (returnVal !== void 0 && !returnVal) {\n                continue;\n              }\n            }\n            if (settings.beforeEach !== defaults.beforeEach) {\n              const returnVal = settings.beforeEach({\n                depth: mergeDepth,\n                key,\n                srcObj,\n                srcVal: mergeVal,\n                targetObj,\n                targetVal\n              });\n              if (returnVal !== void 0) {\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (typeof mergeVal === \"object\" && mergeVal !== null) {\n              if (circularRefs.has(srcObj[key])) {\n                const returnVal = settings.onCircular({\n                  depth: mergeDepth,\n                  key,\n                  srcObj,\n                  srcVal: srcObj[key],\n                  targetObj,\n                  targetVal\n                });\n                if (returnVal === void 0) {\n                  mergeVal = circularRefs.get(srcObj[key]);\n                  targetObj[key] = mergeVal;\n                  continue;\n                }\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (Array.isArray(mergeVal)) {\n              mergeVal = [...mergeVal];\n              if (Array.isArray(targetVal)) {\n                if (settings.appendArrays) {\n                  mergeVal = [...targetVal, ...mergeVal];\n                } else if (settings.prependArrays) {\n                  mergeVal = [...mergeVal, ...targetVal];\n                }\n              }\n              if (settings.dedupArrays) {\n                if (settings.afterEach !== defaults.afterEach) {\n                  mergeVal = [...new Set(mergeVal)];\n                } else {\n                  const keyArray = dedupArrayMap.get(targetObj);\n                  if (keyArray && !keyArray.includes(key)) {\n                    keyArray.push(key);\n                  } else {\n                    dedupArrayMap.set(targetObj, [key]);\n                  }\n                }\n              }\n              if (settings.sortArrays) {\n                if (settings.afterEach !== defaults.afterEach) {\n                  mergeVal = mergeVal.sort(sortArrayFn);\n                } else {\n                  const keyArray = sortArrayMap.get(targetObj);\n                  if (keyArray && !keyArray.includes(key)) {\n                    keyArray.push(key);\n                  } else {\n                    sortArrayMap.set(targetObj, [key]);\n                  }\n                }\n              }\n            } else if (isObject(mergeVal) && (!isReturnVal || !isPropDescriptor(mergeVal))) {\n              mergeDepth++;\n              if (isObject(targetVal)) {\n                mergeVal = _mergician(targetVal, mergeVal);\n              } else {\n                mergeVal = _mergician(mergeVal);\n              }\n              mergeDepth--;\n            }\n            if (settings.afterEach !== defaults.afterEach) {\n              const returnVal = settings.afterEach({\n                depth: mergeDepth,\n                key,\n                mergeVal,\n                srcObj,\n                targetObj\n              });\n              if (returnVal !== void 0) {\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (isReturnVal) {\n              if (isPropDescriptor(mergeVal)) {\n                mergeVal.configurable = true;\n                mergeVal.enumerable = !(\"enumerable\" in mergeVal) ? true : mergeVal.enumerable;\n                if (\"value\" in mergeVal && !(\"writable\" in mergeVal)) {\n                  mergeVal.writable = true;\n                }\n                Object.defineProperty(targetObj, key, mergeVal);\n              } else {\n                targetObj[key] = mergeVal;\n              }\n            } else {\n              const mergeDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n              if (mergeDescriptor && typeof mergeDescriptor.get === \"function\" && !settings.invokeGetters) {\n                if (settings.skipSetters) {\n                  mergeDescriptor.set = void 0;\n                }\n                mergeDescriptor.configurable = true;\n                Object.defineProperty(targetObj, key, mergeDescriptor);\n              } else {\n                targetObj[key] = mergeVal;\n              }\n            }\n          }\n          return targetObj;\n        }, {});\n        for (const [obj, keyArray] of dedupArrayMap.entries()) {\n          for (const key of keyArray) {\n            obj[key] = [...new Set(obj[key])];\n          }\n        }\n        for (const [obj, keyArray] of sortArrayMap.entries()) {\n          for (const key of keyArray) {\n            obj[key].sort(sortArrayFn);\n          }\n        }\n        return newObj;\n      }\n      if (arguments.length === 1) {\n        return function(...objects) {\n          if (arguments.length === 1) {\n            return mergician({ ...settings, ...objects[0] });\n          } else {\n            return _mergician(...objects);\n          }\n        };\n      } else {\n        return _mergician(...arguments);\n      }\n    }\n    module.exports = mergician;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (require_src());\n\n\n//# sourceURL=webpack://App/./node_modules/mergician/dist/mergician.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});